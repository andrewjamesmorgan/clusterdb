<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>join &#8211; Andrew Morgan on Databases</title>
	<atom:link href="./feed/index.html" rel="self" type="application/rss+xml" />
	<link>./../../index.html</link>
	<description>Database technologies - especially around scalability and High Availability</description>
	<lastBuildDate>Mon, 14 Dec 2015 11:51:52 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Joins and Other Aggregation Enhancements in MongoDB 3.2</title>
		<link>./../../mongodb/joins-and-other-aggregation-enhancements-in-mongodb-3-2/index.html</link>
					<comments>./../../mongodb/joins-and-other-aggregation-enhancements-in-mongodb-3-2/index.html#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Fri, 06 Nov 2015 16:09:09 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[aggregation]]></category>
		<category><![CDATA[join]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[MongoDB 3.2]]></category>
		<guid isPermaLink="false">./../../index.html?p=4140</guid>

					<description><![CDATA[This post looks at the aggregation enhancements being introduced in MongoDB 3.2 – most notably $lookup which implements left-outer equi-joins in the MongoDB Aggregation Framework. The material was originally published in a MongoDB blog series. It starts with an introduction to analyzing data with MongoDB. We then explain why joins are sometimes useful for MongoDB]]></description>
										<content:encoded><![CDATA[<p>This post looks at the aggregation enhancements being introduced in MongoDB 3.2 – most notably <code>$lookup</code> which implements left-outer equi-joins in the MongoDB Aggregation Framework. The material was originally published in a <a href="https://www.mongodb.com/blog/post/joins-and-other-aggregation-enhancements-coming-in-mongodb-3-2-part-1-of-3-introduction" title="Joins and Other Aggregation Enhancements Coming in MongoDB 3.2">MongoDB blog series</a>.</p>
<p>It starts with an introduction to analyzing data with MongoDB. We then explain why joins are sometimes useful for MongoDB – in spite of the strengths of the document model – and how developers have been working without them. It then works through examples of building aggregation pipelines – including using the operators added in MongoDB 3.2. After that, we look at how geolocation data can be included as well as what to do when you reach the limit of what can be done using a single pipeline – including adding wrapper code. Finally, there&#8217;s a summary of some of the limitations of the Aggregation Framework and reasons why you might supplement it with a full visualization solution such as <a href="http://www.tableau.com/">Tableau</a> together with MongoDB&#8217;s Connector for BI (Business Intelligence) – also new in MongoDB 3.2.</p>
<h2>
<a id="user-content-disclaimer" class="anchor" href="#disclaimer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Disclaimer</h2>
<p>MongoDB&#8217;s product plans are for informational purposes only. MongoDB&#8217;s plans may change and you should not rely on them for delivery of a specific feature at a specific time.</p>
<h2>
<a id="user-content-real-time-analytics-and-search" class="anchor" href="#real-time-analytics-and-search" aria-hidden="true"><span class="octicon octicon-link"></span></a>Real-Time Analytics and Search</h2>
<p>With the emergence of new data sources such as social media, mobile applications and sensor-equipped “Internet of Things” networks, organizations can extend analytics to deliver real-time insight and discovery into such areas as operational performance, customer satisfaction, and competitor behavior.</p>
<p>Time to value is everything. For example, having access to real-time customer sentiment or fleet tracking is of little benefit unless the data can be analyzed and reported in real-time.</p>
<p>MongoDB 3.2 aims to extend the options for performing analytics on the live, operational database – ensuring that answers are delivered quickly, and reflect current data. Work that would previously have needed to be done on the client side can now be performed by the database – freeing the developer to focus on new features. </p>
<h2>
<a id="user-content-the-case-for-joins" class="anchor" href="#the-case-for-joins" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Case for Joins</h2>
<p>MongoDB’s document data model is flexible and provides developers many options in terms of modeling their data. Most of the time all the data for a record tends to be located in a single document. For the operational application, accessing data is simple, high performance, and easy to scale with this approach. </p>
<p>When it comes to analytics and reporting, however, it is possible that the data you need to access spans multiple collections. This is illustrated in Figure 1, where the <code>_id</code> field of multiple documents from the <code>products</code> collection is included in a document from the <code>orders</code> collection. For a query to analyze orders and details about their associated products, it must fetch the order document from the <code>orders</code> collection and then use the embedded references to read multiple documents from the <code>products</code> collection. Prior to MongoDB 3.2, this work is implemented in application code. However, this adds complexity to the application and requires multiple round trips to the database, which can impact performance.</p>
<p><a href="https://camo.githubusercontent.com/381f8bf25b13cc8ed82c317cf62a273a5a555a10/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f53696d756c617465644c6566744f757465724a6f696e732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/381f8bf25b13cc8ed82c317cf62a273a5a555a10/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f53696d756c617465644c6566744f757465724a6f696e732e706e67" alt="Application-Layer simulation of joins between documents" title="Application-Layer simulation of joins between documents" data-canonical-src="http://clusterdb.com/upload/SimulatedLeftOuterJoins.png" style="max-width:100%;"></a><br />
<em>Figure 1: Application-Layer simulation of joins between documents</em></p>
<p>MongoDB 3.2 introduces the <code>$lookup</code> operator that can now be included as a stage in an aggregation pipeline. With this approach, the work of combining data from the orders and products collections is implemented within the database, and as part of a broader aggregation pipeline that performs other processing in a single query. As a result, there is less work to code in the application, and fewer round trips to the database. You can think about $lookup as equivalent to a left outer equi-join.</p>
<h3>
<a id="user-content-aside---what-is-a-left-outer-equi-join" class="anchor" href="#aside---what-is-a-left-outer-equi-join" aria-hidden="true"><span class="octicon octicon-link"></span></a>Aside &#8211; What is a Left Outer Equi-Join?</h3>
<p>A left outer equi-join produces a result set that contains data for all documents from the left table (collection) together with data from the right table (collection) for documents where there is a match with documents from the left table (collection). This is illustrated in Figure 2.</p>
<p><a href="https://camo.githubusercontent.com/3fd23b37ace2ba08cfb3744f7744ab11de630aa1/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f4c6566745f4f757465725f4a6f696e2e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/3fd23b37ace2ba08cfb3744f7744ab11de630aa1/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f4c6566745f4f757465725f4a6f696e2e706e67" alt="Left-Outer join between tables/collections" title="Left-Outer join between tables/collections" data-canonical-src="http://clusterdb.com/upload/Left_Outer_Join.png" style="max-width:100%;"></a><br />
<em>Figure 2: Left-Outer join between collections</em></p>
<h2>
<a id="user-content-mongodbs-aggregation-framework" class="anchor" href="#mongodbs-aggregation-framework" aria-hidden="true"><span class="octicon octicon-link"></span></a>MongoDB&#8217;s Aggregation Framework</h2>
<p>The Aggregation Framework is a pipeline for data aggregation modeled on the concept of data processing pipelines. Documents enter a multi-stage pipeline that transforms the documents into aggregated results. The pipeline consists of stages; each stage transforms the documents as they pass through.</p>
<p>In general, each successive stage reduces the volume of data; removing information that isn&#8217;t needed and combining other data to produce summarized results.</p>
<p>Figure 3 shows a conceptual model for the Aggregation Framework pipeline. This is what&#8217;s happening at each stage:</p>
<ul>
<li>On the left-hand side/start of the pipeline is the original collection contents – each record (document) containing a number of shapes (keys), each with a particular color (value)</li>
<li>The <code>$match</code> stage filters out any documents that don&#8217;t contain a red diamond</li>
<li>The <code>$project</code> stage adds a new “square” attribute with a value computed from the value (color) of the snowflake and triangle attributes</li>
<li>The <code>$lookup</code> stage (new in 3.2 &#8211; more details later) performs a left-outer join with another collection, with the star being the comparison key. This creates new documents which contain everything from the previous stage but augmented with data from any document from the second collection containing a matching colored star (i.e., the blue and yellow stars had matching “lookup” values, whereas the red star had none).</li>
<li>Finally, the <code>$group</code> stage groups the data by the color of the square and produces statistics (sum, average and standard deviation) for each group.</li>
</ul>
<p><a href="https://camo.githubusercontent.com/4861c2c6c2d2e68978a8e8c7e97c3e8b3dd0114c/687474703a2f2f7777772e636c757374657264622e636f6d2f75706c6f61642f4d6f6e676f44425f4167677265676174696f6e5f506970656c696e652e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/4861c2c6c2d2e68978a8e8c7e97c3e8b3dd0114c/687474703a2f2f7777772e636c757374657264622e636f6d2f75706c6f61642f4d6f6e676f44425f4167677265676174696f6e5f506970656c696e652e706e67" alt="MongoDB Aggregation Framework Pipeline" title="MongoDB Aggregation Framework Pipeline" data-canonical-src="./../../upload/MongoDB_Aggregation_Pipeline.png" style="max-width:100%;"></a><br />
<em>Figure 3: MongoDB Aggregation Framework pipeline</em></p>
<p>This is the full set of aggregation stages:</p>
<ul>
<li>
<code>$match</code> – Filter documents</li>
<li>
<code>$geoNear</code> – Sort documents based on geographic proximity</li>
<li>
<code>$project</code> – Reshape documents (remove or rename keys or add new data based on calculations on the existing data)</li>
<li>
<code>$lookup</code> – <strong>Coming in 3.2</strong> – Left-outer joins</li>
<li>
<code>$unwind</code> – Expand documents (for example create multiple documents where each contains one element from an array from the original document)</li>
<li>
<code>$group</code> – Summarize documents</li>
<li>
<code>$sample</code> – Randomly selects a subset of documents</li>
<li>
<code>$sort</code> – Order documents</li>
<li>
<code>$skip</code> – Jump over a number of documents</li>
<li>
<code>$limit</code> – Limit number of documents</li>
<li>
<code>$redact</code> – Restrict sensitive content from documents</li>
<li>
<code>$out</code> – <em>Coming in 3.2</em>* – store the results in a new collection</li>
</ul>
<p>The details can be found in the <a href="http://docs.mongodb.org/manual/reference/operator/aggregation-pipeline/" title="Pipeline Aggregation Stages">documentation</a>.</p>
<h3>
<a id="user-content-new-aggregation-operators-in-mongodb-32" class="anchor" href="#new-aggregation-operators-in-mongodb-32" aria-hidden="true"><span class="octicon octicon-link"></span></a>New Aggregation Operators in MongoDB 3.2</h3>
<p>There are operators used within each stage and this set is being extended in MongoDB 3.2 to include:</p>
<ul>
<li>Array operations
<ul>
<li>
<code>$slice</code>, <code>$arrayElemAt</code>, <code>$concatArrays</code>, <code>$isArray</code>, <code>$filter</code>, <code>$min</code>, <code>$max</code>, <code>$avg</code> and <code>$sum</code> (some of these were previously available in a <code>$group</code> stage but not in <code>$project</code>
</li>
</ul>
</li>
<li>Standard Deviations
<ul>
<li>
<code>$stdDevSamp</code> (based on a sample) and <code>$stdDevPop</code> (based on the complete population)</li>
</ul>
</li>
<li>Square Root
<ul>
<li><code>$sqrt</code></li>
</ul>
</li>
<li>Absolute (make +ve) value
<ul>
<li><code>$abs</code></li>
</ul>
</li>
<li>Rounding numbers
<ul>
<li>
<code>$trunc</code>, <code>$ceil</code>, <code>$floor</code>
</li>
</ul>
</li>
<li>Logarithms
<ul>
<li>
<code>$log</code>, <code>$log10</code>, <code>$ln</code>
</li>
</ul>
</li>
<li>Raise to power
<ul>
<li><code>$pow</code></li>
</ul>
</li>
<li>Natural Exponent
<ul>
<li><code>$exp</code></li>
</ul>
</li>
</ul>
<p>Further details on these new operators can be found in the MongoDB 3.2 Release Notes.</p>
<h2>
<a id="user-content-lookup--left-outer-equi-joins" class="anchor" href="#lookup--left-outer-equi-joins" aria-hidden="true"><span class="octicon octicon-link"></span></a>$lookup – Left Outer Equi-Joins</h2>
<p>Figure 4 illustrates the syntax for performing the join:</p>
<ul>
<li>
<code>leftCollection</code> is the collection that the aggregation is being performed on and is the <em>left</em> collection in the join</li>
<li>
<code>from</code> identifies the collection that it will be joined with – the <em>right</em> collection (<code>rightCollection</code> in this case)</li>
<li>
<code>localField</code> specifies the key from the original/left collection – <code>leftVal</code>
</li>
<li>
<code>foreignField</code> specifies the key from the right collection – <code>rightVal</code>
</li>
<li>
<code>as</code> indicates that the data from the right collection should be embedded within the resulting documents as an array called <code>embeddedData</code>
</li>
</ul>
<p><a href="https://camo.githubusercontent.com/fdd7e396bb467e8d541289fa983c8cd334e64e77/687474703a2f2f7777772e636c757374657264622e636f6d2f75706c6f61642f246c6f6f6b75705f4d6f6e676f44425f4a6f696e732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/fdd7e396bb467e8d541289fa983c8cd334e64e77/687474703a2f2f7777772e636c757374657264622e636f6d2f75706c6f61642f246c6f6f6b75705f4d6f6e676f44425f4a6f696e732e706e67" alt="$lookup – Left-Outer Joins for MongoDB" title="$lookup – Left-Outer Joins for MongoDB" data-canonical-src="./../../upload/$lookup_MongoDB_Joins.png" style="max-width:100%;"></a><br />
<em>Figure 4: $lookup – Left-Outer Joins for MongoDB</em></p>
<p>In the follow-on blogs in this series, you’ll see how the data from a home sales collection (containing details of each home sale, including the property’s postal code) is joined with data from a postal code collection (containing postal codes and their geographical location). This produces documents that contain the original home sale information augmented with the coordinates of the property. In this case, the “homesales” collection is the left-collection and “postcodes” the right-collection; the “postcode” field from each collection is the <code>localField</code> which is matched with the <code>foreignField</code>.</p>
<h2>
<a id="user-content-worked-examples" class="anchor" href="#worked-examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Worked Examples</h2>
<h3>
<a id="user-content-the-data-set" class="anchor" href="#the-data-set" aria-hidden="true"><span class="octicon octicon-link"></span></a>The Data Set</h3>
<p>The examples use two data sets, the first being a comprehensive set of home sale data for a town and the second being a mapping from postal codes to geospatial locations for that same town.</p>
<p><em>For those interested, the imported data sets needed some cleaning up to make this walkthrough more useful &#8211; <a href="http://clusterdb.com/upload/DataSet_CleanUp.html" title="Cleaning up the data sets">the steps are described here</a>.</em></p>
<p>The two data sets can be checked using the <code>mongo</code> shell:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.findOne()
{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>56005dd980c3678b19792b7f<span class="pl-pds">"</span></span>),
  <span class="pl-s"><span class="pl-pds">"</span>amount<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">9000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>1996-09-19T00:00:00Z<span class="pl-pds">"</span></span>),
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">25</span>,
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>NORFOLK PARK COTTAGES<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 7DR<span class="pl-pds">"</span></span>
  }
}

db.postcodes.findOne()
{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>5600521e50fa77da54dfc0d2<span class="pl-pds">"</span></span>),
  <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 0AA<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
      <span class="pl-c1">51.525605</span>,
      <span class="pl-k">-</span><span class="pl-c1">0.700974</span>
    ]
  }
}</pre>
</div>
<p>An even better option to understand the contents of these collections is to use <a href="https://youtu.be/3w9HVFh1hRs">MongoDB Compass</a> (to be released with MongoDB 3.2). Figure 1 shows an overview of the <code>homeSales</code> collection and Figure 2 delves into its <code>address</code> sub-document.</p>
<p>
These datasets (the <code>homeSales</code> and <code>postcodes</code> collections) can be <a href="./../../upload/SalesData.tar.gz" name="datasets for $lookup" alt="Download datasets used in this post">downloaded here</a>.
</p>
<p><a href="https://camo.githubusercontent.com/76e2d4bcdb1802474cc548b8b58891d3ed02d04b/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d706173735f566965775f6f665f686f6d6553616c65732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/76e2d4bcdb1802474cc548b8b58891d3ed02d04b/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d706173735f566965775f6f665f686f6d6553616c65732e706e67" alt="MongoDB Compass View of homeSales Collection" title="MongoDB Compass View of homeSales Collection" data-canonical-src="http://clusterdb.com/upload/Compass_View_of_homeSales.png" style="max-width:100%;"></a><br />
<em>Figure 1: MongoDB Compass View of the homeSales Collection</em></p>
<p><a href="https://camo.githubusercontent.com/e0738db602146dee4a570b4e578274cc5746f97c/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d706173735f686f6d6553616c65735f416464726573732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/e0738db602146dee4a570b4e578274cc5746f97c/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d706173735f686f6d6553616c65735f416464726573732e706e67" alt="Viewing Sub-Documents With MongoDB Compass" title="Viewing Sub-Documents With MongoDB Compass" data-canonical-src="http://clusterdb.com/upload/Compass_homeSales_Address.png" style="max-width:100%;"></a><br />
<em>Figure 2: Viewing Sub-Documents With MongoDB Compass</em></p>
<h3>
<a id="user-content-building-the-first-pipeline" class="anchor" href="#building-the-first-pipeline" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building the First Pipeline</h3>
<p>As the error messages from complex pipelines aren&#8217;t always very specific, it makes sense to start with a simple pipeline and then check the results before moving onto the next.</p>
<p>As a collection&#8217;s indexes are only used for the beginning stages in the pipeline (before any transformations are performed), it is often sensible to reduce the result set as much as possible with a <code>$match</code> stage to filter out any unnecessary documents. Ideally, the match would be against the sharding key so that fewer shards need to be included. For the first pipeline stage the cheaper property sales are going to excluded and so it would help to have a secondary index on the <code>amount</code> key:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.createIndex({amount<span class="pl-k">:</span> <span class="pl-c1">1</span>})</pre>
</div>
<p>The first stage in the pipeline then filters out any sales of less than £3,000,000:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {$match<span class="pl-k">:</span> {
    amount<span class="pl-k">:</span> {$gte<span class="pl-k">:</span><span class="pl-c1">3000000</span>}}
  }
  ])</pre>
</div>
<p>The results can then be inspected to understand what will flow into the next stage in the pipeline:</p>
<div class="highlight highlight-source-js">
<pre>{
    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>56005dda80c3678b19799e52<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>amount<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">3000000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>2012-04-19T00:00:00Z<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>TEMPLE FERRY PLACE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MILL LANE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 5ND<span class="pl-pds">"</span></span>
      }
    },

...

    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>56005dda80c3678b19799e5c<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>amount<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">5425000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>1999-03-15T00:00:00Z<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>2 - 3<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>THE SWITCHBACK<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 7RJ<span class="pl-pds">"</span></span>
      }
    }</pre>
</div>
<p>In the next stage, a left-outer join is performed – using <code>$lookup</code> – to find documents from the <code>postcodes</code> collection with a matching postcode so that the geographic location can be determined:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {$match<span class="pl-k">:</span> {
    amount<span class="pl-k">:</span> {$gte<span class="pl-k">:</span><span class="pl-c1">3000000</span>}}
  }, 
  {$lookup<span class="pl-k">:</span> {
    from<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcodes<span class="pl-pds">"</span></span>, 
    localField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>address.postcode<span class="pl-pds">"</span></span>,
    foreignField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span>,
    as<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode_docs<span class="pl-pds">"</span></span>}
  }
])</pre>
</div>
<p>Which yields these results:</p>
<div class="highlight highlight-source-js">
<pre>{
    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>56005dda80c3678b19799e52<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>amount<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">3000000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>2012-04-19T00:00:00Z<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>TEMPLE FERRY PLACE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MILL LANE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 5ND<span class="pl-pds">"</span></span>
      },
      <span class="pl-s"><span class="pl-pds">"</span>postcode_docs<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>560053e280c3678b1978b293<span class="pl-pds">"</span></span>),
          <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 5ND<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
            <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
              <span class="pl-c1">51.549516</span>,
              <span class="pl-k">-</span><span class="pl-c1">0.80702</span>
            ]
          }
        }
      ]
    },

...

      <span class="pl-s"><span class="pl-pds">"</span>postcode_docs<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>560053e280c3678b1978b524<span class="pl-pds">"</span></span>),
          <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 7RJ<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
            <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
              <span class="pl-c1">51.536848</span>,
              <span class="pl-k">-</span><span class="pl-c1">0.735835</span>
            ]
          }
        }
      ]
    }</pre>
</div>
<p>The pipeline can then be extended with a <code>$project</code> stage to refactor the documents, removing any information that isn&#8217;t needed. The documents are then sorted in reverse-price order:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {$match<span class="pl-k">:</span> {
    amount<span class="pl-k">:</span> {$gte<span class="pl-k">:</span><span class="pl-c1">3000000</span>}}
  }, 
  {$lookup<span class="pl-k">:</span> {
    from<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcodes<span class="pl-pds">"</span></span>, 
    localField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>address.postcode<span class="pl-pds">"</span></span>,
    foreignField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span>,
    as<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode_docs<span class="pl-pds">"</span></span>}
  },
  {$project<span class="pl-k">:</span> {
    _id<span class="pl-k">:</span> <span class="pl-c1">0</span>,
    saleDate<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>,
    price<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>,
    address<span class="pl-k">:</span> <span class="pl-c1">1</span>,
    location<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$postcode_docs.location<span class="pl-pds">"</span></span>}},
  {$sort<span class="pl-k">:</span>
    {
      price<span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
    }}
])</pre>
</div>
<p>The address and physical location of every home sale, starting with the most expensive is then shown:</p>
<div class="highlight highlight-source-js">
<pre>    {
      <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>2 - 3<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>THE SWITCHBACK<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 7RJ<span class="pl-pds">"</span></span>
      },
      <span class="pl-s"><span class="pl-pds">"</span>saleDate<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>1999-03-15T00:00:00Z<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">5425000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
            <span class="pl-c1">51.536848</span>,
            <span class="pl-k">-</span><span class="pl-c1">0.735835</span>
          ]
        }
      ]
    },

...

    {
      <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>nameOrNumber<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>TEMPLE FERRY PLACE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MILL LANE<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>town<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>county<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>WINDSOR AND MAIDENHEAD<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 5ND<span class="pl-pds">"</span></span>
      },
      <span class="pl-s"><span class="pl-pds">"</span>saleDate<span class="pl-pds">"</span></span><span class="pl-k">:</span> ISODate(<span class="pl-s"><span class="pl-pds">"</span>2012-04-19T00:00:00Z<span class="pl-pds">"</span></span>),
      <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">3000000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>location<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        {
          <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
            <span class="pl-c1">51.549516</span>,
            <span class="pl-k">-</span><span class="pl-c1">0.80702</span>
          ]
        }
      ]
    }</pre>
</div>
<h3>
<a id="user-content-building-further-pipelines" class="anchor" href="#building-further-pipelines" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building Further Pipelines</h3>
<p>If all of the sales need to be analyzed (rather than just the most expensive few) then there would be too many results from the previous pipeline to be easily understood. For this reason, the pipeline is modified so that extra analysis and aggregation is performed within the database. This can be done using a <code>$group</code> stage – in this case to produce sales statistics by year:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {
    $group<span class="pl-k">:</span> 
    {
      _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>},
      higestPrice<span class="pl-k">:</span> {$max<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      lowestPrice<span class="pl-k">:</span> {$min<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      averagePrice<span class="pl-k">:</span> {$avg<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      priceStdDev<span class="pl-k">:</span> {$stdDevPop<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>}
    }
  },
  {
    $sort<span class="pl-k">:</span> {_id<span class="pl-k">:</span> <span class="pl-c1">1</span>}
  }
])</pre>
</div>
<div class="highlight highlight-source-js">
<pre>    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1995</span>,
      <span class="pl-s"><span class="pl-pds">"</span>higestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1000000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">12000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">114059.35206869633</span>,
      <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">81540.50490801703</span>
    },

...

    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
      <span class="pl-s"><span class="pl-pds">"</span>higestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1688000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">125000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">451413.23917137476</span>,
      <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">228293.6005201898</span>
    }

</pre>
</div>
<p>Note that this is using the <code>$stdDevPop</code> (standard deviation) aggregation operator being introduced in MongoDB 3.2.</p>
<p>There&#8217;s more precision than needed for some of the keys and so a common pattern can be employed – use a final <code>$project</code> stage to tidy up the data:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {
    $group<span class="pl-k">:</span> 
    {
      _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>},
      higestPrice<span class="pl-k">:</span> {$max<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      lowestPrice<span class="pl-k">:</span> {$min<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      averagePrice<span class="pl-k">:</span> {$avg<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      priceStdDev<span class="pl-k">:</span> {$stdDevPop<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>}
    }
  },
  {
    $sort<span class="pl-k">:</span> {_id<span class="pl-k">:</span> <span class="pl-c1">1</span>}
  },
  {
    $project<span class="pl-k">:</span>
    {
      _id<span class="pl-k">:</span> <span class="pl-c1">1</span>,
      higestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
      lowestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
      averagePrice<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$averagePrice<span class="pl-pds">"</span></span>},
      priceStdDev<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceStdDev<span class="pl-pds">"</span></span>}
    }
  }
])</pre>
</div>
<div class="highlight highlight-source-js">
<pre>
    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1995</span>,
      <span class="pl-s"><span class="pl-pds">"</span>higestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1000000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">12000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">114059</span>,
      <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">81540</span>
    },

...

    {
      <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
      <span class="pl-s"><span class="pl-pds">"</span>higestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1688000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">125000</span>,
      <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">451413</span>,
      <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">228293</span>
    }</pre>
</div>
<p>It often makes sense to store the results in a new collection – either because the results will be reused many times or that subsequent aggregation pipelines will reference them. This is simple to achieve using a <code>$out</code> stage; note that:</p>
<ul>
<li>If the target collection already exists then its contents will be overwritten</li>
<li>If used then the <code>$out</code> must be the final stage in the pipeline</li>
</ul>
<p>The following example writes the results to a collection called <code>annualHomePrices</code>:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
  {
    $group<span class="pl-k">:</span> 
    {
      _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>},
      highestPrice<span class="pl-k">:</span> {$max<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      lowestPrice<span class="pl-k">:</span> {$min<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      averagePrice<span class="pl-k">:</span> {$avg<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>},
      priceStdDev<span class="pl-k">:</span> {$stdDevPop<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$amount<span class="pl-pds">"</span></span>}
    }
  },
  {
    $sort<span class="pl-k">:</span> {_id<span class="pl-k">:</span> <span class="pl-c1">1</span>}
  },
  {
    $project<span class="pl-k">:</span>
    {
      _id<span class="pl-k">:</span> <span class="pl-c1">0</span>,
      year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$_id<span class="pl-pds">"</span></span>,
      highestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
      lowestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
      averagePrice<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$averagePrice<span class="pl-pds">"</span></span>},
      priceStdDev<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceStdDev<span class="pl-pds">"</span></span>}
    }
  },
  {
    $out<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>annualHomePrices<span class="pl-pds">"</span></span>
  }
])</pre>
</div>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">&gt;</span> db.annualHomePrices.findOne()
{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>560957ac29a5574d557d426d<span class="pl-pds">"</span></span>),
  <span class="pl-s"><span class="pl-pds">"</span>highestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1000000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">12000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">114059</span>,
  <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">81540</span>,
  <span class="pl-s"><span class="pl-pds">"</span>year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1995</span>
}</pre>
</div>
<p>These &#8220;interim&#8221; results could then be used to build further result sets – without the need to run all of that processing again. As an example, using a simple <code>$project</code> stage, the gap between the highest and lowest house sale can be calculated for each year:</p>
<div class="highlight highlight-source-js">
<pre>db.annualHomePrices.aggregate([
  {$project<span class="pl-k">:</span> 
    {
      Year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$year<span class="pl-pds">"</span></span>,
      hightToLowPriceGap<span class="pl-k">:</span> {
        $subtract<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>$highestPrice<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>$lowestPrice<span class="pl-pds">"</span></span>]
      },
      _id<span class="pl-k">:</span> <span class="pl-c1">0</span>
    }
  }
])</pre>
</div>
<div class="highlight highlight-source-js">
<pre>{
   <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2012</span>,
   <span class="pl-s"><span class="pl-pds">"</span>hightToLowPriceGap<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2923000</span>
},
{
   <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2013</span>,
   <span class="pl-s"><span class="pl-pds">"</span>hightToLowPriceGap<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">5092250</span>
},
{
   <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2014</span>,
   <span class="pl-s"><span class="pl-pds">"</span>hightToLowPriceGap<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">3883050</span>
},
{
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
  <span class="pl-s"><span class="pl-pds">"</span>hightToLowPriceGap<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1563000</span>
}</pre>
</div>
<p>As a final stage in this post, a pipeline is built to find the postal code and geographic location of the most expensive house sale for each of the recorded years:<br />
Perform a <code>$sort</code> on the full <code>homeSales</code> data set so that the documents are ordered from most expensive sale first<br />
<code>$group</code> the results based on the year of the home sale, deriving the <code>priciestPostCode</code> from the <code>$first</code> document in that group (year). Because the documents were sorted on price before entering the <code>group</code> stage, the first document is also the one with the highest price<br />
<code>$lookup</code> the postal code in the <code>postcodes</code> collection to get the geolocation data<br />
<code>$sort</code> the results by year<br />
<code>$project</code> just the data that is of interest</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
    {
      $sort<span class="pl-k">:</span> {amount<span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>}
    },
    {
      $group<span class="pl-k">:</span>
      {
        _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>},
        priciestPostCode<span class="pl-k">:</span> {$first<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$address.postcode<span class="pl-pds">"</span></span>}
      }
    },
    {
      $lookup<span class="pl-k">:</span>
      {
        from<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcodes<span class="pl-pds">"</span></span>,
        localField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>priciestPostCode<span class="pl-pds">"</span></span>,
        foreignField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span>,
        as<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>locationData<span class="pl-pds">"</span></span>
      }
    },
    {
      $sort<span class="pl-k">:</span> {_id<span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>}
    },
    {
      $project<span class="pl-k">:</span>
      {
        _id<span class="pl-k">:</span> <span class="pl-c1">0</span>,
        Year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$_id<span class="pl-pds">"</span></span>,
        PostCode<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priciestPostCode<span class="pl-pds">"</span></span>,
        <span class="pl-c1">Location</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$locationData.location<span class="pl-pds">"</span></span>
      }
    }
  ])</pre>
</div>
<div class="highlight highlight-source-js">
<pre>{
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
  <span class="pl-s"><span class="pl-pds">"</span>PostCode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 9UD<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Location<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
    {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        <span class="pl-c1">51.558455</span>,
        <span class="pl-k">-</span><span class="pl-c1">0.756023</span>
      ]
    }
  ]
},
{
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2014</span>,
  <span class="pl-s"><span class="pl-pds">"</span>PostCode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 1UP<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Location<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
    {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        <span class="pl-c1">51.51407</span>,
        <span class="pl-k">-</span><span class="pl-c1">0.704414</span>
      ]
    }
  ]
},
...</pre>
</div>
<h2>
<a id="user-content-adding-some-coding-glue-and-geolocation" class="anchor" href="#adding-some-coding-glue-and-geolocation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Adding Some Coding Glue and Geolocation</h2>
<p>Obviously, there are limits as to how much can be achieved with a single aggregation pipeline but with the addition of just a little code outside of the database (in this example, JavaScript in the <code>mongo</code> shell), additional results can be produced.</p>
<p>We start by repeating an aggregation from the previous section but store the data in a collection so that we can build upon those results:</p>
<div class="highlight highlight-source-js">
<pre>db.homeSales.aggregate([
    {
      $sort<span class="pl-k">:</span> {amount<span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>}
    },
    {
      $group<span class="pl-k">:</span>
      {
        _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$date<span class="pl-pds">"</span></span>},
        priciestPostCode<span class="pl-k">:</span> {$first<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$address.postcode<span class="pl-pds">"</span></span>}
      }
    },
    {
      $lookup<span class="pl-k">:</span>
      {
        from<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcodes<span class="pl-pds">"</span></span>,
        localField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>priciestPostCode<span class="pl-pds">"</span></span>,
        foreignField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span>,
        as<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>locationData<span class="pl-pds">"</span></span>
      }
    },
    {
      $sort<span class="pl-k">:</span> {_id<span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>}
    },
    {
      $project<span class="pl-k">:</span>
      {
        _id<span class="pl-k">:</span> <span class="pl-c1">0</span>,
        Year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$_id<span class="pl-pds">"</span></span>,
        PostCode<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priciestPostCode<span class="pl-pds">"</span></span>,
        <span class="pl-c1">Location</span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$locationData.location<span class="pl-pds">"</span></span>
      }
    },
    {
      $out<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>hottestLocations<span class="pl-pds">"</span></span>
    }
  ])</pre>
</div>
<div class="highlight highlight-source-js">
<pre>db.hottestLocations.findOne()
{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> ObjectId(<span class="pl-s"><span class="pl-pds">"</span>5629108c96be45aba9cb0c98<span class="pl-pds">"</span></span>),
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
  <span class="pl-s"><span class="pl-pds">"</span>PostCode<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>SL6 9UD<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Location<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
    {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
        <span class="pl-c1">51.558455</span>,
        <span class="pl-k">-</span><span class="pl-c1">0.756023</span>
      ]
    }
  ]
}</pre>
</div>
<p>In this example, geospatial operations are performed on the <code>location</code> from the <code>postcodes</code> collection and so a geospatial index should be added:</p>
<div class="highlight highlight-source-js">
<pre>db.postcodes.createIndex({location<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>2dsphere<span class="pl-pds">"</span></span>})</pre>
</div>
<p>A function is created that, given a location, will find the five nearest postcodes – taking advantage of a <code>$geoNear</code> stage – note that this must be the first stage in the pipeline:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">var</span> <span class="pl-en">findNeighbours</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">spot</span>, <span class="pl-smi">yearTag</span>) {
  <span class="pl-k">var</span> result <span class="pl-k">=</span> db.postcodes.aggregate([
      {
        $geoNear<span class="pl-k">:</span>
        {
          near<span class="pl-k">:</span> spot,
          distanceField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>distance<span class="pl-pds">"</span></span>,
          num<span class="pl-k">:</span> <span class="pl-c1">5</span>,
          spherical<span class="pl-k">:</span> <span class="pl-c1">true</span>
        }
      },
      {
        $group<span class="pl-k">:</span> {
          _id<span class="pl-k">:</span> yearTag,
          <span class="pl-s"><span class="pl-pds">"</span>neighbours<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
            $addToSet<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$postcode<span class="pl-pds">"</span></span>
          }
        }
      }
    ]);
  <span class="pl-k">return</span> result.result;
}</pre>
</div>
<p>Then, for each of the <code>hottestLocations</code> collection, that function is called to display and the contents of the returned cursor are displayed:</p>
<div class="highlight highlight-source-js">
<pre>db.hottestLocations.<span class="pl-c1">find</span>().forEach(<span class="pl-k">function</span>(<span class="pl-smi">myDoc</span>) {
  <span class="pl-k">var</span> myCursor <span class="pl-k">=</span> findNeighbours(myDoc.<span class="pl-c1">Location</span>[<span class="pl-c1">0</span>], myDoc.Year);
  myCursor.forEach(printjson);
})</pre>
</div>
<p>The result is a list of the 5 closest postcodes to the top selling home each year:</p>
<div class="highlight highlight-source-js">
<pre>{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1995</span>,
  <span class="pl-s"><span class="pl-pds">"</span>neighbours<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
    <span class="pl-s"><span class="pl-pds">"</span>SL6 2NL<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 2JL<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 2NB<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 2JN<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 2NA<span class="pl-pds">"</span></span>
  ]
}

...

{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>,
  <span class="pl-s"><span class="pl-pds">"</span>neighbours<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
    <span class="pl-s"><span class="pl-pds">"</span>SL6 9XB<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 9XL<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 9UE<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 9UB<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>SL6 9UD<span class="pl-pds">"</span></span>
  ]
}</pre>
</div>
<h2>
<a id="user-content-bonus-query--for-those-choosing-a-school" class="anchor" href="#bonus-query--for-those-choosing-a-school" aria-hidden="true"><span class="octicon octicon-link"></span></a>Bonus Query – For Those Choosing a School</h2>
<p>There&#8217;s often a correlation between the house prices near a school and that school&#8217;s performance. So, if you were considering a specific school then it might make sense to check house prices in the area surrounding that school. </p>
<p>The following pipeline will find house price statistics, by year, for all postcodes within a 3 km radius of the school – which is located at coordinates (51.5156725, -0.727387):</p>
<div class="highlight highlight-source-js">
<pre>db.postcodes.aggregate([
      {
        $geoNear<span class="pl-k">:</span>
        {
          near<span class="pl-k">:</span> 
          {
            <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Point<span class="pl-pds">"</span></span>,
            <span class="pl-s"><span class="pl-pds">"</span>coordinates<span class="pl-pds">"</span></span><span class="pl-k">:</span> [
              <span class="pl-c1">51.5156725</span>,
              <span class="pl-k">-</span><span class="pl-c1">0.727387</span>
            ]},
          distanceField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>distance<span class="pl-pds">"</span></span>,
          num<span class="pl-k">:</span> <span class="pl-c1">10000</span>,
          maxDistance<span class="pl-k">:</span> <span class="pl-c1">3000</span>,
          spherical<span class="pl-k">:</span> <span class="pl-c1">true</span>
        }
      },
      {
        $lookup<span class="pl-k">:</span> {
          from<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>homeSales<span class="pl-pds">"</span></span>,
          localField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>postcode<span class="pl-pds">"</span></span>,
          foreignField<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>address.postcode<span class="pl-pds">"</span></span>,
          as<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>priceData<span class="pl-pds">"</span></span>
        }
      },
      {
        $unwind<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData<span class="pl-pds">"</span></span>
      },

      {
        $group<span class="pl-k">:</span> 
        {
          _id<span class="pl-k">:</span> {$year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData.date<span class="pl-pds">"</span></span>},
          highestPrice<span class="pl-k">:</span> {$max<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData.amount<span class="pl-pds">"</span></span>},
          lowestPrice<span class="pl-k">:</span> {$min<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData.amount<span class="pl-pds">"</span></span>},
          averagePrice<span class="pl-k">:</span> {$avg<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData.amount<span class="pl-pds">"</span></span>},
          priceStdDev<span class="pl-k">:</span> {$stdDevPop<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceData.amount<span class="pl-pds">"</span></span>}
        }
      },
      {
        $project<span class="pl-k">:</span>
        {
          _id<span class="pl-k">:</span> <span class="pl-c1">0</span>,
          Year<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>,
          highestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
          lowestPrice<span class="pl-k">:</span> <span class="pl-c1">1</span>,
          averagePrice<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$averagePrice<span class="pl-pds">"</span></span>},
          priceStdDev<span class="pl-k">:</span> {$trunc<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$priceStdDev<span class="pl-pds">"</span></span>}
        }
      },
      {
        $sort<span class="pl-k">:</span> 
        {
          <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-k">-</span><span class="pl-c1">1</span>
        }
      }
    ]);</pre>
</div>
<div class="highlight highlight-source-js">
<pre>{
  <span class="pl-s"><span class="pl-pds">"</span>highestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1350000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">125000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">410593</span>,
  <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">182358</span>,
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2015</span>
},
...
{
  <span class="pl-s"><span class="pl-pds">"</span>highestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">930000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>lowestPrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">12000</span>,
  <span class="pl-s"><span class="pl-pds">"</span>averagePrice<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">103455</span>,
  <span class="pl-s"><span class="pl-pds">"</span>priceStdDev<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">68615</span>,
  <span class="pl-s"><span class="pl-pds">"</span>Year<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1995</span>
}</pre>
</div>
<h2>
<a id="user-content-limitations" class="anchor" href="#limitations" aria-hidden="true"><span class="octicon octicon-link"></span></a>Limitations</h2>
<p>As seen, it’s possible to build up sophisticated analytical queries using the enhanced aggregation features – especially when pipelines are combined with a little application or scripting glue. </p>
<p>Some limitations that you may meet include:</p>
<ul>
<li>
<code>$geoNear</code> can only be used as the first stage in the pipeline</li>
<li>
<code>$lookup</code> only supports equality for the match and the equality has to be between a single key from each collection</li>
<li>The right-collection for <code>$lookup</code> cannot be sharded</li>
<li>The pipeline is linear; there are no forks and once data has been aggregated, the lost details can&#8217;t be reused later in the pipeline (this is why writing results to a new collection using <code>$out</code> can be helpful)</li>
<li>One can remove information at each stage but it&#8217;s impossible to add new raw data (other than through <code>$lookup</code>)</li>
<li>Indexes are only used for the beginning stages of the pipeline (and right tables in any subsequent <code>$lookup</code>)</li>
<li>
<code>$out</code> can only be used in the final stage of the pipeline</li>
</ul>
<h2>
<a id="user-content-when-to-use-full-data-visualization-solutions" class="anchor" href="#when-to-use-full-data-visualization-solutions" aria-hidden="true"><span class="octicon octicon-link"></span></a>When to Use Full Data Visualization Solutions</h2>
<p>A lot can be achieved directly in the database – especially when augmented with a small amount of code. So when would it make sense to use a BI visualization tool such as Tableau. The capabilities will vary from product to product but some general considerations are given here:</p>
<ul>
<li>
<strong>Visualization</strong> – displaying information in graphs and on maps (rather than in JSON result sets) makes it much simpler for the human mind to see patterns and draw conclusions from the data (see Figure 1 which is based on the same data set used earlier and graphically shows the highest home sale price by location and year)</li>
<li>
<strong>Multiple Data Sources</strong> – combining data from multiple sources (data blending); for example from a MongoDB database and an Excel spreadsheet can greatly broaden the context of reports</li>
<li>
<strong>Interactivity</strong> – visualization tools make it simple to create interactive queries/dashboards where business user can graphically tweak parameters to get precise results and test theories</li>
<li>
<strong>Skills</strong> – performing all of the analytics directly in MongoDB requires knowledge of the MongoDB Query Language and possibly some basic coding skills. Using the visualization tools is analogous to using intermediate features in Microsoft Excel such as pivot tables and graphs and so it opens up the ability to analyze the data to a broader set of users in the organization</li>
<li>
<strong>Extra functions</strong> – for example, the ability to add trend lines to a chart</li>
</ul>
<p><a href="https://camo.githubusercontent.com/c06051cc9b7415379160844df37fd39da4c75e38/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f5461626c6561755f4d6f6e676f44425f446174612e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/c06051cc9b7415379160844df37fd39da4c75e38/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f5461626c6561755f4d6f6e676f44425f446174612e706e67" alt="MongoDB Data Visualized in a Tableau Map" title="MongoDB Data Visualized in a Tableau Map" data-canonical-src="http://clusterdb.com/upload/Tableau_MongoDB_Data.png" style="max-width:100%;"></a><br />
<em>Figure 1: MongoDB Data Visualized in a Tableau Map</em></p>
<p>MongoDB 3.2 introduces the MongoDB Connector for BI which allows Business Intelligence tools such as Tableau to access data from MongoDB using SQL – opening up a range of new options for performing analytics on live data.</p>
<h2>
<a id="user-content-next-steps" class="anchor" href="#next-steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Next Steps</h2>
<p>To learn more about what&#8217;s coming up in MongoDB 3.2, register for the <a href="https://www.mongodb.com/webinar/whats-new-in-mongodb-3-2">What&#8217;s new in MongoDB 3.2 webinar</a> and review the <a href="https://docs.mongodb.org/manual/release-notes/3.2/">MongoDB 3.2 release notes</a>.</p>
<p>There&#8217;s a <a href="https://www.mongodb.com/presentations/webinar-joins-and-other-aggregation-enhancements-coming-in-mongodb-3-2" title="Webinar: Joins and Other Aggregation Enhancements Coming in MongoDB 3.2">webinar recording</a> explaining more about <code>$lookup</code> and the other aggregation features.</p>
<p>To get the best understanding of the new features then you should experiment with the software which is available in the MongoDB 3.2 (not for production) download – to use the new <code>$lookup</code> aggregation theMongoDB Enterprise Advanced download should be used.</p>
<p>The reason MongoDB releases development releases is to give the community a chance to try out the new software – and we hope that you&#8217;ll give us feedback, whether it be by joining the <a href="https://www.mongodb.com/blog/post/announcing-the-mongodb-3-2-bug-hunt">MongoDB 3.2 bug hunt</a> or commenting on this post.</p>
</article>
<p></body></html></p>
]]></content:encoded>
					
					<wfw:commentRss>./../../mongodb/joins-and-other-aggregation-enhancements-in-mongodb-3-2/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>70x Faster Joins with AQL now GA with MySQL Cluster 7.2</title>
		<link>./../../mysql-cluster/70x-faster-joins-with-aql-in-mysql-cluster-7-2/index.html</link>
					<comments>./../../mysql-cluster/70x-faster-joins-with-aql-in-mysql-cluster-7-2/index.html#comments</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Wed, 15 Feb 2012 13:00:41 +0000</pubDate>
				<category><![CDATA[MySQL Cluster]]></category>
		<category><![CDATA[AQL]]></category>
		<category><![CDATA[join]]></category>
		<category><![CDATA[MySQL]]></category>
		<category><![CDATA[MySQL Cluster 7.2]]></category>
		<guid isPermaLink="false">./../../index.html?p=2027</guid>

					<description><![CDATA[The new GA MySQL Cluster 7.2 Release (7.2.4) just announced by Oracle includes 2 new features which when combined can improve the performance of joins by a factor of 70x (or even higher). The first enhancement is that MySQL Cluster now provides the MySQL Server with better information on the available indexes which allows the]]></description>
										<content:encoded><![CDATA[<div id="attachment_2030" style="width: 310px" class="wp-caption alignright"><a href="./../../wp-content/uploads/2011/09/AQL_70x_faster_join.jpg"><img fetchpriority="high" decoding="async" aria-describedby="caption-attachment-2030" class="size-medium wp-image-2030" title="AQL_70x_faster_join" src="./../../wp-content/uploads/2011/09/AQL_70x_faster_join-300x261.jpg" alt="" width="300" height="261" /></a><p id="caption-attachment-2030" class="wp-caption-text">70x faster joins with AQL</p></div>
<p>The new GA MySQL Cluster 7.2  Release (7.2.4) just announced by Oracle includes 2 new features which when combined can improve the performance of joins by a factor of 70x (or even higher). The first enhancement is that MySQL Cluster now provides the MySQL Server with better information  on the available indexes which allows the MySQL optimizer to automatically produce better query execution plans. Previously it was up to the user to manually provide hints to the optimizer. The second new feature is Adaptive Query Localization which allows the work of the join to be distributed across the data nodes (local to the data it&#8217;s working with) rather than up in the MySQL Server; this allows more computing power to be applied to calculating the join as well as dramatically reducing the number of messages being passed around the system. The combined result is that your joins can now run <strong>MUCH</strong> faster and this post describes a test that results in a 70x speed-up for a real-world query.</p>
<h2>The Query</h2>
<div id="attachment_2033" style="width: 310px" class="wp-caption alignright"><a href="./../../wp-content/uploads/2011/09/AQL_Query.jpg"><img decoding="async" aria-describedby="caption-attachment-2033" class="size-medium wp-image-2033" title="AQL_Query" src="./../../wp-content/uploads/2011/09/AQL_Query-300x171.jpg" alt="" width="300" height="171" /></a><p id="caption-attachment-2033" class="wp-caption-text">11-Way Join used in Test</p></div>
<p>The join used in this test is based on a real-world example used for an on-line store/Content Management System. The original query identified all of the media in the system which was appropriate to a particular device and for which a user is entitled to access. As this query is part of a customer&#8217;s application I&#8217;ve replaced all of the table and column names.</p>
<p>The join runs across 11 tables (which contain 33.5K rows in total) and produces a result set of 2,060 rows, each with 19 columns. The figure to the right illustrates the join and the full join is included below.</p>
<pre style="color: #000080;">SELECT
        tab1.uniquekey,
        tab8.name,
        tab8.tab8id,
        tab11.name,
        tab11.tab11id,
        tab11.value,
        tab10.tab10id,
        tab10.name,
        tab2.name,
        tab2.tab2id,
        tab4.value + tab5.value + tab6.value,
        tab3.colx,
        tab3.tab3id,
        tab4.tab4id,
        tab4.name,
        tab5.tab5id,
        tab5.name,
        tab6.tab6id,
        tab6.name
FROM
        tab1,tab2,tab3,tab4,tab5,tab6,tab7,tab8,tab9,tab10,tab11
WHERE
        tab7.tab2id = tab2.tab2id	AND
        tab7.tab8id = tab8.tab8id	AND
        tab9.tab2id = tab2.tab2id	AND
	tab9.tab10id = tab10.tab10id	AND
	tab10.tab11id = tab11.tab11id	AND
        tab3.tab2id = tab2.tab2id	AND
	tab3.tab4id = tab4.tab4id	AND
	tab4.tab5id = tab5.tab5id	AND
	tab4.colz =  'Y'		AND
	tab5.tab6id = tab6.tab6id	AND
	tab6.tab6id IN (6)		AND
	(tab3.tab4id IN (66, 77, 88))	AND
	tab1.tab2id = tab2.tab2id	AND
	tab1.colx = 6;</pre>
<h2>Enabling AQL</h2>
<p>First of all, make sure that you&#8217;re using the GA version of MySQL Cluster (7.2.4 or later); the Open Source version is available from   <a title="dev.mysql.com/downloads/cluster" href="dev.mysql.com/downloads/cluster" target="_blank">http://dev.mysql.com/downloads/cluster/#downloads</a></p>
<p>and the commercial version from the <a href="https://edelivery.oracle.com/" title="Download MySQL Cluster 7.2 from the Oracle Software Delivery Cloud" target="_new">Oracle Software Delivery Cloud</a>. You can double check that AQL is enabled:</p>
<pre style="color: #000080;">mysql> show variables like 'ndb_join_pushdown';

| ndb_join_pushdown                   | ON |</pre>
<h2>Running the Query &#038; Results</h2>
<div id="attachment_2031" style="width: 199px" class="wp-caption alignright"><a href="./../../wp-content/uploads/2011/09/AQL_lab.jpg"><img decoding="async" aria-describedby="caption-attachment-2031" class="size-medium wp-image-2031" title="AQL_lab" src="./../../wp-content/uploads/2011/09/AQL_lab-189x300.jpg" alt="" width="189" height="300" /></a><p id="caption-attachment-2031" class="wp-caption-text">Test configuration</p></div>
<p>To get the full benefit from AQL, you should run &#8220;ANALYZE TABLE;&#8221; once for each of the tables (no need to repeat for every query and it only needs running on one MySQL Server in the Cluster). This is very important and you should start doing this as a matter of course when you create or modify a table.</p>
<p>For this test, 3 machines were used:</p>
<ol>
<li>Intel Core 2 Quad Core @2.83 GHz; 8 Gbytes RAM; single, multi-threaded data node (ndbmtd)</li>
<li>Intel Core 2 Quad Core @2.83 GHz; 8 Gbytes RAM; single, multi-threaded data node (ndbmtd)</li>
<li>4 Core Fedora VM running on VirtualBox on Windows 7, single MySQL Server</li>
</ol>
<p>The query was then run and compared to MySQL CLuster 7.1.15a:</p>
<table Style="border-width: 1px;">
<tbody>
<tr>
<td>MySQL Cluster 7.1.15a</td>
<td>1 minute 27.23 secs</td>
<td></td>
</tr>
<tr>
<td>MySQL Cluster 7.2.1 (without having run ANALYZE TABLE)</td>
<td>1 minute 5.3 secs</td>
<td>1.33x Cluster 7.1</td>
</tr>
<tr>
<td>MySQL Cluster 7.2.1 (having run ANALYZE TABLE)</td>
<td>1.26 secs</td>
<td>69.23x Cluster 7.1</td>
</tr>
</tbody>
</table>
<h2>How it Works</h2>
<div id="attachment_1626" style="width: 310px" class="wp-caption alignright"><a href="./../../wp-content/uploads/2011/03/Nested-Loop-Join.jpg"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-1626" class="size-medium wp-image-1626" title="Nested Loop Join" src="./../../wp-content/uploads/2011/03/Nested-Loop-Join-300x155.jpg" alt="" width="300" height="155" /></a><p id="caption-attachment-1626" class="wp-caption-text">Classic Nested-Loop-Join</p></div>
<p>Traditionally, joins have been implemented in the MySQL Server where the query was executed. This is implemented as a nested-loop join; for every row from the first part of the join, a request has to be sent to the data nodes in order to fetch the data for the next level of the join and for every row in that level&#8230;. This method can result in a lot of network messages which slows down the query (as well as wasting resources). When turned on, Adaptive Query Localization results in the hard work being pushed down to the data nodes where the data is locally accessible. As a bonus, the work is divided amongst the pool of data nodes and so you get parallel execution.</p>
<div id="attachment_1627" style="width: 310px" class="wp-caption alignright"><a href="./../../wp-content/uploads/2011/03/NDB-API.jpg"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-1627" class="size-medium wp-image-1627" title="NDB API" src="./../../wp-content/uploads/2011/03/NDB-API-300x188.jpg" alt="" width="300" height="188" /></a><p id="caption-attachment-1627" class="wp-caption-text">NDB API</p></div>
<p>I&#8217;ll leave the real deep and dirty details to others but cover the basic concepts here. All API nodes access the data nodes using the native C++ NDB API, the MySQL Server is one example of an API node (the new <a href="./../../mysql-cluster/scalabale-persistent-ha-nosql-memcache-storage-using-mysql-cluster/index.html" target="_blank">Memcached Cluster API</a> is another). This API has been expanded to allow parameterised or linked queries where the input from one query is dependent on the previous one. To borrow an example from an excellent <a href="http://messagepassing.blogspot.com/2011/01/low-latency-distributed-parallel-joins.html" target="_blank">post by Frazer Clement</a> on the topic, the classic way to implement a join would be&#8230;</p>
<pre style="font-size: 11px;">SQL > select t1.b, t2.c from t1,t2 where t1.pk=22 and t1.b=t2.pk;
  ndbapi > read column b from t1 where pk = 22;</pre>
<pre style="font-size: 11px;">              [round trip]</pre>
<pre style="font-size: 11px;">           (b = 15)
  ndbapi > read column c from t2 where pk = 15;</pre>
<pre style="font-size: 11px;">              [round trip]</pre>
<pre style="font-size: 11px;">           (c = 30)
           [ return b = 15, c = 30 ]</pre>
<p>Using the new functionality this can be performed with a single network round trip where the second read operation is dependent on the results of the first&#8230;</p>
<pre style="font-size: 11px;">  ndbapi > read column <strong><span style="color: #800000;">@b</span></strong>:=b from t1 where pk = 22;
           read column c from t2 where pk=<span style="color: #800000;"><strong>@b</strong></span>;</pre>
<pre style="font-size: 11px;">              [round trip]</pre>
<pre style="font-size: 11px;">           (b = 15, c = 30)
           [ return b = 15, c = 30 ]</pre>
<p>You can check whether your query is fitting these rules using EXPLAIN, for example:</p>
<pre style="padding-left: 30px; font-size: 11px;"><span style="color: #008000;">mysql> set ndb_join_pushdown=on;</span></pre>
<pre style="padding-left: 30px;"><span style="color: #008000;">mysql> EXPLAIN SELECT COUNT(*) FROM residents,postcodes WHERE residents.postcode=postcodes.postcode AND postcodes.town="MAIDENHEAD";</span>
<span style="color: #008000;">+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+--------------------------------------------------------------------------+</span>
<span style="color: #008000;">| id | select_type | table     | type   | possible_keys | key     | key_len | ref                          | rows   | Extra                                                                    |
+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+--------------------------------------------------------------------------+ 
| 1  | SIMPLE      | residents | ALL    | NULL          | NULL    | NULL    | NULL                         | 100000 | Parent of 2 pushed join@1                                                |
| 1  | SIMPLE      | postcodes | eq_ref | PRIMARY       | PRIMARY | 22      | clusterdb.residents.postcode | 1      | Child of 'residents' in pushed join@1; Using where with pushed condition | 
+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+--------------------------------------------------------------------------+</span></pre>
<pre style="padding-left: 30px; font-size: 11px;"><span style="color: #008000;">mysql> EXPLAIN EXTENDED SELECT COUNT(*) FROM residents,postcodes,towns 
  WHERE residents.postcode=postcodes.postcode AND 
  postcodes.town=towns.town AND towns.county="Berkshire"; 
+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+----------+------------------------------------------------------------------------------------------------------------------------+ 
| id | select_type | table     | type   | possible_keys | key     | key_len | ref                          | rows   | filtered | Extra                                                                                                                  | 
+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+----------+------------------------------------------------------------------------------------------------------------------------+ 
| 1  | SIMPLE      | residents | ALL    | NULL          | NULL    | NULL    | NULL                         | 100000 | 100.00   | Parent of 3 pushed join@1                                                                                              | 
| 1  | SIMPLE      | postcodes | eq_ref | PRIMARY       | PRIMARY | 22      | clusterdb.residents.postcode | 1      | 100.00   | Child of 'residents' in pushed join@1                                                                                  |
| 1  | SIMPLE      | towns     | eq_ref | PRIMARY       | PRIMARY | 22      | clusterdb.postcodes.town     | 1      | 100.00   | Child of 'postcodes' in pushed join@1; Using where with pushed condition: (`clusterdb`.`towns`.`county` = 'Berkshire') | 
+----+-------------+-----------+--------+---------------+---------+---------+------------------------------+--------+----------+------------------------------------------------------------------------------------------------------------------------+</span></pre>
<p>Note that if you want to check for more details why your join isn&#8217;t currently being pushed down to the data node then you can use &#8220;<span style="color: #008000;">EXPLAIN EXTENDED</span>&#8221; and then &#8220;<span style="color: #008000;">SHOW WARNINGS</span>&#8221; to get more hints. Hopefully that will allow you to tweak your queries to get the best improvements.</p>
<p>PLEASE let us know your experiences and give us examples of queries that worked well and (just as importantly) those that didn&#8217;t so that we can improve the feature &#8211; just leave a comment on this Blog with your table schemas, your query and your before/after timings.</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../mysql-cluster/70x-faster-joins-with-aql-in-mysql-cluster-7-2/feed/index.html</wfw:commentRss>
			<slash:comments>10</slash:comments>
		
		
			</item>
	</channel>
</rss>
