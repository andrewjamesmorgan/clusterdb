<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>document &#8211; Andrew Morgan on Databases</title>
	<atom:link href="./feed/index.html" rel="self" type="application/rss+xml" />
	<link>./../../index.html</link>
	<description>Database technologies - especially around scalability and High Availability</description>
	<lastBuildDate>Fri, 06 Nov 2015 16:04:06 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Document Validation &#8211; Adding Just the Right Amount of Control Over Your MongoDB Documents</title>
		<link>./../../mongodb/document-validation-adding-just-the-right-amount-of-control-over-your-mongodb-documents/index.html</link>
					<comments>./../../mongodb/document-validation-adding-just-the-right-amount-of-control-over-your-mongodb-documents/index.html#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Fri, 06 Nov 2015 15:32:59 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[document]]></category>
		<category><![CDATA[Document Validation]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[MongoDB 3.2]]></category>
		<guid isPermaLink="false">./../../index.html?p=4130</guid>

					<description><![CDATA[This post looks at Document Validation, a new feature in MongoDB 3.2. It introduces the feature together with its benefits and then goes on to step through a tutorial on how to introduce validation to an existing, live MongoDB deployment. This material was orginally published on the MongoDB blog. Disclaimer MongoDB&#8217;s future product plans are]]></description>
										<content:encoded><![CDATA[<p><body></p>
<article class="markdown-body">
<p>This post looks at Document Validation, a new feature in MongoDB 3.2. It introduces the feature together with its benefits and then goes on to step through a tutorial on how to introduce validation to an existing, live MongoDB deployment. This material was orginally published on the <a href="https://www.mongodb.com/blog/post/document-validation-part-1-adding-just-the-right-amount-of-control-over-your-documents" title="Document Validation - Adding Just the Right Amount of Control Over Your MongoDB Documents">MongoDB blog</a>.</p>
<h3>
<a id="user-content-disclaimer" class="anchor" href="#disclaimer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Disclaimer</h3>
<p>MongoDB&#8217;s future product plans are for informational purposes only. MongoDB&#8217;s plans may change and you should not rely on them for delivery of a specific feature at a specific time.</p>
<h3>
<a id="user-content-introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>
<p>One of MongoDB’s primary attractions for developers is that it gives them the ability to start application development without first needing to define a formal schema. Operations teams appreciate the fact that they don&#8217;t need to perform a time-consuming schema upgrade operation every time the developers need to store a different attribute (as an example, <a href="https://www.mongodb.com/customers/weather-channel" title="The Weather Channel is now able to launch new features in hours whereas it used to take weeks">The Weather Channel is now able to launch new features in hours whereas it used to take weeks</a>. For business leaders, the application gets launched much faster, and new features can be rolled out more frequently. MongoDB powers agility.</p>
<p>Many projects reach a point where it&#8217;s necessary to enforce rules on what&#8217;s being stored in the database – for example, that for any document in a particular collection, you can be assured that certain attributes are present. Reasons for this include:</p>
<ul>
<li>Different development teams working with the same data; each one needing to know what they can expect to find in a particular collection</li>
<li>Development teams working on different applications, spread over multiple sites means that a clear understanding of shared data is important</li>
<li>Development teams from different companies where misunderstandings about what data should be present can lead to issues</li>
</ul>
<p>As an example, an e-commerce website may centralize a product catalog feed from each of its vendors into a single collection. If one of the vendors alters the format of its product catalog, the global catalog search could fail.</p>
<p>This has resulted in developers building their own validation logic &#8211; either with the application code (possibly multiple times for different applications) or by adding middleware such as <a href="http://mongoosejs.com/" title="elegant mongodb object modeling for node.js">Mongoose</a>.</p>
<p>If the database doesn’t enforce rules about the data, development teams need to implement this logic in their applications. However, use of multiple development languages makes it hard to add a validation layer across multiple applications.</p>
<p>To address the challenges discussed above, while at the same time maintaining the benefits of a dynamic schema, MongoDB 3.2 introduces document validation.</p>
<h3>
<a id="user-content-validating-documents-in-mongodb-32" class="anchor" href="#validating-documents-in-mongodb-32" aria-hidden="true"><span class="octicon octicon-link"></span></a>Validating Documents in MongoDB 3.2</h3>
<p>Note that at the time of writing, MongoDB 3.2 is not yet released but this functionality can be tried out in <a href="https://docs.mongodb.org/master/release-notes/3.2/" title="MongoDB 3.2 Documentation">MongoDB 3.2</a> <strong>which is available for testing only, not production</strong>.</p>
<p>Document Validation provides significant flexibility to customize which parts of the documents are <strong>and are not</strong> validated for any collection. For any key it might be appropriate to check:</p>
<ul>
<li>That a key exists</li>
<li>If a key does exist, is it of the correct type</li>
<li>That the value is in a particular format (e.g., regular expressions can be used to check if the contents of the string matches a particular pattern)</li>
<li>That the value falls within a given range</li>
</ul>
<p>Further, it may be necessary to combine these checks – for example that the document contains the user&#8217;s name and either their email address or phone number, and if the email address does exist, then it must be correctly formed.</p>
<p>Adding the validation checks to a collection is very intuitive to any developer or DBA familiar with MongoDB as it uses the same expression syntax as a <code>find</code> query to search the database. As an example, the following snippet adds validations to the <code>contacts</code> collection that validates:</p>
<ul>
<li>The year of birth is no later than 1994</li>
<li>The document contains a phone number and/or an email address </li>
<li>When present, the phone number and email addresses are strings</li>
</ul>
<div class="highlight highlight-source-js">
<pre>db.runCommand({
   collMod<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>contacts<span class="pl-pds">"</span></span>,
   validator<span class="pl-k">:</span> { 
      $and<span class="pl-k">:</span> [
        {year_of_birth<span class="pl-k">:</span> {$lte<span class="pl-k">:</span> <span class="pl-c1">1994</span>}},
        {$or<span class="pl-k">:</span> [ 
                  {phone<span class="pl-k">:</span> { $type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>}}, 
                  {email<span class="pl-k">:</span> { $type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>}}
              ]}]
    }})</pre>
</div>
<h3>
<a id="user-content-when-and-how-to-add-document-validation" class="anchor" href="#when-and-how-to-add-document-validation" aria-hidden="true"><span class="octicon octicon-link"></span></a>When and How to Add Document Validation</h3>
<p>Proponents of the waterfall development processes would assert that all of the validations should be added right at the start of the project – certainly before going into production. This is possible, but in more agile approaches, the first version may deploy with no validations and future releases will add new data and checks. Fortunately, MongoDB 3.2 provides a great deal of flexibility in this area. </p>
<p>For existing data, we want to allow the application to continue to operate as we introduce validation into our collections. Therefore, we want to allow updates and simply log failed validations so we can take corrective measures separately if necessary, or take no action.</p>
<p>For new data, we want to ensure the data is valid and therefore return an error if the validation fails.</p>
<p>For any collection, developers or the DBA can choose to specify validation rules for each collection as well as indicating whether failed validations result in a hard error or just a warning – Table 1 shows the available permutations.</p>
<p><a href="https://camo.githubusercontent.com/7a2ba719204606a07e202de4d1bee8972f5e7726/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f746162782e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/7a2ba719204606a07e202de4d1bee8972f5e7726/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f746162782e706e67" alt="Configuration options for controlling how document validations are applied to a collection" data-canonical-src="http://clusterdb.com/upload/tabx.png" style="max-width:100%;"></a></p>
<p><em>Table 1: Configuration Options for Document Validation</em></p>
<p>Figure 1 illustrates one possible timeline for how the application is developed.</p>
<p><a href="https://camo.githubusercontent.com/48cc829a4d7298a7bf6310c9bce926b2661630b3/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f496e74726f647563696e675f646f63756d656e745f76616c69646174696f6e732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/48cc829a4d7298a7bf6310c9bce926b2661630b3/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f496e74726f647563696e675f646f63756d656e745f76616c69646174696f6e732e706e67" alt="Lifecycle for introducing document validation" data-canonical-src="http://clusterdb.com/upload/Introducing_document_validations.png" style="max-width:100%;"></a></p>
<p><em>Figure 1: Aligning document validation with application lifecycle</em></p>
<p>Of course, as applications evolve they require additional pieces of data and it will often make sense to add to the documentat validation rules to check that this data is always included. Figure 2 illustrates an example timeline of how this could be managed.</p>
<p><a href="https://camo.githubusercontent.com/58012ff5b68410c0b954c6d3db0a28bbb2bb8308/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f457874656e64696e675f646f63756d656e745f76616c69646174696f6e732e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/58012ff5b68410c0b954c6d3db0a28bbb2bb8308/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f457874656e64696e675f646f63756d656e745f76616c69646174696f6e732e706e67" alt="Introducing New Data Together with Validations" title="Introducing New Data Together with Validations" data-canonical-src="http://clusterdb.com/upload/Extending_document_validations.png" style="max-width:100%;"></a></p>
<p><em>Figure 2: Introducing New Data Together with Validations</em></p>
<h3>
<a id="user-content-coping-with-multiple-schema-versions" class="anchor" href="#coping-with-multiple-schema-versions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coping with Multiple Schema Versions</h3>
<p>A tricky problem to solve with RDBMSs is the versioning of data models; with MongoDB it&#8217;s very straight-forward to set up validations that can cope with different versions of documents, with each version having a different set of checks applied. In the example validation checks below, the following logic is applied:</p>
<ul>
<li>If the document is unversioned (possibly dating to the time before validations were added), then no checks are applied</li>
<li>For version 1, the document is checked to make sure that the <code>name</code> key exists</li>
<li>For version 2 documents, the type of the <code>name</code> key is also validated to ensure that it is a string</li>
</ul>
<div class="highlight highlight-source-js">
<pre>db.runCommand({
   collMod<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>contacts<span class="pl-pds">"</span></span>,
   validator<span class="pl-k">:</span>
     {$or<span class="pl-k">:</span> [{version<span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">"</span>$exists<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">false</span>}},
            {version<span class="pl-k">:</span> <span class="pl-c1">1</span>,
             $and<span class="pl-k">:</span> [{Name<span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">"</span>$exists<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">true</span>}}]
            },
            {version<span class="pl-k">:</span> <span class="pl-c1">2</span>,
             $and<span class="pl-k">:</span> [{Name<span class="pl-k">:</span> {<span class="pl-s"><span class="pl-pds">"</span>$exists<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">"</span>$type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">2</span>}}]
            }
          ]
      } 
})</pre>
</div>
<p>In this way, multiple versions of documents can exist within the same collection, and the application can lazily up-version them over time. Note that the <code>version</code> attribute is user-defined.</p>
<h3>
<a id="user-content-document-validation-limitations-in-mongodb-32" class="anchor" href="#document-validation-limitations-in-mongodb-32" aria-hidden="true"><span class="octicon octicon-link"></span></a>Document Validation Limitations in MongoDB 3.2</h3>
<p>This is the first release of Document Validation and so it&#8217;s inevitable that there are still some things that would be great to add:</p>
<ul>
<li>The current error message is very generic and doesn&#8217;t pick out which part of your document failed validation (note that the validation rule for a collection may check several things across many attributes). <a href="https://jira.mongodb.org/browse/SERVER-20547">Jira ticket</a>
</li>
<li>The validation checks cannot compare one key&#8217;s value against another (whether in the same or different documents). For example <code>{salary: {$gte: startingSalary}}</code> is not possible. <a href="https://jira.mongodb.org/browse/SERVER-2702">Jira ticket</a>
</li>
<li>It is the application or DBA&#8217;s responsibility to bring legacy data into compliance with new rules (there are no audits or tools) &#8211; the tutorial in this post attempts to show how this can be done.</li>
</ul>
<h3>
<a id="user-content-where-mongodb-document-validation-excels-vs-rdbmss" class="anchor" href="#where-mongodb-document-validation-excels-vs-rdbmss" aria-hidden="true"><span class="octicon octicon-link"></span></a>Where MongoDB Document Validation Excels (vs. RDBMSs)</h3>
<p>In MongoDB, Document Validation is simple to set up. There is no need for stored procedures – which for many types of validation would be required in an RDBMS – and because the familiar MongoDB query language is used, there is no new syntax to learn.</p>
<p>The functionality is very flexible and it can enforce constraints on as little or as much of the schema as required. You get the best of both worlds – a dynamic schema for rapidly changing, polymorphic data, with the option to enforce strict validation checks against specific attributes from the onset of your project, or much later on. If you initially have no validations defined, they can still be added later – even once in production, across thousand of servers.</p>
<p>It is always a concern whether adding extra checks will impact the performance of the system; in our tests, document validation adds a negligible overhead.</p>
<h3>
<a id="user-content-so-is-all-data-validation-now-done-in-the-database" class="anchor" href="#so-is-all-data-validation-now-done-in-the-database" aria-hidden="true"><span class="octicon octicon-link"></span></a>So, is all Data Validation Now Done in the Database?</h3>
<p>The answer is &#8216;probably not&#8217; – either because there&#8217;s a limit to what can be done in the database or because there will always be a more appropriate place for some checks. Here are some areas to consider:</p>
<ul>
<li>For a good user-experience, checks should be made as high up the stack as is sensible. For example, the format of an entered email address should be first checked in the browser rather than waiting for the request to be processed and an attempt made to write it to the database.</li>
<li>Any validations which need to compare values between keys, other documents, or external information cannot currently be implemented within the database.</li>
<li>Many checks are best made within the application&#8217;s business logic – for example &#8220;is this user allowed to use these services in their home country&#8221;; the checks in the database are primarily there to protect against coding errors.</li>
<li>If you need information on <strong>why</strong> the document failed validation then the application will need to check against each of the sub-rules within collection&#8217;s validation rule as the error message will not currently give this level of detail.</li>
</ul>
<h3>
<a id="user-content-tutorial" class="anchor" href="#tutorial" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tutorial</h3>
<p>The intent of this section is to step you through exactly how document validation can be introduced into an existing production deployment in such a way that there is no impact to your users. It covers:</p>
<ul>
<li>Setting up some test data (not needed for a real deployment)</li>
<li>Using MongoDB Compass and the <code>mongo</code> shell to reverse engineer the de facto data model and identify anomalies in the existing documents</li>
<li>Defining the appropriate document validation rules</li>
<li>Preventing new documents being added which don’t follow the new rules</li>
<li>Bring existing documents “up to spec” against the new rules</li>
</ul>
<p>This section looks at taking an existing, deployed database which currently has no document validations defined. It steps through understanding what the current document structure looks like; deciding on what rules to add and then rolling out those new rules.</p>
<p>As a pre-step add some data to the database (obviously, this isn&#8217;t needed if working with your real deployment).</p>
<div class="highlight highlight-source-js">
<pre>use clusterdb;
db.dropDatabase();
use clusterdb();
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>sku<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, 
    <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>product 1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>instock<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">120</span> });
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>sku<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>def<span class="pl-pds">"</span></span>, 
    <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>product 2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>instock<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">80</span> });
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">"</span>sku<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>ijk<span class="pl-pds">"</span></span>, 
    <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>product 3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>instock<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">60</span> });
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">4</span>, <span class="pl-s"><span class="pl-pds">"</span>sku<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jkl<span class="pl-pds">"</span></span>, 
    <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>product 4<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>instock<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">70</span> });
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">5</span>, <span class="pl-s"><span class="pl-pds">"</span>sku<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">null</span>, 
    <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Incomplete<span class="pl-pds">"</span></span> });
db.inventory.insert({ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">6</span> });

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">1000</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">2000</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    item<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>, 
    price<span class="pl-k">:</span> i <span class="pl-k">%</span> <span class="pl-c1">50</span>,
    quantity<span class="pl-k">:</span> i <span class="pl-k">%</span> <span class="pl-c1">5</span>
  });
};

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">2000</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">3000</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    item<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jkl<span class="pl-pds">"</span></span>, 
    price<span class="pl-k">:</span> i <span class="pl-k">%</span> <span class="pl-c1">30</span>,
    quantity<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>()) <span class="pl-k">+</span> <span class="pl-c1">1</span>
  });
};

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">3000</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">3200</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    price<span class="pl-k">:</span> i <span class="pl-k">%</span> <span class="pl-c1">30</span>,
    quantity<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>()) <span class="pl-k">+</span> <span class="pl-c1">1</span>
  });
};

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">3200</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">3500</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    item<span class="pl-k">:</span> <span class="pl-c1">null</span>,
    price<span class="pl-k">:</span> i <span class="pl-k">%</span> <span class="pl-c1">30</span>,
    quantity<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>()) <span class="pl-k">+</span> <span class="pl-c1">1</span>
  });
};

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">3500</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">4000</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    item<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>,
    price<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>free<span class="pl-pds">"</span></span>,
    quantity<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>()) <span class="pl-k">+</span> <span class="pl-c1">1</span>
  });
};

<span class="pl-k">for</span> (i<span class="pl-k">=</span><span class="pl-c1">4000</span>; i<span class="pl-k">&lt;</span><span class="pl-c1">4250</span>; i<span class="pl-k">++</span>) {
  db.orders.insert({
    _id<span class="pl-k">:</span> i,
    item<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>,
    price<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>if you have to ask....<span class="pl-pds">"</span></span>,
    quantity<span class="pl-k">:</span> <span class="pl-c1">Math</span>.<span class="pl-c1">floor</span>(<span class="pl-c1">10</span> <span class="pl-k">*</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>()) <span class="pl-k">+</span> <span class="pl-c1">1</span>
  });
};</pre>
</div>
<p>The easiest way to start understanding the de facto schema for your database is to use MongoDB Compass. Simply connect Compass to your <code>mongod</code> (or <code>mongos</code> if you&#8217;re using sharding) and select the database/collection you&#8217;d like to look into. To see MongoDB Compass in action – view this <a href="https://www.google.com/url?q=https://youtu.be/3w9HVFh1hRs">demo video</a>.</p>
<p>As shown in Figure 3, there are <strong>typically</strong> four keys in each document from the <code>clusterdb.orders</code> table:</p>
<ul>
<li>
<code>_id</code> is  always present and is a number</li>
<li>
<code>item</code> is normally present and is a string (either &#8220;abc&#8221; or &#8220;jkl&#8221;) but is occasionally <code>null</code> or missing altogether (undefined)</li>
<li>
<code>price</code> is always present and is in most cases a number (the histogram shows how the values are distributed between 0 and 49) but in some cases it&#8217;s a string</li>
<li>
<code>quantity</code> is always present and is a number</li>
</ul>
<p><a href="https://camo.githubusercontent.com/c6be166af57c3e05bd9178641b3b44e2b09303d1/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373312e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/c6be166af57c3e05bd9178641b3b44e2b09303d1/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373312e706e67" alt="Viewing the Document Schema using MongoDB Compass" title="Viewing the Document Schema using MongoDB Compass" data-canonical-src="http://clusterdb.com/upload/Compass1.png" style="max-width:100%;"></a></p>
<p><em>Figure 3: Viewing the Document Schema using MongoDB Compass</em></p>
<p>For this tutorial, we&#8217;ll focus on the <code>price</code>. By clicking on the <code>string</code> label, Compass will show us more information about the string content for <code>price</code> &#8211; this is shown in Figure 4.</p>
<p><a href="https://camo.githubusercontent.com/e9c905f6f8c7b0a2e50ae9cd8116072c0d1b9daf/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373322e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/e9c905f6f8c7b0a2e50ae9cd8116072c0d1b9daf/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373322e706e67" alt="Drilling Down into string Values" title="Drilling Down into string Values" data-canonical-src="http://clusterdb.com/upload/Compass2.png" style="max-width:100%;"></a></p>
<p><em>Figure 4: Drilling Down into string Values</em></p>
<p>Compass shows us that:</p>
<ul>
<li>For those instances of <code>price</code> which are strings, the common values are &#8220;free&#8221; and &#8220;if you have to ask&#8230;.&#8221;. </li>
<li>If you click on one of those values, a query expression is formed and clicking &#8220;Apply&#8221; runs that query and now Compass will show you information only for that subset of documents. For example, where <code>price == "if you have to ask...."</code> (see Figure 5). </li>
<li>By selecting multiple attributes, you can build up fairly complex queries.</li>
<li>The query you build visually is printed at the top so you can easily copy/paste into other contexts like the shell.</li>
</ul>
<p><a href="https://camo.githubusercontent.com/65ae683d19bb485b640b21590bbca8de71bcb208/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373332e706e67" target="_blank"><img decoding="async" src="https://camo.githubusercontent.com/65ae683d19bb485b640b21590bbca8de71bcb208/687474703a2f2f636c757374657264622e636f6d2f75706c6f61642f436f6d70617373332e706e67" alt="Formulating Search Expressions with MongoDB Compass" title="Formulating Search Expressions with MongoDB Compass" data-canonical-src="http://clusterdb.com/upload/Compass3.png" style="max-width:100%;"></a></p>
<p><em>Figure 5: Formulating Search Expressions with MongoDB Compass</em></p>
<p>If applications are to work with the <code>price</code> from these documents then it would be simpler it it was always set to a numerical value, and so this is something that should be fixed.</p>
<p>Before cleaning up the existing documents, the application should be updated to ensure numerical values are stored in the price field. We can do this by adding a new validation rule to the collection. We want this rule to:</p>
<ul>
<li>Allow changes to existing invalid documents</li>
<li>Prevent inserts of new documents which violate validation rules</li>
<li>Set up a <strong>very</strong> simple document validation rule that checks that <code>price</code> exists and contains a <code>double</code> – see the <a href="http://docs.mongodb.org/master/reference/bson-types/" title="MongoDB BSON types">enumeration of MongoDB BSON types</a> </li>
</ul>
<p>These steps should be run from the <code>mongo</code> shell:</p>
<div class="highlight highlight-source-js">
<pre>db.orders.runCommand(<span class="pl-s"><span class="pl-pds">"</span>collMod<span class="pl-pds">"</span></span>, 
                   {validationLevel<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>moderate<span class="pl-pds">"</span></span>, 
                    validationAction<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>});

db.runCommand({collMod<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>orders<span class="pl-pds">"</span></span>, 
               validator<span class="pl-k">:</span> {
                  price<span class="pl-k">:</span> {$exists<span class="pl-k">:</span> <span class="pl-c1">true</span>},
                  price<span class="pl-k">:</span> {$type<span class="pl-k">:</span> <span class="pl-c1">1</span>}
                }
              });</pre>
</div>
<p>The validation rules for this collection can now be checked:</p>
<div class="highlight highlight-source-js">
<pre>db.getCollectionInfos({name<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>orders<span class="pl-pds">"</span></span>})
[
  {
    <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>orders<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>options<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>validator<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
        <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
          <span class="pl-s"><span class="pl-pds">"</span>$type<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1</span>
        }
      },
      <span class="pl-s"><span class="pl-pds">"</span>validationLevel<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>moderate<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>validationAction<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>
    }
  }
]</pre>
</div>
<p>Now that this has been set up, it&#8217;s possible to check that we can&#8217;t add a new document that breaks the rule:</p>
<div class="highlight highlight-source-js">
<pre>db.orders.insert({
    <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">6666</span>, 
    <span class="pl-s"><span class="pl-pds">"</span>item<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>jkl<span class="pl-pds">"</span></span>, 
    <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>rogue<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>quantity<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1</span> });

Document failed validation
WriteResult({
  <span class="pl-s"><span class="pl-pds">"</span>nInserted<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>writeError<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>code<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">121</span>,
    <span class="pl-s"><span class="pl-pds">"</span>errmsg<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Document failed validation<span class="pl-pds">"</span></span>
  }
})</pre>
</div>
<p>But it&#8217;s OK to modify an existing document that does break the rule:</p>
<div class="highlight highlight-source-js">
<pre>db.orders.findOne({price<span class="pl-k">:</span> {$type<span class="pl-k">:</span> <span class="pl-c1">2</span>}});

{
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">3500</span>,
  <span class="pl-s"><span class="pl-pds">"</span>item<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>abc<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>free<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>quantity<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">5</span>
}

<span class="pl-k">&gt;</span> db.orders.update(
    {_id<span class="pl-k">:</span> <span class="pl-c1">3500</span>},
    {$set<span class="pl-k">:</span> {quantity<span class="pl-k">:</span> <span class="pl-c1">12</span>}});

Updated <span class="pl-c1">1</span> existing record(s) <span class="pl-k">in</span> 5ms
WriteResult({
  <span class="pl-s"><span class="pl-pds">"</span>nMatched<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1</span>,
  <span class="pl-s"><span class="pl-pds">"</span>nUpserted<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>nModified<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">1</span>
})</pre>
</div>
<p>Now that the application is no longer able to store new documents that break the new rule, it&#8217;s time to clean up the &#8220;legacy&#8221; documents. At this point, it&#8217;s important to point out that Compass works on a random sample of the documents in a collection (this is what allows it to be so quick). To make sure that we&#8217;re fixing <strong>all</strong> of the documents, we check from the <code>mongo</code> shell. As the following commands could consume significant resources, it may make sense to run them on a secondary):</p>
<div class="highlight highlight-source-js">
<pre>secondary<span class="pl-k">&gt;</span> db.orders.aggregate([
    {$match<span class="pl-k">:</span> {
      price<span class="pl-k">:</span> {$type<span class="pl-k">:</span> <span class="pl-c1">2</span>}}},
    {$group<span class="pl-k">:</span> {
      _id<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>$price<span class="pl-pds">"</span></span>, 
      count<span class="pl-k">:</span> {$sum<span class="pl-k">:</span><span class="pl-c1">1</span>}}}
  ])

{ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>if you have to ask....<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>count<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">250</span> }
{ <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>free<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>count<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-c1">500</span> }</pre>
</div>
<p>The number of exceptions isn&#8217;t too high and so it is safe to go ahead and fix up the data without consuming too many resources:</p>
<div class="highlight highlight-source-js">
<pre>db.orders.update(
    {price<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>free<span class="pl-pds">"</span></span>},
    {$set<span class="pl-k">:</span> {price<span class="pl-k">:</span> <span class="pl-c1">0</span>}},
    {multi<span class="pl-k">:</span> <span class="pl-c1">true</span>});

db.orders.update(
    {price<span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>if you have to ask....<span class="pl-pds">"</span></span>},
    {$set<span class="pl-k">:</span> {price<span class="pl-k">:</span> <span class="pl-c1">1000000</span>}},
    {multi<span class="pl-k">:</span> <span class="pl-c1">true</span>});</pre>
</div>
<p>At this point it&#8217;s now safe to enter the strict mode where any inserts or updates will cause an error if the document being stored doesn&#8217;t follow the rules:</p>
<div class="highlight highlight-source-js">
<pre>db.orders.runCommand(<span class="pl-s"><span class="pl-pds">"</span>collMod<span class="pl-pds">"</span></span>, 
                   {validationLevel<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>strict<span class="pl-pds">"</span></span>, 
                    validationAction<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span>});</pre>
</div>
<h3>
<a id="user-content-next-steps" class="anchor" href="#next-steps" aria-hidden="true"><span class="octicon octicon-link"></span></a>Next Steps</h3>
<p>Hopefully this has given you a sense for what the Document Validation functionality offers and started you thinking about how it could be applied to your application and database. I&#8217;d encourage you to read up more on the topic and these are some great resources:</p>
<ul>
<li><a href="https://www.mongodb.com/presentations/webinar-document-validation-in-mongodb-3-2" title="Webinar: Document Validation in MongoDB 3.2">Webinar: Document Validation in MongoDB 3.2</a></li>
<li><a href="https://docs.mongodb.org/master/release-notes/3.2/#document-validation" title="MongoDB 3.2 documentation for Document Validation">MongoDB 3.2 documentation for Document Validation</a></li>
<li>The best way to really get a feel for the functionality is to try it out for yourself:<a href="https://www.mongodb.org/downloads#development" title="Download MongoDB 3.2">Download MongoDB 3.2</a>
</li>
<li>Feedback is welcomed and we’d encourage you to join the <a href="https://www.mongodb.com/blog/post/announcing-the-mongodb-3-2-bug-hunt">MongoDB 3.2 bug hunt</a>
</li>
<li>
<a href="http://www.eliothorowitz.com/blog/2015/09/11/document-validation-and-what-dynamic-schema-means/" title="Document Validation and What Dynamic Schema Means">Document Validation and What Dynamic Schema Means</a> – Eliot Horowitz. This blog post adds context to why this functionality is being introduced now.</li>
<li>
<a href="https://www.mongodb.com/presentations/data-management-3-bulletproof-data-management" title="Bulletproof Data Management">Bulletproof Data Management</a> – Buzz Moschetti. Great presentation on how to look after your data &#8211; including in earlier versions of MongoDB.</li>
</ul>
</article>
<p></body></html></p>
]]></content:encoded>
					
					<wfw:commentRss>./../../mongodb/document-validation-adding-just-the-right-amount-of-control-over-your-mongodb-documents/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>MongoDB Document Validation &#8211; London MUG charts</title>
		<link>./../../mongodb/mongodb-document-validation-london-mug-charts/index.html</link>
					<comments>./../../mongodb/mongodb-document-validation-london-mug-charts/index.html#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Wed, 16 Sep 2015 15:37:48 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[3.2]]></category>
		<category><![CDATA[Database]]></category>
		<category><![CDATA[document]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[MongoDB 3.2]]></category>
		<guid isPermaLink="false">./../../index.html?p=4109</guid>

					<description><![CDATA[Last night I preented on the MongoDB 3.2 Documentation Validation feature at the London MongoDB User Group meetup; the charts are shared here. Unfortunately, I didn&#8217;t record the demo and so you&#8217;ll have to grab me at a future MUG if you&#8217;d like to see that! Abstract One of MongoDB’s primary appeals to developers is]]></description>
										<content:encoded><![CDATA[<p>Last night I preented on the MongoDB 3.2 Documentation Validation feature at the <a href="http://www.meetup.com/London-MongoDB-User-Group/events/224606434/" target="_blank">London MongoDB User Group meetup</a>; the charts are shared here. Unfortunately, I didn&#8217;t record the demo and so you&#8217;ll have to grab me at a future MUG if you&#8217;d like to see that!</p>
<p><strong>Abstract</strong></p>
<p>One of MongoDB’s primary appeals to developers is that it gives them the ability to start application development without needing to define a formal, up-front schema. Operations teams appreciate the fact that they don&#8217;t need to perform a time-consuming schema upgrade operation every time the developers need to store a different attribute (as an example, The Weather Channel is now able to launch new features in hours whereas it used to take weeks). For business leaders, the application gets launched much faster, and new features can be rolled out more frequently. MongoDB powers agility. </p>
<p>Some projects reach a point where it&#8217;s necessary to define rules on what&#8217;s being stored in the database – for example, that for any document in a particular collection, you can be assured that certain attributes are present. </p>
<p>To address the challenges discussed above, while at the same time maintaining the benefits of a dynamic schema, MongoDB 3.2 introduces document validation.</p>
<p>There is significant flexibility to customize which parts of the documents are <strong>and are not</strong> validated for any collection.</p>
<p><iframe src="//www.slideshare.net/slideshow/embed_code/key/pRViHhcmzlQYTt" width="600" height="400" frameborder="0" marginwidth="0" marginheight="0" scrolling="no" style="border:1px solid #CCC; border-width:1px; margin-bottom:5px; max-width: 100%;" allowfullscreen> </iframe> </p>
<div style="margin-bottom:5px"> <strong> <a href="//www.slideshare.net/andrewjamesmorgan/document-validation-in-mongodb-32" title="Document validation in MongoDB 3.2" target="_blank">Document validation in MongoDB 3.2</a> </strong> from <strong><a href="//www.slideshare.net/andrewjamesmorgan" target="_blank">Andrew Morgan</a></strong> </div>
<p>Please feel free to ask any questions through comments on this post.</p>
]]></content:encoded>
					
					<wfw:commentRss>./../../mongodb/mongodb-document-validation-london-mug-charts/feed/index.html</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
