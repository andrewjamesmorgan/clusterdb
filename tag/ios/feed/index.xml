<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>ios &#8211; Andrew Morgan on Databases</title>
	<atom:link href="/tag/ios/feed" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Database technologies - especially around scalability and High Availability</description>
	<lastBuildDate>Mon, 14 Mar 2022 16:30:15 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Building a collaborative iOS Minesweeper game with Realm</title>
		<link>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm</link>
					<comments>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 14 Mar 2022 16:30:15 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[game]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4668</guid>

					<description><![CDATA[I wanted to build an app that we could use at events to demonstrate Realm Sync. It needed to be fun to interact with, and so a multiplayer game made sense. Tic-tac-toe is too simple to get excited about. I&#8217;m not a game developer and so Call Of Duty wasn&#8217;t an option. Then I remembered]]></description>
										<content:encoded><![CDATA[<p><a href="/wp-content/uploads/2022/03/ATF-720x720-1.png"><img fetchpriority="high" decoding="async" src="/wp-content/uploads/2022/03/ATF-720x720-1-300x300.png" alt="Realm-Sweeper. Writing a multiplayer iOS Minesweeper game using SwiftUI and Realm" width="300" height="300" class="alignright size-medium wp-image-4669" srcset="/wp-content/uploads/2022/03/ATF-720x720-1-300x300.png 300w, /wp-content/uploads/2022/03/ATF-720x720-1-150x150.png 150w, /wp-content/uploads/2022/03/ATF-720x720-1-144x144.png 144w, /wp-content/uploads/2022/03/ATF-720x720-1.png 720w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>I wanted to build an app that we could use at events to demonstrate <a href="https://www.mongodb.com/realm/mobile/sync">Realm Sync</a>. It needed to be fun to interact with, and so a multiplayer game made sense. Tic-tac-toe is too simple to get excited about. I&#8217;m not a game developer and so <em>Call Of Duty</em> wasn&#8217;t an option. Then I remembered Microsoft&#8217;s <a href="https://en.wikipedia.org/wiki/Minesweeper">Minesweeper</a>.</p>
<p>Minesweeper was a Windows fixture from 1990 until Windows 8 relegated it to the app store in 2012. It was a single-player game, but it struck me as something that could be a lot of fun to play with others. Some family beta-testing of my first version while waiting for a ferry proved that it did get people to interact with each other (even if most interactions involved shouting, &#8220;Which of you muppets clicked on that mine?!&#8221;).</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/IMG_1301_81fa444116.jpeg" alt="Family sat around a table, all playing the Realm-Sweeper game on their iPhones" /></p>
<p>You can download the back end and iOS apps from the <a href="https://github.com/realm/Realm-Sweeper">Realm-Sweeper repo</a>, and get it up and running in a few minutes if you want to play with it.</p>
<p>This article steps you through some of the key aspects of setting up the backend Realm app, as well as the iOS code. Hopefully, you&#8217;ll see how simple it is and try building something for yourself. If anyone&#8217;s looking for ideas, then <a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban</a> could be interesting.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://github.com/realm/realm-swift/releases/tag/v10.23.0">Realm-Cocoa 10.20.1+</a></li>
<li>iOS 15+</li>
</ul>
<h2>The Minesweeper game</h2>
<p>The gameplay for Minesweeper is very simple.</p>
<p>You&#8217;re presented with a grid of gray tiles. You tap on a tile to expose what&#8217;s beneath. If you expose a mine, game over. If there isn&#8217;t a mine, then you&#8217;ll be rewarded with a hint as to how many mines are adjacent to that tile. If you deduce (or guess) that a tile is covering a mine, then you can plant a flag to record that.</p>
<p>You win the game when you correctly flag every mine and expose what&#8217;s behind every non-mined tile.</p>
<h3>What Realm-Sweeper adds</h3>
<p>Minesweeper wasn&#8217;t designed for touchscreen devices; you had to use a physical mouse. Realm-Sweeper brings the game into the 21st century by adding touch controls. Tap a tile to reveal what&#8217;s beneath; tap and hold to plant a flag.</p>
<p>Minesweeper was a single-player game. All people who sign into Realm-Sweeper with the same user ID get to collaborate on the same game in real time.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_sweeper_24ef46cef1.gif" alt="Animation of two iPhones. As a user taps a tile on one device, the change appears almost instantly on the other" /></p>
<p>You also get to configure the size of the grid and how many mines you&#8217;d like to hide.</p>
<h2>The data model</h2>
<p>I decided to go for a simple data model that would put Realm sync to the test.</p>
<p>Each game is a single document/object that contains meta data (score, number of rows/columns, etc.) together with the grid of tiles (the board):</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/schema_f791f6acf6.png" alt="Data model for the Game Class" /></p>
<p>This means that even a modestly sized grid (20&#215;20 tiles) results in a <code>Game</code> document/object with more than 2,000 attributes.</p>
<p>Every time you tap on a tile, the <code>Game</code> object has to be synced with all other players. Those players are also tapping on tiles, and those changes have to be synced too. If you tap on a tile which isn&#8217;t adjacent to any mines, then the app will recursively ripple through exposing similar, connected tiles. That&#8217;s a lot of near-simultaneous changes being made to the same object from different devices‚Äîa great test of Realm&#8217;s automatic conflict resolution!</p>
<h2>The backend Realm app</h2>
<p>If you don&#8217;t want to set this up yourself, simply follow the <a href="https://github.com/realm/Realm-Sweeper/tree/main/Realm">instructions from the repo</a> to import the app.</p>
<p>If you opt to build the backend app yourself, there are only two things to configure once you create the empty Realm app:</p>
<ol>
<li><a href="https://docs.mongodb.com/realm/authentication/email-password/#:~:text=Summary-,Overview,email%20addresses%20are%20case%2Dsensitive.">Enable email/password authentication</a>. I kept it simple by opting to auto-confirm new users and sticking with the default password-reset function (which does nothing).</li>
<li><a href="https://docs.mongodb.com/realm/sync/configure/enable-sync/">Enable partitioned Realm sync</a>. Set the partition key to <code>partition</code> and enable developer mode (so that the schema will be created automatically when the iOS app syncs for the first time).</li>
</ol>
<p>The <code>partition</code> field will be set to the username‚Äîallowing anyone who connects as that user to sync all of their games.</p>
<p>You can also add sync rules to ensure that a user can only sync their own games (in case someone hacks the mobile app). I always prefer using Realm functions for permissions. You can add this for both the read and write rules:</p>
<pre><code class="json">{
  "%%true": {
    "%function": {
      "arguments": [
        "%%partition"
      ],
      "name": "canAccessPartition"
    }
  }
}
</code></pre>
<p>The <code>canAccessPartition</code> function is:</p>
<pre><code class="js">exports = function(partition) {
  const user = context.user.data.email;
  return partition === user;
};
</code></pre>
<h2>The iOS app</h2>
<p>I&#8217;d suggest starting by downloading, configuring, and running the app‚Äîjust follow the <a href="https://github.com/realm/Realm-Sweeper/tree/main/iOS">instructions from the repo</a>. That way, you can get a feel for how it works.</p>
<p>This isn&#8217;t intended to be a full tutorial covering every line of code in the app. Instead, I&#8217;ll point out some key components.</p>
<p>As always with Realm and MongoDB, it all starts with the data‚Ä¶</p>
<h3>Model</h3>
<p>There&#8217;s a single top-level Realm Object‚Äî<code>Game</code>:</p>
<pre><code class="swift">class Game: Object, ObjectKeyIdentifiable {
    @Persisted(primaryKey: true) var _id: ObjectId
    @Persisted var numRows = 0
    @Persisted var numCols = 0
    @Persisted var score = 0
    @Persisted var startTime: Date? = Date()
    @Persisted var latestMoveTime: Date?
    @Persisted var secondsTakenToComplete: Int?
    @Persisted var board: Board?
    @Persisted var gameStatus = GameStatus.notStarted
    @Persisted var winningTimeInSeconds: Int?
    ‚Ä¶
}
</code></pre>
<p>Most of the fields are pretty obvious. The most interesting is <code>board</code>, which contains the grid of tiles:</p>
<pre><code class="swift">class Board: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var rows = List&lt;Row&gt;()
    @Persisted var startingNumberOfMines = 0
    ... 
}
</code></pre>
<p><code>row</code> is a list of <code>Cells</code>:</p>
<pre><code class="swift">class Row: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var cells = List&lt;Cell&gt;()
    ...
}

class Cell: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var isMine = false
    @Persisted var numMineNeigbours = 0
    @Persisted var isExposed = false
    @Persisted var isFlagged = false
    @Persisted var hasExploded = false
    ...
}
</code></pre>
<p>The model is also where the ~~business~~ game logic is implemented. This means that the views can focus on the UI. For example, <code>Game</code> includes a computed variable to check whether the game has been solved:</p>
<pre><code class="swift">var hasWon: Bool {
    guard let board = board else { return false }
    if board.remainingMines != 0 { return false }

    var result = true

    board.rows.forEach() { row in
        row.cells.forEach() { cell in
            if !cell.isExposed &amp;&amp; !cell.isFlagged {
                result = false
                return
            }
        }
        if !result { return }
    }
    return result
}
</code></pre>
<h3>Views</h3>
<p>As with any SwiftUI app, the UI is built up of a hierarchy of many views.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/views_aaac46f078.png" alt="Screen capture from Xcode showing the hierarchy of views making up the RealmSweeper UI" /></p>
<p>Here&#8217;s a quick summary of the <a href="https://github.com/realm/Realm-Sweeper/tree/main/iOS/RealmSweeper/Views">views</a> that make up Real-Sweeper:</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/ContentView.swift"><code>ContentView</code></a></strong> is the top-level view. When the app first runs, it will show the <code>LoginView</code>. Once the user has logged in, it shows <code>GameListView</code> instead. It&#8217;s here that we set the Realm Sync partition (to be the <code>username</code> of the user that&#8217;s just logged in):</p>
<pre><code class="swift">if username == "" {
    LoginView(username: $username)
} else {
    GameListView()
        .environment(\.realmConfiguration, realmApp.currentUser!.configuration(partitionValue: username))
        .navigationBarItems(leading: realmApp.currentUser != nil ? LogoutButton(username: $username) : nil)
}
</code></pre>
<p><code>ContentView</code> also includes the <code>LogoutButton</code> view.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Users/LoginView.swift"><code>LoginView</code></a></strong> allows the user to provide a username and password:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Login_View_034d3f058f.png" alt="Screen capture of the login view. Fields to enter username and password. Checkbox to indicate that you're registering a new user. Button to login," /></p>
<p>Those credentials are then used to register or log into the backend Realm app:</p>
<pre><code class="swift">func userAction() {
    Task {
        do {
            if newUser {
                try await realmApp.emailPasswordAuth.registerUser(
                    email: email, password: password)
            }
            let _ = try await realmApp.login(
                    credentials: .emailPassword(email: email, password: password))
            username = email
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
</code></pre>
<p><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game%20List/GameListView.swift"><strong><code>GameListView</code></strong></a> reads the list of this user&#8217;s existing games.</p>
<pre><code class="swift">@ObservedResults(Game.self, 
    sortDescriptor: SortDescriptor(keyPath: "startTime", ascending: false)) var games
</code></pre>
<p>It displays each of the games within a <code>GameSummaryView</code>. If you tap one of the games, then you jump to a <code>GameView</code> for that game:</p>
<pre><code class="swift">NavigationLink(destination: GameView(game: game)) {
    GameSummaryView(game: game)
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_List_View_22711c2b4a.png" alt="GameListView, Screen capture of a list of games, together with buttons to logout, set settings, or create a new game" /></p>
<p>Tap the settings button and you&#8217;re sent to <code>SettingsView</code>.</p>
<p>Tap the &#8220;New Game&#8221; button and a new <code>Game</code> object is created and then stored in Realm by appending it to the <code>games</code> live query:</p>
<pre><code class="swift">private func createGame() {
    numMines = min(numMines, numRows * numColumns)
    game = Game(rows: numRows, cols: numColumns, mines: numMines)
    if let game = game {
        $games.append(game)
    }
    startGame  = true
}
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/SettingsView.swift"><code>SettingsView</code></a></strong> lets the user choose the number of tiles and mines to use:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Settings_View_39aa24c7ce.png" alt="SettingsView. Steppers to set the number of rows, columns, and mines" /></p>
<p>If the user uses multiple devices to play the game (e.g., an iPhone and an iPad), then they may want different-sized boards (taking advantage of the extra screen space on the iPad). Because of that, the view uses the device&#8217;s <code>UserDefaults</code> to locally persist the settings rather than storing them in a synced realm:</p>
<pre><code class="swift">@AppStorage("numRows") var numRows = 10
@AppStorage("numColumns") var numColumns = 10
@AppStorage("numMines") var numMines = 15
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game%20List/GameSummaryView.swift"><code>GameSummaryView</code></a></strong> displays a summary of one of the user&#8217;s current or past games.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_Summary_View_e80a138236.png" alt="GameSummaryView. Screen capture of view containing the start and completion times + emoji for the status of the game" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game/GameView.swift"><code>GameView</code></a></strong> shows the latest stats for the current game at the top of the screen:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_Status_5ee8b8b6e0.png" alt="GameStatusView. Screen capture showing remaining mines, status of the game (smiling emoji) and elapsed time" /></p>
<p>It uses the <code>LEDCounter</code> and <code>StatusButton</code> views for the summary.</p>
<p>Below the summary, it displays the <code>BoardView</code> for the game.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Control%20Box/Counters/LEDCounter.swift"><code>LEDCounter</code></a></strong> displays the provided number as three digits using a retro LED font:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Counter_View_d7b73c42ce.png" alt="CounterView ‚Äì 3 red LED numbers" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Control%20Box/StatusButton.swift"><code>StatusButton</code></a></strong> uses a <code>ZStack</code> to display the symbol for the game&#8217;s status on top of a tile image:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Status_Button_8975894d39.png" alt="StatusButton. Smiling emoji in front of a gray tile" /></p>
<p>The view uses SwiftUI&#8217;s <a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-provide-relative-sizes-using-geometryreader"><code>GeometryReader</code></a> function to discover how much space is available so that it can select an appropriate font size for the symbol:</p>
<pre><code class="swift">GeometryReader { geo in
    Text(status)
        .font(.system(size: geo.size.height * 0.7))
}
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game/BoardView.swift"><code>BoardView</code></a></strong> displays the game&#8217;s grid of tiles:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Board_View_703d6386db.png" alt="BoardView. A grid of tiles. Some tiles have been removed, revealing colored numbers. One tile contains a red flag" /></p>
<p>Each of the tiles is represented by a <code>CellView</code> view.</p>
<p>When a tile is tapped, this view exposes its contents:</p>
<pre><code class="swift">.onTapGesture() {
    expose(row: row, col: col)
}
</code></pre>
<p>On a tap-and-hold, a flag is dropped:</p>
<pre><code class="swift">.onLongPressGesture(minimumDuration: 0.1) {
    flag(row: row, col: col)
}
</code></pre>
<p>When my family tested the first version of the app, they were frustrated that they couldn&#8217;t tell whether they&#8217;d held long enough for the flag to be dropped. This was an easy mistake to make as their finger was hiding the tile at the time‚Äîan example of where testing with a mouse and simulator wasn&#8217;t a substitute for using real devices. It was especially frustrating as getting it wrong meant that you revealed a mine and immediately lost the game. Fortunately, this is easy to fix using iOS&#8217;s haptic feedback:</p>
<pre><code class="swift">func hapticFeedback(_ isSuccess: Bool) {
    let generator = UINotificationFeedbackGenerator()
    generator.notificationOccurred(isSuccess ? .success : .error)
}
</code></pre>
<p>You now feel a buzz when the flag has been dropped.</p>
<p><strong><a href="CellView"><code>CellView</code></a></strong> displays an individual tile:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Cell_View_6ee46c6103.png" alt="CellView. Tile containing a crossed out red flag" /></p>
<p>What&#8217;s displayed depends on the contents of the <code>Cell</code> and the state of the game. It uses four further views to display different types of tile: <code>FlagView</code>, <code>MineCountView</code>, <code>MineView</code>, and <code>TileView</code>.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/FlagView.swift"><code>FlagView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Flag_View_fd57e245f3.png" alt="FlagView. 2 Tiles, both containing a flag, one shows the  flag crossed out" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/MineCountView.swift"><code>MineCountView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Mine_Count_View_e8392ff46d.png" alt="MineCountView, 6 gray tiles. One is empty the others containing numbers 1 through 5, each in a different color" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/MineView.swift"><code>MineView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Mine_View_18eaaf517b.png" alt="MineView. Two tiles containing mines, one with a gray background, one with a red background" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/TileView.swift"><code>TileView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Tile_View_1a01815c26.png" alt="TileView. A single gray tile" /></p>
<h2>Conclusion</h2>
<p>Realm-Sweeper gives a real feel for how quickly Realm is able to synchronize data over the internet.</p>
<p>I intentionally avoided optimizing how I updated the game data in Realm. When you see a single click exposing dozens of tiles, each cell change is an update to the <code>Game</code> object that needs to be synced.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/sync_526ade2926.gif" alt="GIF showing changes in one game board appearing in near-realtime in the game board on a different device" /></p>
<p>Note that both instances of the game are running in iPhone simulators on an overworked Macbook in England. The Realm backend app is running in the US‚Äîthat&#8217;s a 12,000 km/7,500 mile round trip for each sync.</p>
<p>I took this approach as I wanted to demonstrate the performance of Realm synchronization. If an app like this became super-popular with millions of users, then it would put a lot of extra strain on the backend Realm app.</p>
<p>An obvious optimization would be to condense all of the tile changes from a single tap into a single write to the Realm object. If you&#8217;re interested in trying that out, just fork the <a href="https://github.com/realm/Realm-Sweeper">repo</a> and make the changes. If you do implement the optimization, then please create a pull request. (I&#8217;d probably add it as an option within the settings so that the &#8220;slow&#8221; mode is still an option.)</p>
<p>Got questions? Ask them in our <a href="https://www.mongodb.com/community/forums/c/realm/realm-sync/111">Community forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Introducing Flexible Sync (Preview) ‚Äì The Next Iteration of Realm Sync</title>
		<link>/mongodb/introducing-flexible-sync-preview-the-next-iteration-of-realm-sync</link>
					<comments>/mongodb/introducing-flexible-sync-preview-the-next-iteration-of-realm-sync#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Wed, 26 Jan 2022 10:30:57 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[.net]]></category>
		<category><![CDATA[android]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[javascript]]></category>
		<category><![CDATA[kotlin]]></category>
		<category><![CDATA[Swift]]></category>
		<guid isPermaLink="false">/?p=4651</guid>

					<description><![CDATA[We are excited to announce the public preview of our next version of Realm Sync: Flexible Sync. This new method of syncing puts the power into the hands of the developer. Now, developers can get more granular control over the data synced to user applications with intuitive language-native queries and hierarchical permissions. Introduction Prior to]]></description>
										<content:encoded><![CDATA[<p>We are excited to announce the public preview of our next version of Realm Sync: Flexible Sync. This new method of syncing puts the power into the hands of the developer. Now, developers can get more granular control over the data synced to user applications with intuitive language-native queries and hierarchical permissions.</p>
<p><iframe width=600 height=400 src="https://www.youtube.com/embed/bGaMhy7ns3I" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2>Introduction</h2>
<p>Prior to launching the general availability of Realm Sync in February 2021, the Realm team spent countless hours with developers learning how they build best-in-class mobile applications. A common theme emerged‚Äîbuilding real-time, offline-first mobile apps require an overwhelming amount of complex, non-differentiating work.</p>
<p>Our <a href="https://www.mongodb.com/developer/how-to/realm-partitioning-strategies/">first version of Realm Sync</a> addressed this pain by abstracting away offline-first, real-time syncing functionality using declarative APIs. It expedited the time-to-market for many developers and worked well for apps where data is static and compartmentalized, or where permissions rarely need to change. But for dynamic apps and complex use cases, developers still had to spend time creating workarounds instead of developing new features. With that in mind, we built the next iteration of Realm Sync: Flexible Sync. Flexible Sync is designed to help developers:</p>
<ul>
<li>Get to market faster: Use intuitive, language-native queries to define the data synced to user applications instead of proprietary concepts.</li>
<li>Optimize real-time collaboration between users: Utilize object-level conflict-resolution logic.</li>
<li>Simplify permissions: Apply role-based logic to applications with an expressive permissions system that groups users into roles on a pe-class or collection basis.</li>
</ul>
<h2>Language-Native Querying</h2>
<p>Flexible Sync‚Äôs query-based sync logic is distinctly different from how Realm Sync operates today. The new structure is designed to more closely mirror how developers are used to building sync today‚Äîtypically using GET requests with query parameters.</p>
<p>One of the primary benefits of Flexible Sync is that it eliminates all the time developers spend determining what query parameters to pass to an endpoint. Instead, the Realm APIs directly integrate with the native querying system on the developer‚Äôs choice of platform‚Äîfor example, a predicate-based query language for iOS, a Fluent query for Android, a string-based query for Javascript, and a LINQ query for .NET.</p>
<p>Under the hood, the Realm Sync thread sends the query to MongoDB Realm (Realm‚Äôs cloud offering). MongoDB Realm translates the query to MongoDB‚Äôs query language and executes the query against MongoDB Atlas. Atlas then returns the resulting documents. Those documents are then translated into Realm objects, sent down to the Realm client, and stored on disk. The Realm Sync thread keeps a queue of any changes made locally to synced objects‚Äîeven when offline. As soon as connectivity is reestablished, any changes made to the server-side or client-side are synced down using built-in granular conflict resolution logic. All of this occurs behind the scenes while the developer is interacting with the data. This is the part we‚Äôve heard our users describe as ‚Äúmagic.‚Äù</p>
<p>Flexible Sync also enables much more dynamic queries, based on user inputs. Picture a home listing app that allows users to search available properties in a certain area. As users define inputs‚Äîonly show houses in Dallas, TX that cost less than $300k and have at least three bedrooms‚Äîthe query parameters can be combined with logical ANDs and ORs to produce increasingly complex queries, and narrow down the search result even further. All query results are combined into a single realm file on the client‚Äôs device, which significantly simplifies code required on the client-side and ensures changes to data are synced efficiently and in real time.</p>
<h3>Swift</h3>
<pre><code class="swift">// Set your Schema
class Listing: Object {
    @Persisted(primaryKey: true) var _id: ObjectId
    @Persisted var location: String
    @Persisted var price: Int
    @Persisted var bedrooms: Int
}

// Configure your App and login
let app = App(id: "XXXX")
let user = try! await app.login(credentials:
            .emailPassword(email: "email", password: "password"))

// Set the new Flexible Sync Config and open the Realm
let config = user.flexibleSyncConfiguration()
let realm = try! await Realm(configuration: config, downloadBeforeOpen: .always)

// Create a Query and Add it to your Subscriptions
let subscriptions = realm.subscriptions

try! await subscriptions.write {
    subscriptions.append(QuerySubscription&lt;Listing&gt;(name: "home-search") {
        $0.location == "dallas" &amp;&amp; $0.price &lt; 300000 &amp;&amp; $0.bedrooms &gt;= 3
    })
}

// Now query the local realm and get your home listings - output is 100 listings
// in the results
print(realm.objects(Listing.self).count)

// Remove the subscription - the data is removed from the local device but stays
// on the server
try! await subscriptions.write {
    subscriptions.remove(named: "home-search")
}

// Output is 0 - listings have been removed locally
print(realm.objects(Listing.self).count)
</code></pre>
<h3>Kotlin</h3>
<pre><code class="kotlin">// Set your Schema
open class Listing: ObjectRealm() {
  @PrimaryKey
  @RealmField("_id")
  var id: ObjectId
  var location: String = ""
  var price: Int = 0
  var bedrooms: Int = 0
}

// Configure your App and login
val app = App("&lt;YOUR_APP_ID_HERE&gt;")
val user = app.login(Credentials.emailPassword("email", "password"))

// Set the new Flexible Sync Config and open the Realm
let config = SyncConfiguration.defaultConfig(user)
let realm = Realm.getInstance(config)

// Create a Query and Add it to your Subscriptions
val subscriptions = realm.subscriptions
subscriptions.update { mutableSubscriptions -&gt;
   val sub = Subscription.create(
      "home-search", 
      realm.where&lt;Listing&gt;()
         .equalTo("location", "dallas")
         .lessThan("price", 300_000)
         .greaterThanOrEqual("bedrooms", 3)
   )
   mutableSubscriptions.add(subscription)
}

// Wait for server to accept the new subscription and download data
subscriptions.waitForSynchronization()
realm.refresh()

// Now query the local realm and get your home listings - output is 100 listings 
// in the results
val homes = realm.where&lt;Listing&gt;().count()

// Remove the subscription - the data is removed from the local device but stays 
// on the server
subscriptions.update { mutableSubscriptions -&gt;
   mutableSubscriptions.remove("home-search")
}
subscriptions.waitForSynchronization()
realm.refresh()

// Output is 0 - listings have been removed locally
val homes = realm.where&lt;Listing&gt;().count()
</code></pre>
<h3>.NET</h3>
<pre><code class="csharp">// Set your Schema
class Listing: RealmObject
{
    [PrimaryKey, MapTo("_id")]
    public ObjectId Id { get; set; }
    public string Location { get; set; }
    public int Price { get; set; }
    public int Bedrooms { get; set; }
}

// Configure your App and login
var app = App.Create(YOUR_APP_ID_HERE);
var user = await app.LogInAsync(Credentials.EmailPassword("email", "password"));

// Set the new Flexible Sync Config and open the Realm
var config = new FlexibleSyncConfiguration(user);
var realm = await Realm.GetInstanceAsync(config);

// Create a Query and Add it to your Subscriptions
var dallasQuery = realm.All&lt;Listing&gt;().Where(l =&gt; l.Location == "dallas" &amp;&amp; l.Price &lt; 300_000 &amp;&amp; l.Bedrooms &gt;= 3);
realm.Subscriptions.Update(() =&gt;
{
    realm.Subscriptions.Add(dallasQuery);
});

await realm.Subscriptions.WaitForSynchronizationAsync();

// Now query the local realm and get your home listings - output is 100 listings
// in the results
var numberOfListings = realm.All&lt;Listing&gt;().Count();

// Remove the subscription - the data is removed from the local device but stays
// on the server

realm.Subscriptions.Update(() =&gt;
{
    realm.Subscriptions.Remove(dallasQuery);
});

await realm.Subscriptions.WaitForSynchronizationAsync();

// Output is 0 - listings have been removed locally
numberOfListings = realm.All&lt;Listing&gt;().Count();
</code></pre>
<h3>JavaScript</h3>
<pre><code class="js">import Realm from "realm";

// Set your Schema
const ListingSchema = {
  name: "Listing",
  primaryKey: "_id",
  properties: {
    _id: "objectId",
    location: "string",
    price: "int",
    bedrooms: "int",
  },
};

// Configure your App and login
const app = new Realm.App({ id: YOUR_APP_ID_HERE });
const credentials = Realm.Credentials.emailPassword("email", "password");
const user = await app.logIn(credentials);

// Set the new Flexible Sync Config and open the Realm
const realm = await Realm.open({
  schema: [ListingSchema],
  sync: { user, flexible: true },
});

// Create a Query and Add it to your Subscriptions
await realm.subscriptions.update((mutableSubscriptions) =&gt; {
  mutableSubscriptions.add(
    realm
      .objects(ListingSchema.name)
      .filtered("location = 'dallas' &amp;&amp; price &lt; 300000 &amp;&amp; bedrooms = 3", {
        name: "home-search",
      })
  );
});

// Now query the local realm and get your home listings - output is 100 listings
// in the results
let homes = realm.objects(ListingSchema.name).length;

// Remove the subscription - the data is removed from the local device but stays
// on the server
await realm.subscriptions.update((mutableSubscriptions) =&gt; {
  mutableSubscriptions.removeByName("home-search");
});

// Output is 0 - listings have been removed locally
homes = realm.objects(ListingSchema.name).length;
</code></pre>
<h2>Optimizing for Real-Time Collaboration</h2>
<p>Flexible Sync also enhances query performance and optimizes for real-time user collaboration by treating a single object or document as the smallest entity for synchronization. Flexible Sync allows for Sync Realms to more efficiently share data and for conflict resolution to incorporate changes faster and with less data transfer.</p>
<p>For example, you and a fellow employee are analyzing the remaining tasks for a week. Your coworker wants to see all of the time-intensive tasks remaining (<code>workunits &amp;gt; 5</code>), and you want to see all the tasks you have left for the week (<code>owner == ianward</code>). Your queries will overlap where <code>workunits &amp;gt; 5</code> and <code>owner == ianward</code>. If your coworker notices one of your tasks is marked incorrectly as <code>7 workunits</code> and changes the value to <code>6</code>, you will see the change reflected on your device in real time. Under the hood, the merge algorithm will only sync the changed document instead of the entire set of query results increasing query performance.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Interesecting_Tasks_380cf4962d.png" alt="Venn diagram showing that 2 different queries can share some of the same documents" /></p>
<h2>Permissions</h2>
<p>Whether it‚Äôs a company‚Äôs internal application or an app on the App Store, permissions are required in almost every application. That‚Äôs why we are excited by how seamless Flexible Sync makes applying a document-level permission model when syncing data‚Äîmeaning synced documents can be limited based on a user‚Äôs role.</p>
<p>Consider how a sales organization uses a CRM application. An individual sales representative should only be able to access her own sales pipeline while her manager needs to be able to see the entire region‚Äôs sales pipeline. In Flexible Sync, a user‚Äôs role will be combined with the client-side query to determine the appropriate result set. For example, when the sales representative above wants to view her deals, she would send a query where <code>opportunities.owner == "EmmaLullo"</code> but when her manager wants to see all the opportunities for their entire team, they would query with opportunities.team == &#8220;West‚Äù. If a user sends a much more expansive query, such as querying for all opportunities, then the permissions system would only allow data to be synced for which the user had explicit access.</p>
<pre><code class="json">{
  "Opportunities": {
    "roles": [
        {
                name: "manager", 
                applyWhen: { "%%user.custom_data.isSalesManager": true},
                read: {"team": "%%user.custom_data.teamManager"}
                write: {"team": "%%user.custom_data.teamManager"}
            },
        {
                name: "salesperson",
                applyWhen: {},
                read: {"owner": "%%user.id"}
                write: {"owner": "%%user.id"}
        }
    ]
  },
{
  "Bookings": {
    "roles": [
        {
                name: "accounting", 
                applyWhen: { "%%user.custom_data.isAccounting": true},
                read: true,
                write: true
            },
        {
                name: "sales",
                applyWhen: {},
                read: {"%%user.custom_data.isSales": true},
                write: false
        }
    ]
  }
</code></pre>
<h2>Looking Ahead</h2>
<p>Ultimately, our goal with Flexible Sync is to deliver a sync service that can fit any use case or schema design pattern imaginable without custom code or workarounds. And while we are excited that Flexible Sync is now in preview, we‚Äôre nowhere near done.</p>
<p>The Realm Sync team is planning to bring you more query operators and permissions integrations over the course of 2022. Up next we are looking to expose array operators and enable querying on embedded documents, but really, we look to you, our users, to help us drive the roadmap. Submit your ideas and feature requests to our <a href="https://feedback.mongodb.com/forums/923521-realm">feedback portal</a> and ask questions in our <a href="https://www.mongodb.com/community/forums/c/realm/realm-sync/111">Community forum</a>. Happy building!</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/introducing-flexible-sync-preview-the-next-iteration-of-realm-sync/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Goodbye NSPredicate, hello Realm Swift Query API</title>
		<link>/mongodb/goodbye-nspredicate-hello-realm-swift-query-api</link>
					<comments>/mongodb/goodbye-nspredicate-hello-realm-swift-query-api#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Fri, 17 Dec 2021 17:21:40 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mobile]]></category>
		<category><![CDATA[Swift]]></category>
		<guid isPermaLink="false">/?p=4647</guid>

					<description><![CDATA[Introduction I&#8217;m not a fan of writing code using pseudo-English text strings. It&#8217;s a major context switch when you&#8217;ve been writing &#8220;native&#8221; code. Compilers don&#8217;t detect errors in the strings, whether syntax errors or mismatched types, leaving you to learn of your mistakes when your app crashes. I spent more than seven years working at]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>I&#8217;m not a fan of writing code using pseudo-English text strings. It&#8217;s a major context switch when you&#8217;ve been writing &#8220;native&#8221; code. Compilers don&#8217;t detect errors in the strings, whether syntax errors or mismatched types, leaving you to learn of your mistakes when your app crashes.</p>
<p>I spent more than seven years working at MySQL and Oracle, and still wasn&#8217;t comfortable writing anything but the simplest of SQL queries. I left to join MongoDB because I knew that the object/document model was the way that developers should work with their data. I also knew that idiomatic queries for each programming language were the way to go.</p>
<p>That&#8217;s why I was really excited when MongoDB acquired Realm‚Äîa leading mobile <strong>object</strong> database. You work with Realm objects in your native language (in this case, Swift) to manipulate your data.</p>
<p>However, there was one area that felt odd in Realm&#8217;s Swift SDK. You had to use <code>NSPredicate</code> when searching for Realm objects that match your criteria. <code>NSPredicate</code>s are strings with variable substitution. <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f926-200d-2642-fe0f.png" alt="ü§¶‚Äç‚ôÇÔ∏è" class="wp-smiley" style="height: 1em; max-height: 1em;" /></p>
<p><code>NSPredicate</code>s are used when searching for data in Apple&#8217;s Core Data database, and so it was a reasonable design decision. It meant that iOS developers could reuse the skills they&#8217;d developed while working with Core Data.</p>
<p>But, I hate writing code as strings.</p>
<p>The good news is that the Realm SDK for Swift has added the option to use type-safe queries through the Realm Swift Query API. <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f973.png" alt="ü•≥" class="wp-smiley" style="height: 1em; max-height: 1em;" />.</p>
<p>You now have the option whether to filter using <code>NSPredicate</code>s:</p>
<pre><code class="swift">let predicate = NSPredicate(format: "isSoft == %@", NSNumber(value: wantSoft)
let decisions = unfilteredDecisions.filter(predicate)
</code></pre>
<p>or with the new Realm Swift Query API:</p>
<pre><code class="swift">let decisions = unfilteredDecisions.where { $0.isSoft == wantSoft }
</code></pre>
<p>In this article, I&#8217;m going to show you some examples of how to use the Realm Swift Query API. I&#8217;ll also show you an example where wrangling with <code>NSPredicate</code> strings has frustrated me.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://github.com/realm/realm-cocoa/releases/tag/v10.19.0">Realm-Cocoa 10.19.0</a>+</li>
</ul>
<h2>Using The Realm Swift Query API</h2>
<p>I have a number of existing Realm iOS apps using <code>NSPredicate</code>s. When I learnt of the new query API, the first thing I wanted to do was try to replace some of &#8220;legacy&#8221; queries. I&#8217;ll start by describing that experience, and then show what other type-safe queries are possible.</p>
<h3>Replacing an NSPredicate</h3>
<p>I&#8217;ll start with the example I gave in the introduction (and how the <code>NSPredicate</code> version had previously frustrated me).</p>
<p>I have an <a href="https://github.com/mongodb-developer/BlackJackTrainer">app to train you on what decisions to make in Black Jack</a> (based on the cards you&#8217;ve been dealt and the card that the dealer is showing). There are three different decision matrices based on the cards you&#8217;ve been dealt:</p>
<ul>
<li>Whether you have the option to split your hand (you&#8217;ve been dealt two cards with the same value)</li>
<li>Your hand is &#8220;soft&#8221; (you&#8217;ve been dealt an ace, which can take the value of either one or eleven)</li>
<li>Any other hand</li>
</ul>
<p>All of the decision-data for the app is held in <a href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Model/Decisions.swift"><code>Decisions</code></a> objects:</p>
<pre><code class="swift">class Decisions: Object, ObjectKeyIdentifiable {
   @Persisted var decisions = List&lt;DecisionList&gt;()
   @Persisted var isSoft = false
   @Persisted var isSplit = false
   ...
}
</code></pre>
<p><a href="https://github.com/mongodb-developer/BlackJackTrainer/blob/main/Black%20Jack%20Trainer/Black%20Jack%20Trainer/Views/Decision%20Matrix/SoftDecisionView.swift"><code>SoftDecisionView</code></a> needs to find the <code>Decisions</code> object where <code>isSoft</code> is set to <code>true</code>. That requires a simple <code>NSPredicate</code>:</p>
<pre><code class="swift">struct SoftDecisionView: View {
   @ObservedResults(Decisions.self, filter: NSPredicate(format: "isSoft == YES")) var decisions
   ...
}
</code></pre>
<p>But, what if I&#8217;d mistyped the attribute name? There&#8217;s no Xcode auto-complete to help when writing code within a string, and this code builds with no errors or warnings:</p>
<pre><code class="swift">struct SoftDecisionView: View {
   @ObservedResults(Decisions.self, filter: NSPredicate(format: "issoft == YES")) var decisions
   ...
}
</code></pre>
<p>When I run the code, it works initially. But, when I&#8217;m dealt a soft hand, I get this runtime crash:</p>
<pre><code>Terminating app due to uncaught exception 'Invalid property name', reason: 'Property 'issoft' not found in object of type 'Decisions''
</code></pre>
<p>Rather than having a dedicated view for each of the three types of hand, I want to experiment with having a single view to handle all three.</p>
<p>SwiftUI doesn&#8217;t allow me to use variables (or even named constants) as part of the filter criteria for <code>@ObservedResults</code>. This is because the <code>struct</code> hasn&#8217;t been initialized until after the <code>@ObservedResults</code> is defined. To live within SwitfUIs constraints, the filtering is moved into the view&#8217;s body:</p>
<pre><code class="swift">struct SoftDecisionView: View {
   @ObservedResults(Decisions.self) var unfilteredDecisions
   let isSoft = true

   var body: some View {
       let predicate = NSPredicate(format: "isSoft == %@", isSoft)
       let decisions = unfilteredDecisions.filter(predicate)
   ...
}
</code></pre>
<p>Again, this builds, but the app crashes as soon as I&#8217;m dealt a soft hand. This time, the error is much more cryptic:</p>
<pre><code>Thread 1: EXC_BAD_ACCESS (code=1, address=0x1)
</code></pre>
<p>It turns out that, you need to convert the boolean value to an <code>NSNumber</code> before substituting it into the <code>NSPredicate</code> string:</p>
<pre><code class="swift">struct SoftDecisionView: View {
   @ObservedResults(Decisions.self) var unfilteredDecisions


   let isSoft = true


   var body: some View {
       let predicate = NSPredicate(format: "isSoft == %@", NSNumber(value: isSoft))
       let decisions = unfilteredDecisions.filter(predicate)
   ...
}
</code></pre>
<p>Who knew? OK, StackOverflow did, but it took me quite a while to find the solution.</p>
<p>Hopefully, this gives you a feeling for why I don&#8217;t like writing strings in place of code.</p>
<p>This is the same code using the new (type-safe) Realm Swift Query API:</p>
<pre><code class="swift">struct SoftDecisionView: View {
   @ObservedResults(Decisions.self) var unfilteredDecisions
   let isSoft = true

   var body: some View {
       let decisions = unfilteredDecisions.where { $0.isSoft == isSoft }
   ...
}
</code></pre>
<p>The code&#8217;s simpler, and (even better) Xcode won&#8217;t let me use the wrong field name or type‚Äîgiving me this error before I even try running the code:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/xcode_type_warning_5e1c3b18e6.png" alt="Xcode showing the error &quot;Binary operator '==' cannot be applied to operands of type 'Query<Boo>&#8216; and &#8216;Int'&#8221; title=&#8221;Xcode showing the error Binary operator &#8216;==&#8217; cannot be applied to operands of type &#8216;Query<Bool>&#8216; and &#8216;Int'&#8221; /></p>
<h3>Experimenting With Other Sample Queries</h3>
<p>In my <a href="https://github.com/realm/RCurrency">RCurrency app</a>, I was able to replace this <code>NSPredicate</code>-based code:</p>
<pre><code class="swift">struct CurrencyRowContainerView: View {
   @ObservedResults(Rate.self) var rates
   let baseSymbol: String
   let symbol: String

   var rate: Rate? {
       NSPredicate(format: "query.from = %@ AND query.to = %@", baseSymbol, symbol)).first
   }
   ...
}
</code></pre>
<p>With this:</p>
<pre><code class="swift">struct CurrencyRowContainerView: View {
   @ObservedResults(Rate.self) var rates
   let baseSymbol: String
   let symbol: String

   var rate: Rate? {
       rates.where { $0.query.from == baseSymbol &amp;&amp; $0.query.to == symbol }.first
   }
   ...
}
</code></pre>
<p>Again, I find this more Swift-like, and bugs will get caught as I type/build rather than when the app crashes.</p>
<p>I&#8217;ll use this simple <code>Task</code> <code>Object</code> to show a few more example queries:</p>
<pre><code class="swift">class Task: Object, ObjectKeyIdentifiable {
   @Persisted var name = ""
   @Persisted var isComplete = false
   @Persisted var assignee: String?
   @Persisted var priority = 0
   @Persisted var progressMinutes = 0
}
</code></pre>
<p>All in-progress tasks assigned to name:</p>
<pre><code class="swift">let myStartedTasks = realm.objects(Task.self).where {
   ($0.progressMinutes &gt; 0) &amp;&amp; ($0.assignee == name)
}
</code></pre>
<p>All tasks where the <code>priority</code> is higher than <code>minPriority</code>:</p>
<pre><code class="swift">let highPriorityTasks = realm.objects(Task.self).where {
   $0.priority &gt;= minPriority
}
</code></pre>
<p>All tasks that have a <code>priority</code> that&#8217;s an integer between <code>-1</code> and <code>minPriority</code>:</p>
<pre><code class="swift">let lowPriorityTasks = realm.objects(Task.self).where {
   $0.priority.contains(-1...minPriority)
}
</code></pre>
<p>All tasks where the <code>assignee</code> name string includes <code>namePart</code>:</p>
<pre><code class="swift">let tasksForName = realm.objects(Task.self).where {
   $0.assignee.contains(namePart)
}
</code></pre>
<h3>Filtering on Sub-Objects</h3>
<p>You may need to filter your Realm objects on values within their sub-objects. Those sub-object may be <code>EmbeddedObject</code>s or part of a <code>List</code>.</p>
<p>I&#8217;ll use the <code>Project</code> class to illustrate filtering on the attributes of sub-documents:</p>
<pre><code class="swift">class Project: Object, ObjectKeyIdentifiable {
   @Persisted var name = ""
   @Persisted var tasks: List&lt;Task&gt;
}
</code></pre>
<p>All projects that include a task that&#8217;s in-progress, and is assigned to a given user:</p>
<pre><code class="swift">let myActiveProjects = realm.objects(Project.self).where {
   ($0.tasks.progressMinutes &gt;= 1) &amp;&amp; ($0.tasks.assignee == name)
}
</code></pre>
<h3>Including the Query When Creating the Original Results (SwiftUI)</h3>
<p>At the time of writing, this feature wasn&#8217;t released, but it can be tested using <a href="https://github.com/realm/realm-cocoa/pull/7518">this PR</a>.</p>
<p>You can include the where modifier directly in your <code>@ObservedResults</code> call. That avoids the need to refine your results inside your view&#8217;s body:</p>
<pre><code class="swift">@ObservedResults(Decisions.self, where: { $0.isSoft == true }) var decisions
</code></pre>
<p>Unfortunately, SwiftUI rules still mean that you can&#8217;t use variables or named constants in your <code>where</code> block for <code>@ObservedResults</code>.</p>
<h2>Conclusion</h2>
<p>Realm type-safe queries provide a simple, idiomatic way to filter results in Swift. If you have a bug in your query, it should be caught by Xcode rather than at run-time.</p>
<p>You can find more information in the <a href="https://docs.mongodb.com/realm/sdk/ios/examples/filter-data/#std-label-ios-realm-swift-query-api">docs</a>. If you want to see hundreds of examples, and how they map to equivalent <code>NSPredicate</code> queries, then take a look at the <a href="https://github.com/realm/realm-cocoa/blob/v10.19.0/RealmSwift/Tests/QueryTests.swift">test cases</a>.</p>
<p>For those that prefer working with <code>NSPredicate</code>s, you can continue to do so. In fact, the Realm Swift Query API runs on top of the <code>NSPredicate</code> functionality, so they&#8217;re not going anywhere soon.</p>
<p>Please provide feedback and ask any questions in the <a href="https://www.mongodb.com/community/forums/c/realm-sdks/58">Realm Community Forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/goodbye-nspredicate-hello-realm-swift-query-api/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Most Useful iOS 15 SwiftUI Features</title>
		<link>/mongodb/realm/most-useful-ios-15-swiftui-features</link>
					<comments>/mongodb/realm/most-useful-ios-15-swiftui-features#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Thu, 30 Sep 2021 12:10:36 +0000</pubDate>
				<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4639</guid>

					<description><![CDATA[Introduction I&#8217;m all-in on using SwiftUI to build iOS apps. I find it so much simpler than wrangling with storyboards and UIKit. Unfortunately, there are still occasions when SwiftUI doesn&#8217;t let you do what you need‚Äîforcing you to break out into UIKit. That&#8217;s why I always focus on Apple&#8217;s SwiftUI enhancements at each year&#8217;s WWDC.]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>I&#8217;m all-in on using SwiftUI to build iOS apps. I find it so much simpler than wrangling with storyboards and UIKit. Unfortunately, there are still occasions when SwiftUI doesn&#8217;t let you do what you need‚Äîforcing you to break out into UIKit.</p>
<p>That&#8217;s why I always focus on Apple&#8217;s SwiftUI enhancements at each year&#8217;s WWDC. And, each year I&#8217;m rewarded with a few more enhancements that make SwiftUI more powerful and easy to work with. For example, iOS14 made it much <a href="https://www.mongodb.com/developer/how-to/realm-swiftui-maps-location/">easier to work with Apple Maps</a>.</p>
<p>WWDC 2021 was no exception, introducing a raft of <a href="https://developer.apple.com/videos/play/wwdc2021/10018/">SwiftUI enhancements that were coming in iOS 15/ SwiftUI 3 / Xcode 13</a>. As iOS 15 has now been released, it feels like a good time to cover the features that I&#8217;ve found the most useful.</p>
<p>I&#8217;ve revisited some of my existing iOS apps to see how I could exploit the new iOS 15 SwiftUI features to improve the user experience and/or simplify my code base. This article steps through the features I found most interesting/useful, and how I tested them out on my apps. These are the apps/branches that I worked with:</p>
<ul>
<li><a href="https://github.com/realm/RCurrency/">RCurrency</a></li>
<li><a href="https://github.com/realm/RChat/">RChat</a></li>
<li><a href="https://github.com/mongodb-developer/LiveTutorial2021/">LiveTutorial2021</a></li>
<li><a href="https://github.com/realm/task-tracker-swiftui/">task-tracker-swiftui</a></li>
</ul>
<h2>Prerequisites</h2>
<ul>
<li>Xcode 13</li>
<li>iOS 15</li>
<li><a href="https://github.com/realm/realm-cocoa/releases">Realm-Cocoa</a> (varies by app, but 10.13.0+ is safe for them all)</li>
</ul>
<h2>Lists</h2>
<p>SwiftUI <code>List</code>s are pretty critical to data-based apps. I use <code>List</code>s in almost every iOS app I build, typically to represent objects stored in Realm. That&#8217;s why I always go there first when seeing what&#8217;s new.</p>
<h3>Custom Swipe Options</h3>
<p>We&#8217;ve all used mobile apps where you swipe an item to the left for one action, and to the right for another. SwiftUI had a glaring omission‚Äîthe only supported action was to swipe left to delete an item.</p>
<p>This was a massive pain.</p>
<p>This limitation meant that my <a href="https://github.com/realm/task-tracker-swiftui/">task-tracker-swiftui</a> app had a cumbersome UI. You had to click on a task to expose a sheet that let you click on your preferred action.</p>
<p>With iOS 15, I can replace that popup sheet with swipe actions:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/swipe_action_b291b24533.gif" alt="iOS app showing that action buttons are revealed when swiping a list item to the left or right" /></p>
<p>The swipe actions are implemented in <a href="https://github.com/realm/task-tracker-swiftui/blob/main/task-tracker-swiftui/Views/Projects%20%26%20Tasks/TasksView.swift"><code>TasksView</code></a>:</p>
<pre><code class="swift">List {
   ForEach(tasks) { task in
       TaskView(task: task)
           .swipeActions(edge: .leading) {
               if task.statusEnum == .Open || task.statusEnum == .InProgress {
                   CompleteButton(task: task)
               }
               if task.statusEnum == .Open || task.statusEnum == .Complete {
                   InProgressButton(task: task)
               }
               if task.statusEnum == .InProgress || task.statusEnum == .Complete {
                   NotStartedButton(task: task)
               }
           }
           .swipeActions(edge: .trailing) {
               Button(role: .destructive, action: { $tasks.remove(task) }) {
                   Label("Delete", systemImage: "trash")
               }
           }
   }
}
</code></pre>
<p>The role of the delete button is set to <code>.destructive</code> which automatically sets the color to red.</p>
<p>For the other actions, I created custom buttons. For example, this is the code for <a href="https://github.com/realm/task-tracker-swiftui/blob/main/task-tracker-swiftui/Views/Projects%20%26%20Tasks/Buttons/CompleteButton.swift"><code>CompleteButton</code></a>:</p>
<pre><code class="swift">struct CompleteButton: View {
   @ObservedRealmObject var task: Task

   var body: some View {
       Button(action: { $task.statusEnum.wrappedValue = .Complete }) {
           Label("Complete", systemImage: "checkmark")
       }
       .tint(.green)
   }
}
</code></pre>
<h3>Searchable Lists</h3>
<p>When you&#8217;re presented with a long list of options, it helps the user if you offer a way to filter the results.</p>
<p><a href="https://github.com/realm/RCurrency/">RCurrency</a> lets the user choose between 150 different currencies. Forcing the user to scroll through the whole list wouldn&#8217;t make for a good experience. A search bar lets them quickly jump to the items they care about:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/search_d5cdac1c86.gif" alt="Animation showing currencies being filtered as a user types into the search box" /></p>
<p>The selection of the currency is implemented in the <a href="https://github.com/realm/RCurrency/blob/main/iOS-SwiftUI/RCurrency/RCurrency/Views/SymbolPickerView.swift"><code>SymbolPickerView</code></a> view.</p>
<p>The view includes a state variable to store the <code>searchText</code> (the characters that the user has typed) and a <code>searchResults</code> computed value that uses it to filter the full list of symbols:</p>
<pre><code class="swift">struct SymbolPickerView: View {
   ...
   @State private var searchText = ""
   ...
   var searchResults: Dictionary&lt;String, String&gt; {
       if searchText.isEmpty {
           return Symbols.data.symbols
       } else {
           return Symbols.data.symbols.filter {
               $0.key.contains(searchText.uppercased()) || $0.value.contains(searchText)}
       }
   }
}
</code></pre>
<p>The <code>List</code> then loops over those <code>searchResults</code>. We add the <code>.searchable</code> modifier to add the search bar, and bind it to the <code>searchText</code> state variable:</p>
<pre><code class="swift">List {
   ForEach(searchResults.sorted(by: &lt;), id: \.key) { symbol in
       ...
   }
}
.searchable(text: $searchText)
</code></pre>
<p>This is the full view:</p>
<pre><code class="swift">struct SymbolPickerView: View {
   @Environment(\.presentationMode) var presentationMode

   var action: (String) -&gt; Void
   let existingSymbols: [String]

   @State private var searchText = ""

   var body: some View {
       List {
           ForEach(searchResults.sorted(by: &lt;), id: \.key) { symbol in
               Button(action: {
                   pickedSymbol(symbol.key)
               }) {
                   HStack {
                       Image(symbol.key.lowercased())
                       Text("\(symbol.key): \(symbol.value)")
                   }
                   .foregroundColor(existingSymbols.contains(symbol.key) ? .secondary : .primary)
               }
               .disabled(existingSymbols.contains(symbol.key))
           }
       }
       .searchable(text: $searchText)
       .navigationBarTitle("Pick Currency", displayMode: .inline)
   }

   private func pickedSymbol(_ symbol: String) {
       action(symbol)
       presentationMode.wrappedValue.dismiss()
   }

   var searchResults: Dictionary&lt;String, String&gt; {
       if searchText.isEmpty {
           return Symbols.data.symbols
       } else {
           return Symbols.data.symbols.filter {
               $0.key.contains(searchText.uppercased()) || $0.value.contains(searchText)}
       }
   }
}
</code></pre>
<h2>Pull to Refresh</h2>
<p>We&#8217;ve all used this feature in iOS apps. You&#8217;re impatiently waiting on an important email, and so you drag your thumb down the page to get the app to check the server.</p>
<p>This feature isn&#8217;t always helpful for apps that use Realm and Realm Sync. When Realm cloud data changes, the local realm is updated, and your SwiftUI view automatically refreshes to show the new data.</p>
<p>However, the feature <strong>is</strong> useful for the RCurrency app. I can use it to refresh all of the locally-stored exchange rates with fresh data from the API:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/pull_to_refresh_b37e5a81b9.gif" alt="Animation showing currencies being refreshed when the screen is dragged dowm" /></p>
<p>We allow the user to trigger the refresh by adding a <code>.refreshable</code> modifier and action (<code>refreshAll</code>) to the list of currencies in <a href="https://github.com/realm/RCurrency/blob/main/iOS-SwiftUI/RCurrency/RCurrency/Views/CurrencyList/CurrencyListContainerView.swift"><code>CurrencyListContainerView</code></a>:</p>
<pre><code class="swift">List {
   ForEach(userSymbols.symbols, id: \.self) { symbol in
       CurrencyRowContainerView(baseSymbol: userSymbols.baseSymbol,
                                   baseAmount: $baseAmount,
                                   symbol: symbol,
                                   refreshNeeded: refreshNeeded)
           .listRowSeparator(.hidden)
   }
   .onDelete(perform: deleteSymbol)
}
.refreshable{ refreshAll() }
</code></pre>
<p>In that code snippet, you can see that I added the <code>.listRowSeparator(.hidden)</code> modifier to the <code>List</code>. This is another iOS 15 feature that hides the line that would otherwise be displayed between each <code>List</code> item. Not a big feature, but every little bit helps in letting us use native SwiftUI to get the exact design we want.</p>
<h2>Text</h2>
<h3>Markdown</h3>
<p>I&#8217;m a big fan of <a href="https://daringfireball.net/projects/markdown/">Markdown</a>. Markdown lets you write formatted text (including tables, links, and images) without taking your hands off the keyboard. I added this post to our CMS in markdown.</p>
<p>iOS 15 allows you to render markdown text within a <code>Text</code> view. If you pass a literal link to a <code>Text</code> view, then it&#8217;s automatically rendered correctly:</p>
<pre><code class="swift">struct MarkDownTest: View {
   var body: some View {
       Text("Let's see some **bold**, *italics* and some ***bold italic text***. ~~Strike that~~. We can even include a [link](https://realm.io)./")
   }
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/markdown1_718e4edcae.png" alt="Text formatted. Included bold, italics and a link" /></p>
<p>But, it doesn&#8217;t work out of the box for string constants or variables (e.g., data read from Realm):</p>
<pre><code class="swift">struct MarkDownTest: View {
   let myString = "Let's see some **bold**, *italics* and some ***bold italic text***. ~~Strike that~~. We can even include a [link](https://realm.io)./"

   var body: some View {
       Text(myString)
   }
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/markdown2_be6d3e6123.png" alt="Raw Markdown source code, rather than rendered text" /></p>
<p>The issue is that the version of <code>Text</code> that renders markdown expects to be passed an <code>AttributedString</code>. I created this simple <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Views/Components/MarkDown.swift"><code>Markdown</code></a> view to handle this for us:</p>
<pre><code class="swift">struct MarkDown: View {
   let text: String

   @State private var formattedText: AttributedString?

   var body: some View {
       Group {
           if let formattedText = formattedText {
               Text(formattedText)
           } else {
               Text(text)
           }
       }
       .onAppear(perform: formatText)
   }

   private func formatText() {
       do {
           try formattedText = AttributedString(markdown: text)
       } catch {
           print("Couldn't convert this from markdown: \(text)")
       }
   }
}
</code></pre>
<p>I updated the <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Views/Chat%20Messages/ChatBubbleView.swift"><code>ChatBubbleView</code></a> in RChat to use the <code>Markdown</code> view:</p>
<pre><code class="swift">if chatMessage.text != "" {
   MarkDown(text: chatMessage.text)
   .padding(Dimensions.padding)
}
</code></pre>
<p>RChat now supports markdown in user messages:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/markdown_in_R_Chat_b6d3a01409.gif" alt="Animation showing that Markdown source is converted to formated text in the RChat app" /></p>
<h3>Dates</h3>
<p>We all know that working with dates can be a pain. At least in iOS 15 we get some nice new functionality to control how we display dates and times. We use the new <code>Date.formatted</code> syntax.</p>
<p>In RChat, I want the date/time information included in a chat bubble to depend on how recently the message was sent. If a message was sent less than a minute ago, then I care about the time to the nearest second. If it were sent a day ago, then I want to see the day of the week plus the hour and minutes. And so on.</p>
<p>I created a <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Views/Components/TextDate.swift"><code>TextDate</code></a> view to perform this conditional formatting:</p>
<pre><code class="swift">struct TextDate: View {
   let date: Date

   private var isLessThanOneMinute: Bool { date.timeIntervalSinceNow &gt; -60 }
   private var isLessThanOneDay: Bool { date.timeIntervalSinceNow &gt; -60 * 60 * 24 }
   private var isLessThanOneWeek: Bool { date.timeIntervalSinceNow &gt; -60 * 60 * 24 * 7}
   private var isLessThanOneYear: Bool { date.timeIntervalSinceNow &gt; -60 * 60 * 24 * 365}

   var body: some View {
       if isLessThanOneMinute {
           Text(date.formatted(.dateTime.hour().minute().second()))
       } else {
           if isLessThanOneDay {
               Text(date.formatted(.dateTime.hour().minute()))
           } else {
               if isLessThanOneWeek {
                   Text(date.formatted(.dateTime.weekday(.wide).hour().minute()))
               } else {
                   if isLessThanOneYear {
                       Text(date.formatted(.dateTime.month().day()))
                   } else {
                       Text(date.formatted(.dateTime.year().month().day()))
                   }
               }
           }
       }
   }
}
</code></pre>
<p>This preview code lets me test it&#8217;s working in the Xcode Canvas preview:</p>
<pre><code class="swift">struct TextDate_Previews: PreviewProvider {
   static var previews: some View {
       VStack {
           TextDate(date: Date(timeIntervalSinceNow: -60 * 60 * 24 * 365)) // 1 year ago
           TextDate(date: Date(timeIntervalSinceNow: -60 * 60 * 24 * 7))   // 1 week ago
           TextDate(date: Date(timeIntervalSinceNow: -60 * 60 * 24))       // 1 day ago
           TextDate(date: Date(timeIntervalSinceNow: -60 * 60))            // 1 hour ago
           TextDate(date: Date(timeIntervalSinceNow: -60))                 // 1 minute ago
           TextDate(date: Date())                                          // Now
       }
   }
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/dates_9f872c74b7.png" alt="Screen capture of dates rendered in various formatt" /></p>
<p>We can then use <code>TextDate</code> in RChat&#8217;s <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Views/Chat%20Messages/ChatBubbleView.swift"><code>ChatBubbleView</code></a> to add context-sensitive date and time information:</p>
<pre><code class="swift">TextDate(date: chatMessage.timestamp)
   .font(.caption)
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/rchat_dates_034fae5600.png" alt="Screen capture of properly formatted dates against each chat message in the RChat app" /></p>
<h2>Keyboards</h2>
<p>Customizing keyboards and form input was a real pain in the early days of SwiftUI‚Äîtake a look at the work we did for the <a href="https://github.com/WildAid/o-fish-ios/tree/main/o-fish-ios/Views/Components/KeyboardControlling">WildAid O-FISH</a> app if you don&#8217;t believe me. Thankfully, iOS 15 has shown some love in this area. There are a couple of features that I could see an immediate use for&#8230;</p>
<h3>Submit Labels</h3>
<p>It&#8217;s now trivial to rename the on-screen keyboard&#8217;s &#8220;return&#8221; key. It sounds trivial, but it can give the user a big hint about what will happen if they press it.</p>
<p>To rename the return key, add a <a href="https://developer.apple.com/documentation/swiftui/form/submitlabel(_:)"><code>.submitLabel</code></a> modifier to the input field. You pass the modifier one of these values:</p>
<ul>
<li><code>done</code></li>
<li><code>go</code></li>
<li><code>send</code></li>
<li><code>join</code></li>
<li><code>route</code></li>
<li><code>search</code></li>
<li><code>return</code></li>
<li><code>next</code></li>
<li><code>continue</code></li>
</ul>
<p>I decided to use these labels to improve the login flow for the <a href="https://github.com/mongodb-developer/LiveTutorial2021">LiveTutorial2021</a> app. In <a href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/LoginView.swift"><code>LoginView</code></a>, I added a <code>submitLabel</code> to both the &#8220;email address&#8221; and &#8220;password&#8221; <code>TextFields</code>:</p>
<pre><code class="swift">TextField("email address", text: $email)
   .submitLabel(.next)
SecureField("password", text: $password)
   .onSubmit(userAction)
   .submitLabel(.go)
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/email_field_6245860cb5.png" alt="Screen capture showing that the &quot;return&quot; key is replaced with &quot;next&quot; when editing the email/username field" /></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/password_field_924329af36.png" alt="Screen capture showing that the &quot;return&quot; key is replaced with &quot;go&quot; when editing the password field" /></p>
<p>Note the <code>.onSubmit(userAction)</code> modifier on the password field. If the user taps &#8220;go&#8221; (or hits return on an external keyboard), then the <code>userAction</code> function is called. <code>userAction</code> either registers or logs in the user, depending on whether &#8220;Register new user‚Äù is checked.</p>
<h3>Focus</h3>
<p>It can be tedious to have to click between different fields on a form. iOS 15 makes it simple to automate that shifting focus.</p>
<p>Sticking with <a href="https://github.com/mongodb-developer/LiveTutorial2021/">LiveTutorial2021</a>, I want the &#8220;email address&#8221; field to be selected when the view opens. When the user types their address and hits ~~&#8221;return&#8221;~~ &#8220;next&#8221;, focus should move to the &#8220;password&#8221; field. When the user taps &#8220;go,&#8221; the app logs them in.</p>
<p>You can use the new <a href="https://developer.apple.com/documentation/swiftui/focusstate"><code>FocusState</code></a> SwiftUI property wrapper to create variables to represent the placement of focus in the view. It can be a boolean to flag whether the associated field is in focus. In our login view, we have two fields that we need to switch focus between and so we use the <code>enum</code> option instead.</p>
<p>In <a href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/LoginView.swift"><code>LoginView</code></a>, I define the <code>Field</code> enumeration type to represent whether the username (email address) or password is in focus. I then create the <code>focussedField</code> <code>@FocusState</code> variable to store the value using the <code>Field</code> type:</p>
<pre><code class="swift">enum Field: Hashable {
   case username
   case password
}

@FocusState private var focussedField: Field?
</code></pre>
<p>I use the <code>.focussed</code> modifier to bind <code>focussedField</code> to the two fields:</p>
<pre><code class="swift">TextField("email address", text: $email)
   .focused($focussedField, equals: .username)
   ...
SecureField("password", text: $password)
    .focused($focussedField, equals: .password)
   ...
</code></pre>
<p>It&#8217;s a two-way binding. If the user selects the email field, then <code>focussedField</code> is set to <code>.username</code>. If the code sets <code>focussedField</code> to <code>.password</code>, then focus switches to the password field.</p>
<p>This next step feels like a hack, but I&#8217;ve not found a better solution yet. When the view is loaded, the code waits half a second before setting focus to the username field. Without the delay, the focus isn&#8217;t set:</p>
<pre><code class="swift">VStack(spacing: 16) {
   ...
}
.onAppear {
   DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
       focussedField = .username
    ...
   }
}
</code></pre>
<p>The final step is to shift focus to the password field when the user hits the &#8220;next&#8221; key in the username field:</p>
<pre><code class="swift">TextField("email address", text: $email)
   .onSubmit { focussedField = .password }
   ...
</code></pre>
<p>This is the complete body from <a href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/LoginView.swift"><code>LoginView</code></a>:</p>
<pre><code class="swift">var body: some View {
   VStack(spacing: 16) {
       Spacer()
       TextField("email address", text: $email)
           .focused($focussedField, equals: .username)
           .submitLabel(.next)
           .onSubmit { focussedField = .password }
       SecureField("password", text: $password)
           .focused($focussedField, equals: .password)
           .onSubmit(userAction)
           .submitLabel(.go)
       Button(action: { newUser.toggle() }) {
           HStack {
               Image(systemName: newUser ? "checkmark.square" : "square")
               Text("Register new user")
               Spacer()
           }
       }
       Button(action: userAction) {
           Text(newUser ? "Register new user" : "Log in")
       }
       .buttonStyle(.borderedProminent)
       .controlSize(.large)
       Spacer()
   }
   .onAppear {
       DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
           focussedField = .username
       }
   }
   .padding()
}
</code></pre>
<h2>Buttons</h2>
<h3>Formatting</h3>
<p>Previously, I&#8217;ve created custom SwiftUI views to make buttons look like‚Ä¶. buttons.</p>
<p>Things get simpler in iOS 15.</p>
<p>In <a href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/LoginView.swift"><code>LoginView</code></a>, I added two new modifiers to my register/login button:</p>
<pre><code class="swift">Button(action: userAction) {
   Text(newUser ? "Register new user" : "Log in")
}
.buttonStyle(.borderedProminent)
.controlSize(.large)
</code></pre>
<p>Before making this change, I experimented with other button styles:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/button_styles_7882dc43b7.png" alt="Xcode. Showing button source code and the associated previews" /></p>
<h3>Confirmation</h3>
<p>It&#8217;s very easy to accidentally tap the &#8220;Logout&#8221; button, and so I wanted to add this confirmation dialog:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/confirm_logout_e913c93674.png" alt="Dialog for the user to confirm that they wish to log out" /></p>
<p>Again, iOS 15 makes this simple.</p>
<p>This is the modified version of the <code>LogoutButton</code> view:</p>
<pre><code class="swift">struct LogoutButton: View {
   ...
   @State private var isConfirming = false

   var body: some View {
       Button("Logout") { isConfirming = true }
       .confirmationDialog("Are you sure want to logout",
                           isPresented: $isConfirming) {
           Button(action: logout) {
               Text("Confirm Logout")
           }
           Button("Cancel", role: .cancel) {}
       }
   }
   ...
}
</code></pre>
<p>These are the changes I made:</p>
<ul>
<li>Added a new state variable (<code>isConfirming</code>)</li>
<li>Changed the logout button&#8217;s action from calling the <code>logout</code> function to setting <code>isConfirming</code> to <code>true</code></li>
<li>Added the <a href="https://developer.apple.com/documentation/swiftui/view/confirmationdialog(_:ispresented:titlevisibility:presenting:actions:)-9ibgk"><code>confirmationDialog</code></a> modifier to the button, providing three things:
<ul>
<li>The dialog title (I didn&#8217;t override the <code>titleVisibility</code> option and so the system decides whether this should be shown)</li>
<li>A binding to <code>isConfirming</code> that controls whether the dialog is shown or not</li>
<li>A view containing the contents of the dialog:
<ul>
<li>A button to logout the user</li>
<li>A cancel button</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>Material</h2>
<p>I&#8217;m no designer, and this is <em>blurring</em> the edges of what changes I consider worth adding.</p>
<p>The <a href="https://github.com/realm/RChat/">RChat</a> app may have to wait a moment while the backend MongoDB Realm application confirms that the user has been authenticated and logged in. I superimpose a progress view while that&#8217;s happening:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/busy_62dee69adb.png" alt="A semi-transparrent overlay to indicate that the apps is working on something" /></p>
<p>To make it look a bit more professional, I can update <a href="https://github.com/realm/RChat/blob/ios15/RChat-iOS/RChat/Views/Components/OpaqueProgressView.swift"><code>OpaqueProgressView</code></a> to use <a href="https://developer.apple.com/documentation/swiftui/material">Material</a> to blur the content that&#8217;s behind the overlay. To get this effect, I update the background modifier for the <code>VStack</code>:</p>
<pre><code class="swift">var body: some View {
   VStack {
       if let message = message {
           ProgressView(message)
       } else {
           ProgressView()
       }
   }
   .padding(Dimensions.padding)
   .background(.ultraThinMaterial,
               in: RoundedRectangle(cornerRadius: Dimensions.cornerRadius))
}
</code></pre>
<p>The result looks like this:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/busy_material_35e6fedf53.png" alt="A semi-transparrent overlay, with the background blurred, to indicate that the apps is working on something" /></p>
<h2>Developer Tools</h2>
<p>Finally, there are a couple of enhancements that are helpful during your development phase.</p>
<h3>Landscape Previews</h3>
<p>I&#8217;m a big fan of Xcode&#8217;s &#8220;Canvas&#8221; previews. Previews let you see what your view will look like. Previews update in more or less real time as you make code changes. You can even display multiple previews at once for example:</p>
<ul>
<li>For different devices: <code>.previewDevice(PreviewDevice(rawValue: "iPhone 12 Pro Max"))</code></li>
<li>For dark mode: <code>.preferredColorScheme(.dark)</code></li>
</ul>
<p>A glaring omission was that there was no way to preview landscape mode. That&#8217;s fixed in iOS 15 with the addition of the <a href="https://developer.apple.com/documentation/SwiftUI/View/previewInterfaceOrientation(_:)"><code>.previewInterfaceOrientation</code></a> modifier.</p>
<p>For example, this code will show two devices in the preview. The first will be in portrait mode. The second will be in landscape and dark mode:</p>
<pre><code class="swift">struct CurrencyRow_Previews: PreviewProvider {
   static var previews: some View {
       Group {
           List {
               CurrencyRowView(value: 3.23, symbol: "USD", baseValue: .constant(1.0))
               CurrencyRowView(value: 1.0, symbol: "GBP", baseValue: .constant(10.0))
           }
           List {
               CurrencyRowView(value: 3.23, symbol: "USD", baseValue: .constant(1.0))
               CurrencyRowView(value: 1.0, symbol: "GBP", baseValue: .constant(10.0))
           }
           .preferredColorScheme(.dark)
           .previewInterfaceOrientation(.landscapeLeft)
       }
   }
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/preview_demo_12b5116b98.gif" alt="Animation of Xcode preview. Shows that the preview updates in real time as the code is changed. There are previews for both landscape and portrait modes" /></p>
<h3>Self._printChanges</h3>
<p>SwiftUI is very smart at automatically refreshing views when associated state changes. But sometimes, it can be hard to figure out exactly why a view is or isn&#8217;t being updated.</p>
<p>iOS 15 adds a way to print out what pieces of state data have triggered each refresh for a view. Simply call <code>Self._printChanges()</code> from the body of your view. For example, I updated <a href="https://github.com/mongodb-developer/LiveTutorial2021/blob/main/iOS/LiveChat/LiveChat/Views/ContentView.swift"><code>ContentView</code></a> for the LiveChat app:</p>
<pre><code class="swift">struct ContentView: View {
   @State private var username = ""

   var body: some View {
       print(Self._printChanges())
       return NavigationView {
           Group {
               if app.currentUser == nil {
                   LoginView(username: $username)
               } else {
                   ChatRoomsView(username: username)
               }
           }
           .navigationBarTitle(username, displayMode: .inline)
           .navigationBarItems(trailing: app.currentUser != nil ? LogoutButton(username: $username) : nil) }
    }
}
</code></pre>
<p>If I log in and check the Xcode console, I can see that it&#8217;s the update to <code>username</code> that triggered the refresh (rather than <code>app.currentUser</code>):</p>
<pre><code class="swift">ContentView: _username changed.
</code></pre>
<p>There can be a lot of these messages, and so remember to turn them off before going into production.</p>
<h2>Conclusion</h2>
<p>SwiftUI is developing at pace. With each iOS release, there is less and less reason to not use it for all/some of your mobile app.</p>
<p>This post describes how to use some of the iOS 15 SwiftUI features that caught my attention. I focussed on the features that I could see would instantly benefit my most recent mobile apps. In this article, I&#8217;ve shown how those apps could be updated to use these features.</p>
<p>There are lots of features that I didn&#8217;t include here. A couple of notable omissions are:</p>
<ul>
<li><a href="https://developer.apple.com/documentation/swiftui/asyncimage"><code>AsyncImage</code></a> is going to make it far easier to work with images that are stored in the cloud. I didn&#8217;t need it for any of my current apps, but I&#8217;ve no doubt that I&#8217;ll be using it in a project soon.</li>
<li>The <a href="https://developer.apple.com/documentation/swiftui/anyview/task(priority:_:)/"><code>task</code></a> view modifier is going to have a significant effect on how people run asynchronous code when a view is loaded. I plan to cover this in a future article that takes a more general look at how to handle concurrency with Realm.</li>
<li>Adding a toolbar to your keyboards (e.g., to let the user switch between input fields).</li>
</ul>
<p>If you have any questions or comments on this post (or anything else Realm-related), then please raise them on our <a href="https://www.mongodb.com/community/forums/c/realm-sdks/58">community forum</a>. To keep up with the latest Realm news, follow <a href="https://twitter.com/realm">@realm</a> on Twitter and join the <a href="https://live.mongodb.com/realm-global-community/">Realm global community</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm/most-useful-ios-15-swiftui-features/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Migrating Your iOS App&#8217;s Synced Realm Schema in Production</title>
		<link>/mongodb/migrating-your-ios-apps-synced-realm-schema-in-production</link>
					<comments>/mongodb/migrating-your-ios-apps-synced-realm-schema-in-production#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Thu, 02 Sep 2021 08:25:39 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4626</guid>

					<description><![CDATA[Introduction In the previous post in this series, we saw how to migrate your Realm data when you upgraded your iOS app with a new schema. But, that only handled the data in your local, standalone Realm database. What if you&#8217;re using MongoDB Realm Sync to replicate your local Realm data with other instances of]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>In the <a href="https://www.mongodb.com/developer/how-to/realm-schema-migration">previous post in this series</a>, we saw how to migrate your Realm data when you upgraded your iOS app with a new schema. But, that only handled the data in your local, standalone Realm database. What if you&#8217;re using <a href="https://docs.mongodb.com/realm/sync/">MongoDB Realm Sync</a> to replicate your local Realm data with other instances of your mobile app and with MongoDB Atlas? That&#8217;s what this article will focus on.</p>
<p>We&#8217;ll start with the original <a href="https://www.mongodb.com/developer/how-to/building-a-mobile-chat-app-using-realm-new-way/">RChat app</a>. We&#8217;ll then extend the iOS app and backend Realm schema to add a new feature that allows chat messages to be tagged as high priority. The next (and perhaps surprisingly more complicated from a Realm perspective) upgrade is to make the <code>author</code> attribute of the existing <code>ChatMessage</code> object non-optional.</p>
<p>You can find all of the code for this post in the RChat repo under these branches:</p>
<ul>
<li><a href="https://github.com/realm/RChat">Starting point</a></li>
<li><a href="https://github.com/realm/RChat/tree/new-schema">Upgrade #1</a></li>
<li><a href="https://github.com/realm/RChat/tree/v2-schema">Upgrade #2</a></li>
</ul>
<h2>Prerequisites</h2>
<p><a href="https://github.com/realm/realm-cocoa/releases">Realm Cocoa 10.13.0</a> or later (for versions of the app that you&#8217;re upgrading <strong>to</strong>)</p>
<h2>Catch-Up ‚Äî The RChat App</h2>
<p>RChat is a basic chat app:</p>
<ul>
<li>Users can register and log in using their email address and a password.</li>
<li>Users can create chat rooms and include other users in those rooms.</li>
<li>Users can post messages to a chat room (optionally including their location and photos).</li>
<li>All members of a chatroom can see messages sent to the room by themselves or other users.</li>
</ul>
<p><iframe width="600" height="340" src="https://www.youtube.com/embed/BlV9El_MJqk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h2>Upgrade #1: Add a High-Priority Flag to Chat Messages</h2>
<p>The first update is to allow a user to tag a message as being high-priority as they post it to the chat room:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Set_Priority_a2c8f60550.png" alt="Screenshot showing the option to click a thermometer button to tag the message as urgent" /></p>
<p>That message is then highlighted with bold text and a &#8220;hot&#8221; icon in the list of chat messages:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/View_Priority_1991c9d4bf.png" alt="Screenshot showing that a high-priority message has bold text and a hot thermometer icon" /></p>
<h3>Updating the Backend Realm Schema</h3>
<p>Adding a new field is an <a href="https://docs.mongodb.com/realm/sync/synced-schema-overview/">additive change</a>‚Äîmeaning that you don&#8217;t need to restart sync (which would require every deployed instance of the RChat mobile app to recognize the change and start sync from scratch, potentially losing local changes).</p>
<p>We add the new <code>isHighPriority</code> bool to our Realm schema through the Realm UI:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Update_Schema_v1_b9ff24b45c.png" alt="Screenshot from the RealmUI showing that the isHighPriority bool has been added to the schema" /></p>
<p>We also make <code>isHighPriority</code> a required (non-optional field).</p>
<p>The resulting schema looks like this:</p>
<pre><code class="js">{
   "bsonType": "object",
   "properties": {
     "_id": {
       "bsonType": "string"
     },
     "author": {
       "bsonType": "string"
     },
     "image": {
       "bsonType": "object",
       "properties": {
         "_id": {
           "bsonType": "string"
         },
         "date": {
           "bsonType": "date"
         },
         "picture": {
           "bsonType": "binData"
         },
         "thumbNail": {
           "bsonType": "binData"
         }
       },
       "required": [
         "_id",
         "date"
       ],
       "title": "Photo"
     },
     "isHighPriority": {
       "bsonType": "bool"
     },
     "location": {
       "bsonType": "array",
       "items": {
         "bsonType": "double"
       }
     },
     "partition": {
       "bsonType": "string"
     },
     "text": {
       "bsonType": "string"
     },
     "timestamp": {
       "bsonType": "date"
     }
   },
   "required": [
     "_id",
     "partition",
     "text",
     "timestamp",
     "isHighPriority"
   ],
   "title": "ChatMessage"
 }
</code></pre>
<p>Note that existing versions of our iOS RChat app can continue to work with our updated backend Realm app, even though their local <code>ChatMessage</code> Realm objects don&#8217;t include the new field.</p>
<h3>Updating the iOS RChat App</h3>
<p>While existing versions of the iOS RChat app can continue to work with the updated Realm backend app, they can&#8217;t use the new <code>isHighPriority</code> field as it isn&#8217;t part of the <code>ChatMessage</code> object.</p>
<p>To add the new feature, we need to update the mobile app after deploying the updated Realm backend application.</p>
<p>The first change is to add the <code>isHighPriority</code> field to the <code>ChatMessage</code> class:</p>
<pre><code class="swift">class ChatMessage: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id = UUID().uuidString
   @Persisted var partition = "" // "conversation=&lt;conversation-id&gt;"
   @Persisted var author: String? // username
   @Persisted var text = ""
   @Persisted var image: Photo?
   @Persisted var location = List&lt;Double&gt;()
   @Persisted var timestamp = Date()
   @Persisted var isHighPriority = false
   ...
}
</code></pre>
<p>As seen in the <a href="https://www.mongodb.com/developer/how-to/realm-schema-migration">previous post in this series</a>, Realm can automatically update the local realm to include this new attribute and initialize it to <code>false</code>. Unlike with standalone realms, we **don&#8217;t*- need to signal to the Realm SDK that we&#8217;ve updated the schema by providing a schema version.</p>
<p>The new version of the app will happily exchange messages with instances of the original app on other devices (via our updated backend Realm app).</p>
<h2>Upgrade #2: Make <code>author</code> a Non-Optional Chat Message field</h2>
<p>When the initial version of RChat was written, the <code>author</code> field of <code>ChatMessage</code> was declared as being optional. We&#8217;ve since realized that there are no scenarios where we wouldn&#8217;t want the author included in a chat message. To make sure that no existing or future client apps neglect to include the author, we need to update our schema to make <code>author</code> a required field.</p>
<p>Unfortunately, changing a field from optional to required (or vice versa) is a <a href="https://docs.mongodb.com/realm/sync/synced-schema-overview/#destructive-changes">destructive change</a>, and so would break sync for any deployed instances of the RChat app.</p>
<p>Oops!</p>
<p>This means that there&#8217;s extra work needed to make the upgrade seamless for the end users. We&#8217;ll go through the process now.</p>
<h3>Updating the Backend Realm Schema</h3>
<p>The change we need to make to the schema is destructive. This means that the new document schema is incompatible with the schema that&#8217;s currently being used in our mobile app.</p>
<p>If RChat wasn&#8217;t already deployed on the devices of hundreds of millions of users (we can dream!), then we could update the Realm schema for the <code>ChatMessage</code> collection and restart Realm Sync. During development, we can simply remove the original RChat mobile app and then install an updated version on our test devices.</p>
<p>To avoid that trauma for our end users, we leave the <code>ChatMessage</code> collection&#8217;s schema as is and create a <a href="https://docs.mongodb.com/realm/sync/migrate-schema-partner-collection/#partner-collections">partner collection</a>. The partner collection (<code>ChatMessageV2</code>) will contain the same data as <code>ChatMessage</code>, except that its schema makes <code>author</code> a required field.</p>
<p>These are the steps we&#8217;ll go through to create the partner collection:</p>
<ul>
<li>Define a Realm schema for the <code>ChatMessageV2</code> collection.</li>
<li>Run an <a href="https://docs.mongodb.com/manual/aggregation/">aggregation</a> to copy all of the documents from <code>ChatMessage</code> to <code>ChatMessageV2</code>. If <code>author</code> is missing from a <code>ChatMessage</code> document, then the aggregation will add it.</li>
<li>Add a trigger to the <code>ChatMessage</code> collection to propagate any changes to <code>ChatMessageV2</code> (adding <code>author</code> if needed).</li>
<li>Add a trigger to the <code>ChatMessageV2</code> collection to propagate any changes to <code>ChatMessage</code>.</li>
</ul>
<h4>Define the Schema for the Partner Collection</h4>
<p>From the Realm UI, copy the schema from the <code>ChatMessage</code> collection.</p>
<p>Click the button to create a new schema:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/add_collection_c16ec9a063.png" alt="Showing a plus button in the Realm UI to add a new collection" /></p>
<p>Set the database and collection name before clicking &#8220;Add Collection&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/config_collection_324bc0182e.png" alt="Setting the database and collection names in the Realm UI" /></p>
<p>Paste in the schema copied from <code>ChatMessage</code>, add <code>author</code> to the <code>required</code> section, change the <code>title</code> to <code>ChatMessageV2</code>, and the click the &#8220;SAVE&#8221; button:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/define_schema_be6ae7c555.png" alt="Adding &quot;author&quot; to the required attribute list and naming the class ChatMessageV2 in the Realm UI" /></p>
<p>This is the resulting schema:</p>
<pre><code class="js">{
   "bsonType": "object",
   "properties": {
     "_id": {
       "bsonType": "string"
     },
     "author": {
       "bsonType": "string"
     },
     "image": {
       "bsonType": "object",
       "properties": {
         "_id": {
           "bsonType": "string"
         },
         "date": {
           "bsonType": "date"
         },
         "picture": {
           "bsonType": "binData"
         },
         "thumbNail": {
           "bsonType": "binData"
         }
       },
       "required": [
         "_id",
         "date"
       ],
       "title": "Photo"
     },
     "isHighPriority": {
       "bsonType": "bool"
     },
     "location": {
       "bsonType": "array",
       "items": {
         "bsonType": "double"
       }
     },
     "partition": {
       "bsonType": "string"
     },
     "text": {
       "bsonType": "string"
     },
     "timestamp": {
       "bsonType": "date"
     }
   },
   "required": [
     "_id",
     "partition",
     "text",
     "timestamp",
     "isHighPriority",
     "author"
   ],
   "title": "ChatMessageV2"
 }
</code></pre>
<h4>Copy Existing Data to the Partner Collection</h4>
<p>We&#8217;re going to use an <a href="https://docs.mongodb.com/manual/aggregation/">aggregation pipeline</a> to copy and transform the existing data from the original collection (<code>ChatMessage</code>) to the partner collection (<code>ChatMessageV2</code>).</p>
<p>You may want to pause sync just before you run the aggregation, and then unpause it after you enable the trigger on the <code>ChatMessage</code> collection in the next step:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/pause_sync_707605a511.png" alt="Pressing a button to pause Realm sync in the Realm UI" /></p>
<p>The end users can continue to create new messages while sync is paused, but those messages won&#8217;t be published to other users until sync is resumed. By pausing sync, you can ensure that all new messages will make it into the partner collection (and so be visible to users running the new version of the mobile app).</p>
<p>If pausing sync is too much of an inconvenience, then you could create a temporary trigger on the <code>ChatMessage</code> collection that will copy and transform document inserts to the <code>ChatMessageV2</code> collection (it&#8217;s a subset of the <code>ChatMessageProp</code> trigger we&#8217;ll define in the next section.).</p>
<p>From the Atlas UI, select &#8220;Collections&#8221; -> &#8220;ChatMessage&#8221;, &#8220;New Pipeline From Text&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/add_aggregation_2e84c4a8df.png" alt="Navigating through &quot;Atlas/ChatMessage/Collections/New Pipeline from Text&quot; in the Realm UI" /></p>
<p>Paste in this aggregation pipeline and click the &#8220;Create New&#8221; button:</p>
<pre><code class="js">[
 {
   '$addFields': {
     'author': {
       '$convert': {
         'input': '$author',
         'to': 'string',
         'onError': 'unknown',
         'onNull': 'unknown'
       }
     }
   }
 },
 {
   '$merge': {
     into: "ChatMessageV2",
     on: "_id",
     whenMatched: "replace",
     whenNotMatched: "insert"
   }
 }
]
</code></pre>
<p>This aggregation will take each <code>ChatMessage</code> document, set <code>author</code> to &#8220;unknown&#8221; if it&#8217;s not already set, and then add it to the <code>ChatMessageV2</code> collection.</p>
<p>Click &#8220;MERGE DOCUMENTS&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/merge_documents_8b40ae6ce6.png" alt="Clicking the &quot;Merge Documents&quot; button in the Realm UI" /></p>
<p><code>ChatMessageV2</code> now contains a (possibly transformed) copy of every document from <code>ChatMessage</code>. But, changes to one collection won&#8217;t be propagated to the other. To address that, we add a database trigger to each collection‚Ä¶</p>
<h4>Add Database Triggers</h4>
<p>We need to create two <a href="https://docs.mongodb.com/realm/functions/">Realm Functions</a>‚Äîone to copy/transfer documents to <code>ChatMessageV2</code>, and one to copy documents to <code>ChatMessage</code>.</p>
<p>From the &#8220;Functions&#8221; section of the Realm UI, click &#8220;Create New Function&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/new_function_3fd3b90a11.png" alt="Clicking the &quot;Create New Function&quot; button in the Realm UI" /></p>
<p>Name the function <code>copyToChatMessageV2</code>. Set the authentication method to &#8220;System&#8221;‚Äîthis will circumvent any access permissions on the <code>ChatMessageV2</code> collection. Ensure that the &#8220;Private&#8221; switch is turned on‚Äîthat means that the function can be called from a trigger, but not directly from a frontend app. Click &#8220;Save&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/configure_function_6acb29f42b.png" alt="Set the name to &quot;copyToChatMessageV2&quot;, authentication to &quot;System&quot; and &quot;Private&quot; to &quot;On&quot;. Then click the &quot;Save&quot; button in the Realm UI" /></p>
<p>Paste this code into the function editor and save:</p>
<pre><code class="js">exports = function (changeEvent) {
   const db = context.services.get("mongodb-atlas").db("RChat");


   if (changeEvent.operationType === "delete") {
     return db.collection("ChatMessageV2").deleteOne({ _id: changeEvent.documentKey._id });
   }


   const author = changeEvent.fullDocument.author ? changeEvent.fullDocument.author : "Unknown";
   const pipeline = [
     { $match: { _id: changeEvent.documentKey._id } },
     {
       $addFields: {
         author: author,
       }
     },
     { $merge: "ChatMessageV2" }];


   return db.collection("ChatMessage").aggregate(pipeline);
};
</code></pre>
<p>This function will receive a <code>ChatMessage</code> document from our trigger. If the operation that triggered the function is a delete, then this function deletes the matching document from <code>ChatMessageV2</code>. Otherwise, the function either copies <code>author</code> from the incoming document or sets it to &#8220;Unknown&#8221; before writing the transformed document to <code>ChatMessageV2</code>. We could initialize <code>author</code> to any string, but I&#8217;ve used &#8220;Unknown&#8221; to tell the user that we don&#8217;t know who the author was.</p>
<p>Create the <code>copyToChatMessage</code> function in the same way:</p>
<pre><code class="js">exports = function (changeEvent) {
   const db = context.services.get("mongodb-atlas").db("RChat");


   if (changeEvent.operationType === "delete") {
     return db.collection("ChatMessage").deleteOne({ _id: changeEvent.documentKey._id })
   }
    const pipeline = [
     { $match: { _id: changeEvent.documentKey._id } },
     { $merge: "ChatMessage" }]
   return db.collection("ChatMessageV2").aggregate(pipeline);
};
</code></pre>
<p>The final change needed to the backend Realm application is to add database triggers that invoke these functions.</p>
<p>From the &#8220;Triggers&#8221; section of the Realm UI, click &#8220;Add a Trigger&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/configure_trigger_558a629423.png" alt="Click the &quot;Add a Trigger&quot; button in the Realm UI" /></p>
<p>Configure the <code>ChatMessageProp</code> trigger as shown:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/trigger_settings_1601e02011.png" alt="In the Realm UI, set &quot;Trigger Type&quot; to &quot;Database&quot;. Set &quot;Name&quot; to &quot;ChatMessageProp&quot;. Enabled = On. Event Ordering = on. Cluster Name = Cluster 0. Database name = RChat. Collection name = ChatMessage. Check all operation types. Full Document = on. Document Preimage = off. Event Type = Function. Function = copyToChatMessageV2" /></p>
<p>Repeat for <code>ChatMessageV2Change</code>:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/trigger2_settings_c55de55738.png" alt="In the Realm UI, set &quot;Trigger Type&quot; to &quot;Database&quot;. Set &quot;Name&quot; to &quot;ChatMessageProp&quot;. Enabled = On. Event Ordering = on. Cluster Name = Cluster 0. Database name = RChat. Collection name = ChatMessage. Check all operation types. Full Document = off. Document Preimage = off. Event Type = Function. Function = copyToChatMessage" /></p>
<p>If you paused sync in the previous section, then you can now unpause it.</p>
<h3>Updating the iOS RChat App</h3>
<p>We want to ensure that users still running the old version of the app can continue to exchange messages with users running the latest version.</p>
<p>Existing versions of RChat will continue to work. They will create <code>ChatMessage</code> objects which will get synced to the <code>ChatMessage</code> Atlas collection. The database triggers will then copy/transform the document to the <code>ChatMessageV2</code> collection.</p>
<p>We now need to create a new version of the app that works with documents from the <code>ChatMessageV2</code> collection. We&#8217;ll cover that in this section.</p>
<p>Recall that we set <code>title</code> to <code>ChatMessageV2</code> in the partner collection&#8217;s schema. That means that to sync with that collection, we need to rename the <code>ChatMessage</code> class to <code>ChatMessageV2</code> in the iOS app.</p>
<p>Changing the name of the class throughout the app is made trivial by Xcode.</p>
<p>Open <code>ChatMessage.swift</code> and right-click on the class name (<code>ChatMessage</code>), select &#8220;Refactor&#8221; and then &#8220;Rename‚Ä¶&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/refactor1_4c2d938e3d.png" alt="In Xcode, select the &quot;ChatMessage&quot; class name, right-click and select &quot;Refactor -> Rename&#8230;&quot;&#8221; /></p>
<p>Override the class name with <code>ChatMessageV2</code> and click &#8220;Rename&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/refactor2_03837b2472.png" alt="In Xcode, overwrite the class name with &quot;ChatMessageV2&quot; and then click the &quot;Rename&quot; button" /></p>
<p>The final step is to make the author field mandatory. Remove the ? from the author attribute to make it non-optional:</p>
<pre><code class="swift">class ChatMessageV2: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id = UUID().uuidString
   @Persisted var partition = "" // "conversation=&lt;conversation-id&gt;"
   @Persisted var author: String
   ...
}
</code></pre>
<h2>Conclusion</h2>
<p>Modifying a Realm schema is a little more complicated when you&#8217;re using Realm Sync for a deployed app. You&#8217;ll have end users who are using older versions of the schema, and those apps need to continue to work.</p>
<p>Fortunately, the most common schema changes (adding or removing fields) are additive. They simply require updates to the back end and iOS schema.</p>
<p>Things get a little trickier for destructive changes, such as changing the type or optionality of an existing field. For these cases, you need to create and maintain a partner collection to avoid loss of data or service for your users.</p>
<p>This article has stepped through how to handle both additive and destructive schema changes, allowing you to add new features or fix issues in your apps without impacting users running older versions of your app.</p>
<p>Remember, you can find all of the code for this post in the RChat repo under these branches:</p>
<ul>
<li><a href="https://github.com/realm/RChat">Starting point</a></li>
<li><a href="https://github.com/realm/RChat/tree/new-schema">Upgrade #1</a></li>
<li><a href="https://github.com/realm/RChat/tree/v2-schema">Upgrade #2</a></li>
</ul>
<p>If you&#8217;re looking to upgrade the Realm schema for an iOS app that <strong>isn&#8217;t</strong> using Realm Sync, then refer to the <a href="https://www.mongodb.com/developer/how-to/realm-schema-migration">previous post in this series</a>.</p>
<p>If you have any questions or comments on this post (or anything else Realm-related), then please raise them on our <a href="https://www.mongodb.com/community/forums/c/realm-sdks/58">community forum</a>. To keep up with the latest Realm news, follow <a href="https://twitter.com/realm">@realm</a> on Twitter and join the <a href="https://live.mongodb.com/realm-global-community/">Realm global community</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/migrating-your-ios-apps-synced-realm-schema-in-production/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Migrating Your iOS App&#8217;s Realm Schema in Production</title>
		<link>/mongodb/migrating-your-ios-apps-realm-schema-in-production</link>
					<comments>/mongodb/migrating-your-ios-apps-realm-schema-in-production#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Fri, 27 Aug 2021 08:26:22 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4623</guid>

					<description><![CDATA[Introduction Murphy&#8217;s law dictates that as soon as your mobile app goes live, you&#8217;ll receive a request to add a new feature. Then another. Then another. This is fine if these features don&#8217;t require any changes to your data schema. But, that isn&#8217;t always the case. Fortunately, Realm has built-in functionality to make schema migration]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p><a href="https://en.wikipedia.org/wiki/Murphy%27s_law">Murphy&#8217;s law</a> dictates that as soon as your mobile app goes live, you&#8217;ll receive a request to add a new feature. Then another. Then another.</p>
<p>This is fine if these features don&#8217;t require any changes to your data schema. But, that isn&#8217;t always the case.</p>
<p>Fortunately, Realm has built-in functionality to make schema migration easier.</p>
<p>This tutorial will step you through updating an existing mobile app to add some new features that require changes to the schema. In particular, we&#8217;ll look at the Realm migration code that ensures that no existing data is lost when the new app versions are rolled out to your production users.</p>
<p>We&#8217;ll use the <a href="https://www.mongodb.com/developer/how-to/realm-swiftui-scrumdinger-migration/">Scrumdinger app that I modified in a previous post to show how Apple&#8217;s sample Swift app could be ported to Realm</a>. The starting point for the app can be found in <a href="https://github.com/realm/Scrumdinger/tree/realm">this branch of our Scrumdinger repo</a> and the final version is in <a href="https://github.com/realm/Scrumdinger/tree/new-schema">this branch</a>.</p>
<p>Note that the app we&#8217;re using for this post doesn&#8217;t use <a href="https://docs.mongodb.com/realm/sync/">MongoDB Realm Sync</a>. If it did, then the schema migration process would be very different‚ÄîI&#8217;ll cover that in a future tutorial, but for now, you can check out the <a href="https://docs.mongodb.com/realm/sync/migrate-schema-partner-collection/">docs</a>.</p>
<h2>Prerequisites</h2>
<p>This tutorial has a dependency on <a href="https://github.com/realm/realm-cocoa/releases">Realm-Cocoa 10.13.0+</a>.</p>
<h2>Baseline App/Realm Schema</h2>
<p>As a reminder, the starting point for this tutorial is the <a href="https://github.com/realm/scrumdinger/tree/realm">&#8220;realm&#8221; branch of the Scrumdinger repo</a>.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/scrumdinger_original_b6a15f10ea.gif" alt="Animated gif of the original Scrumdinger app in action" /></p>
<p>There are two Realm model classes that we&#8217;ll extend to add new features to Scrumdinger. The first, <a href="https://github.com/realm/Scrumdinger/blob/realm/Scrumdinger/Models/DailyScrum.swift">DailyScrum</a>, represents one scrum:</p>
<pre><code class="swift">class DailyScrum: Object, ObjectKeyIdentifiable {
   @Persisted var title = ""
   @Persisted var attendeeList = RealmSwift.List&lt;String&gt;()
   @Persisted var lengthInMinutes = 0
   @Persisted var colorComponents: Components?
   @Persisted var historyList = RealmSwift.List&lt;History&gt;()


   var color: Color { Color(colorComponents ?? Components()) }
   var attendees: [String] { Array(attendeeList) }
   var history: [History] { Array(historyList) }
   ...
}
</code></pre>
<p>The second, <a href="https://github.com/realm/Scrumdinger/blob/realm/Scrumdinger/Models/History.swift">History</a>, represents the minutes of a meeting from one of the user&#8217;s scrums:</p>
<pre><code class="swift">class History: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var date: Date?
   @Persisted var attendeeList = List&lt;String&gt;()
   @Persisted var lengthInMinutes: Int = 0
   @Persisted var transcript: String?
   var attendees: [String] { Array(attendeeList) }
   ...
}
</code></pre>
<p>We can use <a href="https://docs.mongodb.com/realm/studio/">Realm Studio</a> to examine the contents of our Realm database after the <code>DailyScrum</code> and <code>History</code> objects have been created:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Daily_Scrum_original_117e226072.png" alt="DailyScrum data shown in RealmStudio" /></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/History_original_fcc4e0b78d.png" alt="History data shown in RealmStudio" /></p>
<p><a href="https://www.mongodb.com/developer/how-to/realm-ios-database-access-using-realm-studio/">Accessing Realm Data on iOS Using Realm Studio</a> explains how to locate and open the Realm files from your iOS simulator.</p>
<h2>Schema Change #1‚ÄîMark Scrums as Public/Private</h2>
<p>The first new feature we&#8217;ve been asked to add is a flag to indicate whether each scrum is public or private:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Scrumdinger_show_privacy_00eb2f407b.png" alt="Screen capture highlighting the new status - set to &quot;Private&quot;" /></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Scrumdinger_edit_privacy_8df1447d57.png" alt="Screen capture showing the user setting the meeting status to &quot;Public&quot;" /></p>
<p>This feature requires the addition of a new <code>Bool</code> named <code>isPublic</code> to <a href="https://github.com/realm/Scrumdinger/blob/new-schema/Scrumdinger/Models/DailyScrum.swift">DailyScrum</a>:</p>
<pre><code class="swift">class DailyScrum: Object, ObjectKeyIdentifiable {
   @Persisted var title = ""
   @Persisted var attendeeList = RealmSwift.List&lt;String&gt;()
   @Persisted var lengthInMinutes = 0
   @Persisted var isPublic = false
   @Persisted var colorComponents: Components?
   @Persisted var historyList = RealmSwift.List&lt;History&gt;()


   var color: Color { Color(colorComponents ?? Components()) }
   var attendees: [String] { Array(attendeeList) }
   var history: [History] { Array(historyList) }
   ...
}
</code></pre>
<p>Remember that our original version of Scrumdinger is already in production, and the embedded Realm database is storing instances of <code>DailyScrum</code>. We don&#8217;t want to lose that data, and so we must migrate those objects to the new schema when the app is upgraded.</p>
<p>Fortunately, Realm has built-in functionality to automatically handle the addition and deletion of fields. When adding a field, Realm will use a default value (e.g., <code>0</code> for an <code>Int</code>, and <code>false</code> for a <code>Bool</code>).</p>
<p>If we simply upgrade the installed app with the one using the new schema, then we&#8217;ll get a fatal error. That&#8217;s because we need to tell Realm that we&#8217;ve updated the schema. We do that by setting the schema version to 1 (the version defaulted to 0 for the original schema):</p>
<pre><code class="swift">@main
struct ScrumdingerApp: SwiftUI.App {
   var body: some Scene {
       WindowGroup {
           NavigationView {
               ScrumsView()
                   .environment(\.realmConfiguration,
                       Realm.Configuration(schemaVersion: 1))
           }
       }
   }
}
</code></pre>
<p>After upgrading the app, we can use <a href="https://docs.mongodb.com/realm/studio/">Realm Studio</a> to confirm that our <code>DailyScrum</code> object has been updated to initialize <code>isPublic</code> to <code>false</code>:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Daily_Scrum_updated_19c30fabd6.png" alt="RealmStudio showing that the new, isPublic field has been initialised to false" /></p>
<h2>Schema Change #2‚ÄîStore The Number of Attendees at Each Meeting</h2>
<p>The second feature request is to show the number of attendees in the history from each meeting:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Scrumdinger_History_Change_5218655494.png" alt="Screen capture showing that the number of attendees is now displayed in the meeting minutes" /></p>
<p>We could calculate the count every time that it&#8217;s needed, but we&#8217;ve decided to calculate it just once and then store it in our <a href="https://github.com/realm/Scrumdinger/blob/new-schema/Scrumdinger/Models/History.swift">History</a> object in a new field named <code>numberOfAttendees</code>:</p>
<pre><code class="swift">class History: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var date: Date?
   @Persisted var attendeeList = List&lt;String&gt;()
   @Persisted var numberOfAttendees = 0
   @Persisted var lengthInMinutes: Int = 0
   @Persisted var transcript: String?
   var attendees: [String] { Array(attendeeList) }
   ...
}
</code></pre>
<p>We increment the schema version to 2. Note that the schema version applies to all Realm objects, and so we have to set the version to 2 even though this is the first time that we&#8217;ve changed the schema for <code>History</code>.</p>
<p>If we leave it to Realm to initialize <code>numberOfAttendees</code>, then it will set it to 0‚Äîwhich is not what we want. Instead, we provide a <code>migrationBlock</code> which initializes new fields based on the old schema version:</p>
<pre><code class="swift">@main
struct ScrumdingerApp: SwiftUI.App {
   var body: some Scene {
       WindowGroup {
           NavigationView {
               ScrumsView()
                   .environment(\.realmConfiguration, Realm.Configuration(
                       schemaVersion: 2,
                       migrationBlock: { migration, oldSchemaVersion in
                            if oldSchemaVersion &lt; 1 {
                                // Could init the `DailyScrum.isPublic` field here, but the default behavior of setting
                                // it to `false` is what we want.
                            }
                            if oldSchemaVersion &lt; 2 {
                                migration.enumerateObjects(ofType: History.className()) { oldObject, newObject in
                                    let attendees = oldObject!["attendeeList"] as? RealmSwift.List&lt;DynamicObject&gt;
                                    newObject!["numberOfAttendees"] = attendees?.count ?? 0
                                }
                            }
                            if oldSchemaVersion &lt; 3 {
                                // TODO: This is where you'd add you're migration code to go from version
                                // to version 3 when you next modify the schema
                            }
                        }
                   ))
           }
       }
   }
}
</code></pre>
<p>Note that all other fields are migrated automatically.</p>
<p>It&#8217;s up to you how you use data from the previous schema to populate fields in the new schema. E.g., if you wanted to combine <code>firstName</code> and <code>lastName</code> from the previous schema to populate a <code>fullName</code> field in the new schema, then you could do so like this:</p>
<pre><code class="swift">migration.enumerateObjects(ofType: Person.className()) { oldObject, newObject in
   let firstName = oldObject!["firstName"] as! String
   let lastName = oldObject!["lastName"] as! String
   newObject!["fullName"] = "\(firstName) \(lastName)"
}
</code></pre>
<p>We can&#8217;t know what &#8220;old version&#8221; of the schema will be already installed on a user&#8217;s device when it&#8217;s upgraded to the latest version (some users may skip some versions,) and so the <code>migrationBlock</code> must handle all previous versions. Best practice is to process the incremental schema changes sequentially:</p>
<ul>
<li><code>oldSchemaVersion &lt; 1</code> : Process the delta between v0 and v1</li>
<li><code>oldSchemaVersion &lt; 2</code> : Process the delta between v1 and v2</li>
<li><code>oldSchemaVersion &lt; 3</code> : Process the delta between v2 and v3</li>
<li>&#8230;</li>
</ul>
<p>Realm Studio shows that our code has correctly initialized <code>numberOfAttendees</code>:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/History_new_11564ec4b0.png" alt="Realm Studio showing that the numberOfAttendees field has been set to 2 ‚Äì¬†matching the number of attendees in the meeting history" /></p>
<h2>Conclusion</h2>
<p>It&#8217;s almost inevitable that any successful mobile app will need some schema changes after it&#8217;s gone into production. Realm makes adapting to those changes simple, ensuring that users don&#8217;t lose any of their existing data when upgrading to new versions of the app.</p>
<p>For changes such as adding or removing fields, all you need to do as a developer is to increment the version with each new deployed schema. For more complex changes, you provide code that computes the values for fields in the new schema using data from the old schema.</p>
<p>This tutorial stepped you through adding two new features that both required schema changes. You can view the final app in the <a href="https://github.com/realm/Scrumdinger/tree/new-schema">new-schema branch of the Scrumdinger repo</a>.</p>
<h2>Next Steps</h2>
<p>This post focussed on schema migration for an iOS app. You can find some <a href="https://github.com/realm/realm-cocoa/tree/master/examples/ios/swift/Migration">more complex examples in the repo</a>.</p>
<p>If you&#8217;re working with an app for a different platform, then you can find instructions in the docs:</p>
<ul>
<li><a href="https://docs.mongodb.com/realm/sdk/node/examples/modify-an-object-schema/">Node.js</a></li>
<li><a href="https://docs.mongodb.com/realm/sdk/android/examples/modify-an-object-schema/">Android</a></li>
<li><a href="https://docs.mongodb.com/realm/sdk/android/examples/modify-an-object-schema/">iOS</a></li>
<li><a href="https://docs.mongodb.com/realm/sdk/dotnet/examples/modify-an-object-schema/">.NET</a></li>
<li><a href="https://docs.mongodb.com/realm/sdk/react-native/examples/modify-an-object-schema/">React Native</a></li>
</ul>
<p>If you&#8217;ve any questions about schema migration, or anything else related to Realm, then please post them to our <a href="https://www.mongodb.com/community/forums/c/realm-sdks/58">community forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/migrating-your-ios-apps-realm-schema-in-production/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Using Maps and Location Data in Your SwiftUI (+Realm) App</title>
		<link>/mongodb/realm/maps</link>
					<comments>/mongodb/realm/maps#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 12 Jul 2021 12:46:04 +0000</pubDate>
				<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mobile]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4620</guid>

					<description><![CDATA[Introduction Embedding Apple Maps and location functionality in SwiftUI apps used to be a bit of a pain. It required writing your own SwiftUI wrapper around UIKit code‚Äîsee these examples from the O-FISH app: Location helper Map views If you only need to support iOS14 and later, then you can forget most of that messy]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>Embedding Apple Maps and location functionality in SwiftUI apps used to be a bit of a pain. It required writing your own SwiftUI wrapper around UIKit code‚Äîsee these examples from the O-FISH app:</p>
<ul>
<li><a href="https://github.com/WildAid/o-fish-ios/blob/main/o-fish-ios/Helpers/LocationHelper.swift">Location helper</a></li>
<li><a href="https://github.com/WildAid/o-fish-ios/tree/main/o-fish-ios/Views/Components/Maps">Map views</a></li>
</ul>
<p>If you only need to support iOS14 and later, then you can <strong>forget most of that messy code <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f60a.png" alt="üòä" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong>. If you need to support iOS13‚Äîsorry, you need to go the O-FISH route!</p>
<p>iOS14 introduced the <a href="https://developer.apple.com/documentation/mapkit/map">Map</a> SwiftUI view (part of <a href="https://developer.apple.com/documentation/mapkit/map">Mapkit</a>) allowing you to embed maps directly into your SwiftUI apps without messy wrapper code.</p>
<p>This article shows you how to embed Apple Maps into your app views using Mapkit&#8217;s Map view. We&#8217;ll then look at how you can fetch the user&#8217;s current location‚Äîwith their permission, of course!</p>
<p>Finally, we&#8217;ll see how to store the location data in Realm in a format that lets MongoDB Realm sync it to MongoDB Atlas. Once in Atlas, you can add a <a href="https://docs.mongodb.com/manual/core/2dsphere/">geospatial index</a> and use <a href="https://www.mongodb.com/products/charts">MongoDB Charts</a> to plot the data on a map‚Äîwe&#8217;ll look at that too.</p>
<p>Most of the code snippets have been extracted from the <a href="https://github.com/realm/RChat">RChat app</a>. That app is a good place to see maps and location data in action. <a href="https://developer.mongodb.com/how-to/building-a-mobile-chat-app-using-realm-new-way/">Building a Mobile Chat App Using Realm ‚Äì The New and Easier Way</a> is a good place to learn more about the RChat app‚Äîincluding how to enable <a href="https://docs.mongodb.com/realm/sync/">MongoDB Realm Sync</a>.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://github.com/realm/realm-cocoa/releases">Realm-Cocoa 10.8.0</a>+ (may work with some 10.7.X versions)</li>
<li>iOS 14.5+ (<a href="https://developer.apple.com/documentation/mapkit/map">Mapkit</a> was introduced in iOS 14.0 and so most features should work with earlier iOS 14.X versions)</li>
<li><a href="https://developer.apple.com/xcode/">XCode12+</a></li>
</ul>
<h2>How to Add an Apple Map to Your SwiftUI App</h2>
<p>To begin, let&#8217;s create a simple view that displays a map, the coordinates of the center of that map, and the zoom level:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map1_7ea7ecbf15.gif" alt="Gif of scrolling around an embedded Apple Map and seeing the reported coordinates changing" /></p>
<p>With Mapkit and SwiftUI, this only takes a few lines of code:</p>
<pre><code class="swift">import MapKit
import SwiftUI

struct MyMapView: View {
    @State private var region: MKCoordinateRegion = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: MapDefaults.latitude, longitude: MapDefaults.longitude),
        span: MKCoordinateSpan(latitudeDelta: MapDefaults.zoom, longitudeDelta: MapDefaults.zoom))

    private enum MapDefaults {
        static let latitude = 45.872
        static let longitude = -1.248
        static let zoom = 0.5
    }

    var body: some View {
        VStack {
            Text("lat: \(region.center.latitude), long: \(region.center.longitude). Zoom: \(region.span.latitudeDelta)")
            .font(.caption)
            .padding()
            Map(coordinateRegion: $region,
                interactionModes: .all,
                showsUserLocation: true)
        }
    }
}
</code></pre>
<p>Note that <code>showsUserLocation</code> won&#8217;t work unless the user has already given the app permission to use their location‚Äîwe&#8217;ll get to that.</p>
<p><code>region</code> is initialized to a starting location, but it&#8217;s updated by the <code>Map</code> view as the user scrolls and zooms in and out.</p>
<h3>Adding Bells and Whistles to Your Maps (Pins at Least)</h3>
<p>Pins can be added to a map in the form of &#8220;annotations.&#8221; Let&#8217;s start with a single pin:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map2_3812086195.png" alt="Embedded Apple Map showing a red pin" /></p>
<p>Annotations are provided as an array of structs where each instance must contain the coordinates of the pin. The struct must also conform to the <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a> protocol:</p>
<pre><code class="swift">struct MyAnnotationItem: Identifiable {
    var coordinate: CLLocationCoordinate2D
    let id = UUID()
}
</code></pre>
<p>We can now create an array of <code>MyAnnotationItem</code> structs:</p>
<pre><code class="swift">let annotationItems = [
    MyAnnotationItem(coordinate: CLLocationCoordinate2D(
        latitude: MapDefaults.latitude,
        longitude: MapDefaults.longitude))]
</code></pre>
<p>We then pass <code>annotationItems</code> to the <code>MapView</code> and indicate that we want a <code>MapMarker</code> at the contained coordinates:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
        MapMarker(coordinate: item.coordinate)
    }
</code></pre>
<p>That gives us the result we wanted.</p>
<p>What if we want multiple pins? Not a problem. Just add more <code>MyAnnotationItem</code> instances to the array.</p>
<p>All of the pins will be the same default color. But, what if we want different colored pins? It&#8217;s simple to extend our code to produce this:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map3_669f6ec179.png" alt="Embedded Apple Map showing red, yellow, and plue pins at different locations" /></p>
<p>Firstly, we need to extend <code>MyAnnotationItem</code> to include an optional <code>color</code> and a <code>tint</code> that returns <code>color</code> if it&#8217;s been defined and &#8220;red&#8221; if not:</p>
<pre><code class="swift">struct MyAnnotationItem: Identifiable {
    var coordinate: CLLocationCoordinate2D
    var color: Color?
    var tint: Color { color ?? .red }
    let id = UUID()
}
</code></pre>
<p>In our sample data, we can now choose to provide a color for each annotation:</p>
<pre><code class="swift">let annotationItems = [
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: MapDefaults.latitude,
            longitude: MapDefaults.longitude)),
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: 45.8827419,
            longitude: -1.1932383),
        color: .yellow),
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: 45.915737,
            longitude: -1.3300991),
        color: .blue)
]
</code></pre>
<p>The <code>MapView</code> can then use the <code>tint</code>:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
    MapMarker(
        coordinate: item.coordinate,
        tint: item.tint)
}
</code></pre>
<p>If you get bored of pins, you can use <code>MapAnnotation</code> to use any view you like for your annotations:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
    MapAnnotation(coordinate: item.coordinate) {
        Image(systemName: "gamecontroller.fill")
            .foregroundColor(item.tint)
    }
}
</code></pre>
<p>This is the result:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map5_8509602cd7.png" alt="Apple Map showing red, yellow and blue game controller icons at different locations on the map" /></p>
<p>You could also include the name of the system image to use with each annotation.</p>
<p>This <a href="https://gist.github.com/am-MongoDB/3073226a84bf6deb6b2df7afcb21ca92">gist</a> contains the final code for the view.</p>
<h2>Finding Your User&#8217;s Location</h2>
<h3>Asking for Permission</h3>
<p>Apple is pretty vocal about respecting the privacy of their users, and so it shouldn&#8217;t be a shock that your app will have to request permission before being able to access a user&#8217;s location.</p>
<p>The first step is to add a key-value pair to your Xcode project to indicate that the app may request permission to access the user&#8217;s location, and what text should be displayed in the alert. You can add the pair to the &#8220;Info.plist&#8221; file:</p>
<pre><code>Privacy - Location When In Use Usage Description : We'll only use your location when you ask to include it in a message
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Info_plist_1500a15e11.png" alt="Screenshot from Xcode showing the key-value pair for requesting permission for the app to access the user's location" /></p>
<p>Once that setting has been added, the user should see an alert the first time that the app attempts to access their current location:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/request_access_to_location_08d1be66d1.png" alt="iPhone screenshot ‚Äì app is requesting permission to access the user's location" /></p>
<h3>Accessing Current Location</h3>
<p>While Mapkit has made maps simple and native in SwiftUI, the same can&#8217;t be said for location data.</p>
<p>You need to create a SwiftUI wrapper for Apple&#8217;s <a href="https://developer.apple.com/documentation/corelocation">Core Location</a> functionality. There&#8217;s not a lot of value in explaining this boilerplate code‚Äîjust copy this code from RChat&#8217;s <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Helpers/LocationHelper.swift">LocationHelper.swift</a> file, and paste it into your app:</p>
<pre><code class="swift">import CoreLocation

class LocationHelper: NSObject, ObservableObject {

    static let shared = LocationHelper()
    static let DefaultLocation = CLLocationCoordinate2D(latitude: 45.8827419, longitude: -1.1932383)

    static var currentLocation: CLLocationCoordinate2D {
        guard let location = shared.locationManager.location else {
            return DefaultLocation
        }
        return location.coordinate
    }

    private let locationManager = CLLocationManager()

    private override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }
}

extension LocationHelper: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { }

    public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }

    public func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        print("Location manager changed the status: \(status)")
    }
}
</code></pre>
<p>Once added, you can access the user&#8217;s location with this simple call:</p>
<pre><code class="swift">let location = LocationHelper.currentLocation
</code></pre>
<h3>Store Location Data in Your Realm Database</h3>
<h4>The Location Format Expected by MongoDB</h4>
<p>Realm doesn&#8217;t have a native type for a geographic location, and so it&#8217;s up to us how we choose to store it in a Realm Object. That is, unless we want to synchronize the data to MongoDB Atlas using MongoDB Realm Sync, and go on to use MongoDB&#8217;s geospatial functionality.</p>
<p>To make the best use of the location data in Atlas, we need to add a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes">geospatial index</a> to the field (which we‚Äôll see how to do soon.) That means storing the location in a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-data">supported format</a>. Not all options will work with Realm Sync (e.g., it&#8217;s not guaranteed that attributes will appear in the same order in your Realm Object and the synced Atlas document). The most robust approach is to use an array where the first element is longitude and the second is latitude:</p>
<pre><code class="json">location: [&lt;longitude&gt;, &lt;latitude&gt;]
</code></pre>
<h4>Your Realm Object</h4>
<p>The RChat app gives users the option to include their location in a chat message‚Äîthis means that we need to include the location in the <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Model/ChatMessage.swift">ChatMessage</a> Object:</p>
<pre><code class="swift">@objcMembers class ChatMessage: Object, ObjectKeyIdentifiable {
  ‚Ä¶
    let location = List&lt;Double&gt;()
  ‚Ä¶
    convenience init(author: String, text: String, image: Photo?, location: [Double] = []) {
        ...
    location.forEach { coord in
            self.location.append(coord)
      }
        ...
        }
    }
   ‚Ä¶.
}
</code></pre>
<p>The <code>location</code> array that&#8217;s passed to that initializer is formed like this:</p>
<pre><code class="swift">let location = LocationHelper.currentLocation
self.location = [location.longitude, location.latitude]
</code></pre>
<h2>Location Data in Your Backend MongoDB Realm App</h2>
<p>The easiest way to create your backend MongoDB Realm schema is to enable <a href="https://docs.mongodb.com/realm/sync/enable-development-mode/">Development Mode</a>‚Äîthat way, the schema is automatically generated from your Swift Realm Objects.</p>
<p>This is the generated <a href="https://github.com/realm/RChat/blob/main/RChat-Realm/RChat/services/mongodb-atlas/rules/RChat.ChatMessage.json">schema</a> for our &#8220;ChatMessage&#8221; collection:</p>
<pre><code class="swift">{
    "bsonType": "object",
    "properties": {
      "_id": {
        "bsonType": "string"
      },
      ...
      "location": {
        "bsonType": "array",
        "items": {
          "bsonType": "double"
        }
      }
    },
    "required": [
      "_id",
      ...
    ],
    "title": "ChatMessage"
}
</code></pre>
<p>This is a document that&#8217;s been created from a synced Realm <code>ChatMessage</code> object:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/atlas_document_d09cb3be1d.png" alt="Screen capture of an Atlas document, which includes an array named location" /></p>
<h3>Adding a Geospatial Index in Atlas</h3>
<p>Now that you have location data stored in Atlas, it would be nice to be able to work with it‚Äîe.g., running <a href="https://docs.mongodb.com/manual/geospatial-queries/">geospatial queries</a>. To enable this, you need to add a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes">geospatial index</a> to the <code>location</code> field.</p>
<p>From the Atlas UI, select the &#8220;Indexes&#8221; tab for your collection and click &#8220;CREATE INDEX&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/geo_index1_604fcbcd13.png" alt="Atlas screen capture of creating a new index" /></p>
<p>You should then configure a <code>2dsphere</code> index:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/geo_index2_8878556cfc.png" alt="Atlas screen capture of creating a new 2dsphere index" /></p>
<p>Most chat messages won&#8217;t include the user&#8217;s location and so I set the <code>sparse</code> option for efficiency.</p>
<p>Note that you&#8217;ll get an error message if your ChatMessage collection contains any documents where the value in the location attribute isn&#8217;t in a valid geospatial format.</p>
<p>Atlas will then build the index. This will be very quick, unless you already have a huge number of documents containing the location field. Once complete, you can move onto the next section.</p>
<h3>Plotting Your Location Data in MongoDB Charts</h3>
<p><a href="https://www.mongodb.com/products/charts">MongoDB Charts</a> is a simple way to visualize MongoDB data. You can access it through the same UI as Realm and Atlas. Just click on the &#8220;Charts&#8221; button:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/select_charts_9c8caa71c0.png" alt="Atlas screen capture of MongoDB Charts button" /></p>
<p>The first step is to click the &#8220;Add Data Source&#8221; button:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_data_source_4cbf88fea5.png" alt="Charts screen capture of adding a new data source" /></p>
<p>Select your Atlas cluster:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_select_cluster_b6d35ea00e.png" alt="Charts screen capture of adding Atlas cluster as a data source" /></p>
<p>Select the <code>RChat.ChatMessage</code> collection:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_select_collections_4f0dc0577d.png" alt="Charts screen capture of selecting the ChatMessage collection in the RChat database" /></p>
<p>Click ‚ÄúFinish.‚Äù You‚Äôll be taken to the default Dashboards view, which is empty for now. Click &#8220;Add Dashboard&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_dashboard1_b25eb3e015.png" alt="Charts screen capture of adding a new dashboard" /></p>
<p>In your new dashboard, click &#8220;ADD CHART&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_add_chart_f00639d1a1.png" alt="Charts screen capture of adding a new chart" /></p>
<p>Configure your chart as shown here by:<br />
&#8211; Setting the chart type to &#8220;Geospatial&#8221; and the sub-type to &#8220;Scatter.&#8221;<br />
&#8211; Dragging the &#8220;location&#8221; attribute to the coordinates box.<br />
&#8211; Dragging the &#8220;author&#8221; field to the &#8220;Color&#8221; box.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_create_chart_81189874ac.png" alt="Charts screen capture of configuring a new chart" /></p>
<p>Once you&#8217;ve created your chart, you can <a href="https://docs.mongodb.com/charts/saas/embed-chart-anon-auth/#std-label-anon-embedding-charts">embed it</a> in web apps, etc. That&#8217;s beyond the scope of this article, but check out the <a href="https://docs.mongodb.com/charts/saas/">MongoDB Charts docs</a> if you&#8217;re interested.</p>
<h2>Conclusion</h2>
<p>SwiftUI makes it easy to embed Apple Maps in your SwiftUI apps. As with most Apple frameworks, there are extra maps features available if you break out from SwiftUI, but I&#8217;d suggest that the simplicity of working with SwiftUI is enough incentive for you to avoid that unless you have a compelling reason.</p>
<p>Accessing location information from within SwiftUI still feels a bit of a hack, but in reality, you cut and paste the helper code once, and then you&#8217;re good to go.</p>
<p>By storing the location as a <code>[longitude, latitude]</code> array (<code>List</code>) in your Realm database, it&#8217;s simple to sync it with MongoDB Atlas. Once in Atlas, you have the full power of MongoDB&#8217;s geospatial functionality to work your location data.</p>
<p>If you have questions, please head to our <a href="https://community.mongodb.com/">developer community website</a> where the MongoDB engineers and the MongoDB community will help you build your next big idea with MongoDB.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm/maps/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Realm Partitioning Strategies</title>
		<link>/mongodb/realm-partitioning-strategies</link>
					<comments>/mongodb/realm-partitioning-strategies#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Tue, 04 May 2021 15:04:47 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[android]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mongodb]]></category>
		<guid isPermaLink="false">/?p=4611</guid>

					<description><![CDATA[I&#8217;ve just released a new article ‚Äì Realm Partitioning Strategies. Realm partitioning can be used to control what data is synced to each mobile device, ensuring that your app is efficient, performant and secure. This article will help you pick the right partitioning strategy for your app. MongoDB Realm Sync stores the superset of your]]></description>
										<content:encoded><![CDATA[<p>I&#8217;ve just released a <a href="https://developer.mongodb.com/how-to/realm-partitioning-strategies">new article ‚Äì Realm Partitioning Strategies</a>.</p>
<p>Realm partitioning can be used to control what data is synced to each mobile device, ensuring that your app is efficient, performant and secure. This article will help you pick the right partitioning strategy for your app.</p>
<p>MongoDB Realm Sync stores the superset of your application data in the cloud using MongoDB Atlas. The simplest strategy is that every instance of your mobile app contains the full database, but that quickly consumes a lot of space on the users&#8217; devices and makes the app slow to start while it syncs all of the data for the first time.<br />
Alternative strategies include partitioning by:</p>
<ul>
<li>User</li>
<li>Group/team/store</li>
<li>Chanel/room/topic</li>
<li>Geographic region</li>
<li>Bucket of time</li>
<li>Any combination of these</li>
</ul>
<p><a href="https://developer.mongodb.com/how-to/realm-partitioning-strategies">The article</a> discusses all of those strategies so that you adopt one, or craft a different strategy that&#8217;s customized to your app&#8217;s needs.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm-partitioning-strategies/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>New article on migrating Apple&#8217;s Scrumdinger tutorial app to Realm</title>
		<link>/mongodb/realm/new-article-on-migrating-apples-scrumdinger-tutorial-app-to-realm</link>
					<comments>/mongodb/realm/new-article-on-migrating-apples-scrumdinger-tutorial-app-to-realm#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 12 Apr 2021 08:53:15 +0000</pubDate>
				<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mobile]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4604</guid>

					<description><![CDATA[Apple published a great tutorial to teach developers how to create iOS apps using Swift and SwiftUI. I particularly like it because it doesn&#8217;t make any assumptions about existing UIKit experience, making it ideal for developers new to iOS. That tutorial is built around an app named &#8220;Scrumdinger,&#8221; which is designed to facilitate daily scrum]]></description>
										<content:encoded><![CDATA[
Apple published a great <a rel="noreferrer noopener" href="https://developer.apple.com/tutorials/app-dev-training" target="_blank">tutorial</a> to teach developers how to create iOS apps using Swift and SwiftUI. I particularly like it because it doesn&#8217;t make any assumptions about existing UIKit experience, making it ideal for developers new to iOS. That tutorial is built around an <a rel="noreferrer noopener" href="https://github.com/realm/Scrumdinger" target="_blank">app named &#8220;Scrumdinger,&#8221;</a> which is designed to facilitate daily <a rel="noreferrer noopener" href="https://en.wikipedia.org/wiki/Scrum_(software_development)" target="_blank">scrum</a> meetings.




<div style="height:36px" aria-hidden="true" class="wp-block-spacer"></div>




Apple&#8217;s Scrumdinger implementation saves the app data to a local file whenever the user minimizes the app, and loads it again when they open the app. It seemed an interesting exercise to modify Scrumdinger to use Realm rather than a flat file to persist the data. So. I wrote <a rel="noreferrer noopener" href="https://developer.mongodb.com/how-to/realm-swiftui-scrumdinger-migration" target="_blank">&#8220;Adapting Apple&#8217;s Scrumdinger SwiftUI Tutorial App to Use Realm&#8221;</a> to step through what changes were required to rebase Scrumdinger onto Realm.




<div style="height:37px" aria-hidden="true" class="wp-block-spacer"></div>




An immediate benefit of the move is that changes are now persisted immediately, so nothing is lost if the device or app crashes. It&#8217;s beyond the scope of this article, but now that the app data is stored in Realm, it would be straightforward to add enhancements such as:




<ul class="wp-block-list"><li>Search meeting minutes for a string.- Filter minutes by date or attendees.</li><li>Sync data so that the same user can see all of their data on multiple iOS (and optionally, Android) devices.</li><li>Use <a rel="noreferrer noopener" href="https://docs.mongodb.com/realm/sync/partitioning/" target="_blank">Realm Sync Partitions</a> to share scrum data between team members.</li><li>Sync the data to MongoDB Atlas so that it can be accessed by web apps or through a GraphQL API</li></ul>





]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm/new-article-on-migrating-apples-scrumdinger-tutorial-app-to-realm/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Building a Mobile Chat App Using Realm ‚Äì Integrating with Realm</title>
		<link>/mongodb/building-a-mobile-chat-app-using-realm-integrating-with-realm</link>
					<comments>/mongodb/building-a-mobile-chat-app-using-realm-integrating-with-realm#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 01 Feb 2021 17:12:00 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<guid isPermaLink="false">/?p=4583</guid>

					<description><![CDATA[I&#8217;ve just completed an article on how to integrate Realm and Realm Sync into an iOS chat app. It was timed to coincide with the GA of MongoDB Realm Sync. Realm is used for both persisting data on the iOS device and synchronizing the data between instances of the mobile app. The app is currently]]></description>
										<content:encoded><![CDATA[
I&#8217;ve just completed an <a href="https://developer.mongodb.com/how-to/building-a-mobile-chat-app-using-realm/" target="_blank" rel="noreferrer noopener">article on how to integrate Realm and Realm Sync into an iOS chat app</a>. It was timed to coincide with the GA of MongoDB Realm Sync.







<br>Realm is used for both persisting data on the iOS device and synchronizing the data between instances of the mobile app.<br>







The app is currently iOS-only (using SwiftUI), but we plan on building an Android version soon. One of the nice things about Realm Sync is that there&#8217;s no extra work needed to map between operating systems and languages when syncing data between iOS and Android.<br>







That data is also synced to MongoDB Atlas and so can be accessed from web or other kinds of apps too.<br>







The data stored and synced covers everything in the app:




<ul class="wp-block-list"><li>User profile</li><li>User presence</li><li>Lists of chatrooms and members</li><li>The messages themselves</li></ul>












You can download all of the code from the <a rel="noreferrer noopener" href="https://github.com/ClusterDB/RChat" target="_blank">GitHub</a> repo.



<br>



Checkout <a rel="noreferrer noopener" href="https://developer.mongodb.com/how-to/building-a-mobile-chat-app-using-realm" target="_blank">Building a Mobile Chat App Using Realm ‚Äì Integrating Realm into Your App</a> for all of the details.



<br>



Also, if you want to learn more about how the app was built and ask some questions then I&#8217;ll be speaking at a <a rel="noreferrer noopener" href="https://live.mongodb.com/events/details/mongodb-realm-global-community-presents-realm-sync-in-use-building-and-architecting-a-mobile-chat-app" target="_blank">virtual meetup on 17th Feb</a>.
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/building-a-mobile-chat-app-using-realm-integrating-with-realm/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
