<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>mongodb &#8211; Andrew Morgan on Databases</title>
	<atom:link href="/tag/mongodb/feed" rel="self" type="application/rss+xml" />
	<link>/</link>
	<description>Database technologies - especially around scalability and High Availability</description>
	<lastBuildDate>Mon, 14 Mar 2022 16:30:15 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Building a collaborative iOS Minesweeper game with Realm</title>
		<link>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm</link>
					<comments>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 14 Mar 2022 16:30:15 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[game]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4668</guid>

					<description><![CDATA[I wanted to build an app that we could use at events to demonstrate Realm Sync. It needed to be fun to interact with, and so a multiplayer game made sense. Tic-tac-toe is too simple to get excited about. I&#8217;m not a game developer and so Call Of Duty wasn&#8217;t an option. Then I remembered]]></description>
										<content:encoded><![CDATA[<p><a href="/wp-content/uploads/2022/03/ATF-720x720-1.png"><img fetchpriority="high" decoding="async" src="/wp-content/uploads/2022/03/ATF-720x720-1-300x300.png" alt="Realm-Sweeper. Writing a multiplayer iOS Minesweeper game using SwiftUI and Realm" width="300" height="300" class="alignright size-medium wp-image-4669" srcset="/wp-content/uploads/2022/03/ATF-720x720-1-300x300.png 300w, /wp-content/uploads/2022/03/ATF-720x720-1-150x150.png 150w, /wp-content/uploads/2022/03/ATF-720x720-1-144x144.png 144w, /wp-content/uploads/2022/03/ATF-720x720-1.png 720w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>I wanted to build an app that we could use at events to demonstrate <a href="https://www.mongodb.com/realm/mobile/sync">Realm Sync</a>. It needed to be fun to interact with, and so a multiplayer game made sense. Tic-tac-toe is too simple to get excited about. I&#8217;m not a game developer and so <em>Call Of Duty</em> wasn&#8217;t an option. Then I remembered Microsoft&#8217;s <a href="https://en.wikipedia.org/wiki/Minesweeper">Minesweeper</a>.</p>
<p>Minesweeper was a Windows fixture from 1990 until Windows 8 relegated it to the app store in 2012. It was a single-player game, but it struck me as something that could be a lot of fun to play with others. Some family beta-testing of my first version while waiting for a ferry proved that it did get people to interact with each other (even if most interactions involved shouting, &#8220;Which of you muppets clicked on that mine?!&#8221;).</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/IMG_1301_81fa444116.jpeg" alt="Family sat around a table, all playing the Realm-Sweeper game on their iPhones" /></p>
<p>You can download the back end and iOS apps from the <a href="https://github.com/realm/Realm-Sweeper">Realm-Sweeper repo</a>, and get it up and running in a few minutes if you want to play with it.</p>
<p>This article steps you through some of the key aspects of setting up the backend Realm app, as well as the iOS code. Hopefully, you&#8217;ll see how simple it is and try building something for yourself. If anyone&#8217;s looking for ideas, then <a href="https://en.wikipedia.org/wiki/Sokoban">Sokoban</a> could be interesting.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://github.com/realm/realm-swift/releases/tag/v10.23.0">Realm-Cocoa 10.20.1+</a></li>
<li>iOS 15+</li>
</ul>
<h2>The Minesweeper game</h2>
<p>The gameplay for Minesweeper is very simple.</p>
<p>You&#8217;re presented with a grid of gray tiles. You tap on a tile to expose what&#8217;s beneath. If you expose a mine, game over. If there isn&#8217;t a mine, then you&#8217;ll be rewarded with a hint as to how many mines are adjacent to that tile. If you deduce (or guess) that a tile is covering a mine, then you can plant a flag to record that.</p>
<p>You win the game when you correctly flag every mine and expose what&#8217;s behind every non-mined tile.</p>
<h3>What Realm-Sweeper adds</h3>
<p>Minesweeper wasn&#8217;t designed for touchscreen devices; you had to use a physical mouse. Realm-Sweeper brings the game into the 21st century by adding touch controls. Tap a tile to reveal what&#8217;s beneath; tap and hold to plant a flag.</p>
<p>Minesweeper was a single-player game. All people who sign into Realm-Sweeper with the same user ID get to collaborate on the same game in real time.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_sweeper_24ef46cef1.gif" alt="Animation of two iPhones. As a user taps a tile on one device, the change appears almost instantly on the other" /></p>
<p>You also get to configure the size of the grid and how many mines you&#8217;d like to hide.</p>
<h2>The data model</h2>
<p>I decided to go for a simple data model that would put Realm sync to the test.</p>
<p>Each game is a single document/object that contains meta data (score, number of rows/columns, etc.) together with the grid of tiles (the board):</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/schema_f791f6acf6.png" alt="Data model for the Game Class" /></p>
<p>This means that even a modestly sized grid (20&#215;20 tiles) results in a <code>Game</code> document/object with more than 2,000 attributes.</p>
<p>Every time you tap on a tile, the <code>Game</code> object has to be synced with all other players. Those players are also tapping on tiles, and those changes have to be synced too. If you tap on a tile which isn&#8217;t adjacent to any mines, then the app will recursively ripple through exposing similar, connected tiles. That&#8217;s a lot of near-simultaneous changes being made to the same object from different devices—a great test of Realm&#8217;s automatic conflict resolution!</p>
<h2>The backend Realm app</h2>
<p>If you don&#8217;t want to set this up yourself, simply follow the <a href="https://github.com/realm/Realm-Sweeper/tree/main/Realm">instructions from the repo</a> to import the app.</p>
<p>If you opt to build the backend app yourself, there are only two things to configure once you create the empty Realm app:</p>
<ol>
<li><a href="https://docs.mongodb.com/realm/authentication/email-password/#:~:text=Summary-,Overview,email%20addresses%20are%20case%2Dsensitive.">Enable email/password authentication</a>. I kept it simple by opting to auto-confirm new users and sticking with the default password-reset function (which does nothing).</li>
<li><a href="https://docs.mongodb.com/realm/sync/configure/enable-sync/">Enable partitioned Realm sync</a>. Set the partition key to <code>partition</code> and enable developer mode (so that the schema will be created automatically when the iOS app syncs for the first time).</li>
</ol>
<p>The <code>partition</code> field will be set to the username—allowing anyone who connects as that user to sync all of their games.</p>
<p>You can also add sync rules to ensure that a user can only sync their own games (in case someone hacks the mobile app). I always prefer using Realm functions for permissions. You can add this for both the read and write rules:</p>
<pre><code class="json">{
  "%%true": {
    "%function": {
      "arguments": [
        "%%partition"
      ],
      "name": "canAccessPartition"
    }
  }
}
</code></pre>
<p>The <code>canAccessPartition</code> function is:</p>
<pre><code class="js">exports = function(partition) {
  const user = context.user.data.email;
  return partition === user;
};
</code></pre>
<h2>The iOS app</h2>
<p>I&#8217;d suggest starting by downloading, configuring, and running the app—just follow the <a href="https://github.com/realm/Realm-Sweeper/tree/main/iOS">instructions from the repo</a>. That way, you can get a feel for how it works.</p>
<p>This isn&#8217;t intended to be a full tutorial covering every line of code in the app. Instead, I&#8217;ll point out some key components.</p>
<p>As always with Realm and MongoDB, it all starts with the data…</p>
<h3>Model</h3>
<p>There&#8217;s a single top-level Realm Object—<code>Game</code>:</p>
<pre><code class="swift">class Game: Object, ObjectKeyIdentifiable {
    @Persisted(primaryKey: true) var _id: ObjectId
    @Persisted var numRows = 0
    @Persisted var numCols = 0
    @Persisted var score = 0
    @Persisted var startTime: Date? = Date()
    @Persisted var latestMoveTime: Date?
    @Persisted var secondsTakenToComplete: Int?
    @Persisted var board: Board?
    @Persisted var gameStatus = GameStatus.notStarted
    @Persisted var winningTimeInSeconds: Int?
    …
}
</code></pre>
<p>Most of the fields are pretty obvious. The most interesting is <code>board</code>, which contains the grid of tiles:</p>
<pre><code class="swift">class Board: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var rows = List&lt;Row&gt;()
    @Persisted var startingNumberOfMines = 0
    ... 
}
</code></pre>
<p><code>row</code> is a list of <code>Cells</code>:</p>
<pre><code class="swift">class Row: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var cells = List&lt;Cell&gt;()
    ...
}

class Cell: EmbeddedObject, ObjectKeyIdentifiable {
    @Persisted var isMine = false
    @Persisted var numMineNeigbours = 0
    @Persisted var isExposed = false
    @Persisted var isFlagged = false
    @Persisted var hasExploded = false
    ...
}
</code></pre>
<p>The model is also where the ~~business~~ game logic is implemented. This means that the views can focus on the UI. For example, <code>Game</code> includes a computed variable to check whether the game has been solved:</p>
<pre><code class="swift">var hasWon: Bool {
    guard let board = board else { return false }
    if board.remainingMines != 0 { return false }

    var result = true

    board.rows.forEach() { row in
        row.cells.forEach() { cell in
            if !cell.isExposed &amp;&amp; !cell.isFlagged {
                result = false
                return
            }
        }
        if !result { return }
    }
    return result
}
</code></pre>
<h3>Views</h3>
<p>As with any SwiftUI app, the UI is built up of a hierarchy of many views.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/views_aaac46f078.png" alt="Screen capture from Xcode showing the hierarchy of views making up the RealmSweeper UI" /></p>
<p>Here&#8217;s a quick summary of the <a href="https://github.com/realm/Realm-Sweeper/tree/main/iOS/RealmSweeper/Views">views</a> that make up Real-Sweeper:</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/ContentView.swift"><code>ContentView</code></a></strong> is the top-level view. When the app first runs, it will show the <code>LoginView</code>. Once the user has logged in, it shows <code>GameListView</code> instead. It&#8217;s here that we set the Realm Sync partition (to be the <code>username</code> of the user that&#8217;s just logged in):</p>
<pre><code class="swift">if username == "" {
    LoginView(username: $username)
} else {
    GameListView()
        .environment(\.realmConfiguration, realmApp.currentUser!.configuration(partitionValue: username))
        .navigationBarItems(leading: realmApp.currentUser != nil ? LogoutButton(username: $username) : nil)
}
</code></pre>
<p><code>ContentView</code> also includes the <code>LogoutButton</code> view.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Users/LoginView.swift"><code>LoginView</code></a></strong> allows the user to provide a username and password:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Login_View_034d3f058f.png" alt="Screen capture of the login view. Fields to enter username and password. Checkbox to indicate that you're registering a new user. Button to login," /></p>
<p>Those credentials are then used to register or log into the backend Realm app:</p>
<pre><code class="swift">func userAction() {
    Task {
        do {
            if newUser {
                try await realmApp.emailPasswordAuth.registerUser(
                    email: email, password: password)
            }
            let _ = try await realmApp.login(
                    credentials: .emailPassword(email: email, password: password))
            username = email
        } catch {
            errorMessage = error.localizedDescription
        }
    }
}
</code></pre>
<p><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game%20List/GameListView.swift"><strong><code>GameListView</code></strong></a> reads the list of this user&#8217;s existing games.</p>
<pre><code class="swift">@ObservedResults(Game.self, 
    sortDescriptor: SortDescriptor(keyPath: "startTime", ascending: false)) var games
</code></pre>
<p>It displays each of the games within a <code>GameSummaryView</code>. If you tap one of the games, then you jump to a <code>GameView</code> for that game:</p>
<pre><code class="swift">NavigationLink(destination: GameView(game: game)) {
    GameSummaryView(game: game)
}
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_List_View_22711c2b4a.png" alt="GameListView, Screen capture of a list of games, together with buttons to logout, set settings, or create a new game" /></p>
<p>Tap the settings button and you&#8217;re sent to <code>SettingsView</code>.</p>
<p>Tap the &#8220;New Game&#8221; button and a new <code>Game</code> object is created and then stored in Realm by appending it to the <code>games</code> live query:</p>
<pre><code class="swift">private func createGame() {
    numMines = min(numMines, numRows * numColumns)
    game = Game(rows: numRows, cols: numColumns, mines: numMines)
    if let game = game {
        $games.append(game)
    }
    startGame  = true
}
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/SettingsView.swift"><code>SettingsView</code></a></strong> lets the user choose the number of tiles and mines to use:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Settings_View_39aa24c7ce.png" alt="SettingsView. Steppers to set the number of rows, columns, and mines" /></p>
<p>If the user uses multiple devices to play the game (e.g., an iPhone and an iPad), then they may want different-sized boards (taking advantage of the extra screen space on the iPad). Because of that, the view uses the device&#8217;s <code>UserDefaults</code> to locally persist the settings rather than storing them in a synced realm:</p>
<pre><code class="swift">@AppStorage("numRows") var numRows = 10
@AppStorage("numColumns") var numColumns = 10
@AppStorage("numMines") var numMines = 15
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game%20List/GameSummaryView.swift"><code>GameSummaryView</code></a></strong> displays a summary of one of the user&#8217;s current or past games.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_Summary_View_e80a138236.png" alt="GameSummaryView. Screen capture of view containing the start and completion times + emoji for the status of the game" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game/GameView.swift"><code>GameView</code></a></strong> shows the latest stats for the current game at the top of the screen:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Game_Status_5ee8b8b6e0.png" alt="GameStatusView. Screen capture showing remaining mines, status of the game (smiling emoji) and elapsed time" /></p>
<p>It uses the <code>LEDCounter</code> and <code>StatusButton</code> views for the summary.</p>
<p>Below the summary, it displays the <code>BoardView</code> for the game.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Control%20Box/Counters/LEDCounter.swift"><code>LEDCounter</code></a></strong> displays the provided number as three digits using a retro LED font:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Counter_View_d7b73c42ce.png" alt="CounterView – 3 red LED numbers" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Control%20Box/StatusButton.swift"><code>StatusButton</code></a></strong> uses a <code>ZStack</code> to display the symbol for the game&#8217;s status on top of a tile image:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Status_Button_8975894d39.png" alt="StatusButton. Smiling emoji in front of a gray tile" /></p>
<p>The view uses SwiftUI&#8217;s <a href="https://www.hackingwithswift.com/quick-start/swiftui/how-to-provide-relative-sizes-using-geometryreader"><code>GeometryReader</code></a> function to discover how much space is available so that it can select an appropriate font size for the symbol:</p>
<pre><code class="swift">GeometryReader { geo in
    Text(status)
        .font(.system(size: geo.size.height * 0.7))
}
</code></pre>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Game/BoardView.swift"><code>BoardView</code></a></strong> displays the game&#8217;s grid of tiles:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Board_View_703d6386db.png" alt="BoardView. A grid of tiles. Some tiles have been removed, revealing colored numbers. One tile contains a red flag" /></p>
<p>Each of the tiles is represented by a <code>CellView</code> view.</p>
<p>When a tile is tapped, this view exposes its contents:</p>
<pre><code class="swift">.onTapGesture() {
    expose(row: row, col: col)
}
</code></pre>
<p>On a tap-and-hold, a flag is dropped:</p>
<pre><code class="swift">.onLongPressGesture(minimumDuration: 0.1) {
    flag(row: row, col: col)
}
</code></pre>
<p>When my family tested the first version of the app, they were frustrated that they couldn&#8217;t tell whether they&#8217;d held long enough for the flag to be dropped. This was an easy mistake to make as their finger was hiding the tile at the time—an example of where testing with a mouse and simulator wasn&#8217;t a substitute for using real devices. It was especially frustrating as getting it wrong meant that you revealed a mine and immediately lost the game. Fortunately, this is easy to fix using iOS&#8217;s haptic feedback:</p>
<pre><code class="swift">func hapticFeedback(_ isSuccess: Bool) {
    let generator = UINotificationFeedbackGenerator()
    generator.notificationOccurred(isSuccess ? .success : .error)
}
</code></pre>
<p>You now feel a buzz when the flag has been dropped.</p>
<p><strong><a href="CellView"><code>CellView</code></a></strong> displays an individual tile:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Cell_View_6ee46c6103.png" alt="CellView. Tile containing a crossed out red flag" /></p>
<p>What&#8217;s displayed depends on the contents of the <code>Cell</code> and the state of the game. It uses four further views to display different types of tile: <code>FlagView</code>, <code>MineCountView</code>, <code>MineView</code>, and <code>TileView</code>.</p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/FlagView.swift"><code>FlagView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Flag_View_fd57e245f3.png" alt="FlagView. 2 Tiles, both containing a flag, one shows the  flag crossed out" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/MineCountView.swift"><code>MineCountView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Mine_Count_View_e8392ff46d.png" alt="MineCountView, 6 gray tiles. One is empty the others containing numbers 1 through 5, each in a different color" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/MineView.swift"><code>MineView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Mine_View_18eaaf517b.png" alt="MineView. Two tiles containing mines, one with a gray background, one with a red background" /></p>
<p><strong><a href="https://github.com/realm/Realm-Sweeper/blob/main/iOS/RealmSweeper/Views/Tiles/TileView.swift"><code>TileView</code></a></strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Tile_View_1a01815c26.png" alt="TileView. A single gray tile" /></p>
<h2>Conclusion</h2>
<p>Realm-Sweeper gives a real feel for how quickly Realm is able to synchronize data over the internet.</p>
<p>I intentionally avoided optimizing how I updated the game data in Realm. When you see a single click exposing dozens of tiles, each cell change is an update to the <code>Game</code> object that needs to be synced.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/sync_526ade2926.gif" alt="GIF showing changes in one game board appearing in near-realtime in the game board on a different device" /></p>
<p>Note that both instances of the game are running in iPhone simulators on an overworked Macbook in England. The Realm backend app is running in the US—that&#8217;s a 12,000 km/7,500 mile round trip for each sync.</p>
<p>I took this approach as I wanted to demonstrate the performance of Realm synchronization. If an app like this became super-popular with millions of users, then it would put a lot of extra strain on the backend Realm app.</p>
<p>An obvious optimization would be to condense all of the tile changes from a single tap into a single write to the Realm object. If you&#8217;re interested in trying that out, just fork the <a href="https://github.com/realm/Realm-Sweeper">repo</a> and make the changes. If you do implement the optimization, then please create a pull request. (I&#8217;d probably add it as an option within the settings so that the &#8220;slow&#8221; mode is still an option.)</p>
<p>Got questions? Ask them in our <a href="https://www.mongodb.com/community/forums/c/realm/realm-sync/111">Community forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/building-a-collaborative-ios-minesweeper-game-with-realm/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Using Realm Flexible Sync in Your App—an iOS Tutorial</title>
		<link>/mongodb/using-realm-flexible-sync-in-your-app-an-ios-tutorial</link>
					<comments>/mongodb/using-realm-flexible-sync-in-your-app-an-ios-tutorial#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Fri, 25 Feb 2022 12:24:10 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4664</guid>

					<description><![CDATA[Introduction We recently announced the release of the Realm Flexible Sync preview—an opportunity for developers to take it for a spin and give us feedback. That article provided an overview of the benefits of flexible sync and how it works. TL;DR: You typically don&#8217;t want to sync the entire backend database to every device—whether for]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>We recently announced the <a href="https://www.mongodb.com/developer/article/realm-flexible-sync/">release of the Realm Flexible Sync preview</a>—an opportunity for developers to take it for a spin and give us feedback. That article provided an overview of the benefits of flexible sync and how it works. TL;DR: You typically don&#8217;t want to sync the entire backend database to every device—whether for capacity or security concerns. Realm Flexible Sync lets the developer provide queries to control exactly what the mobile app asks to sync, together with backend rules to ensure users can only access the data that they&#8217;re entitled to.</p>
<p>This post builds on that introduction by showing how to add flexible sync to the RChat mobile app. I&#8217;ll show how to configure the Realm backend app, and then what code needs adding to the mobile app.</p>
<p>Everything you see in this tutorial can be found in the <a href="https://github.com/realm/RChat/tree/flex-sync">flex-sync branch of the RChat repo</a>.</p>
<h2>Prerequisites</h2>
<ul>
<li>Xcode 13.2+</li>
<li>iOS 15+</li>
<li><a href="https://github.com/realm/realm-swift/releases">Realm-Swift 10.22.0+</a></li>
<li>MongoDB 5.0+</li>
</ul>
<h2>The RChat App</h2>
<p>RChat is a messaging app. Users can add other users to a chat room and then share messages, images, and location with each other.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/chat_realm_flex_sync_468d197c99.gif" alt="Screen capture video of running the RCha App on 2 different iOS simulators. Two users join a chat room and send messages to each other" /></p>
<p>All of the user and chat message data is shared between instances of the app via Realm Sync.</p>
<p>There&#8217;s a common Realm backend app. There are frontend apps for iOS and Android. This post focuses on the backend and the iOS app.</p>
<h2>Configuring the Realm Backend App</h2>
<p>The backend app contains a lot of functionality that isn&#8217;t connected to the sync functionality, and so I won&#8217;t cover that here. If you&#8217;re interested, then check out the <a href="https://www.mongodb.com/developer/how-to/realm-swiftui-ios-chat-app/">original RChat series</a>.</p>
<p>As a starting point, you can install the app. I&#8217;ll then explain the parts connected to Realm Sync.</p>
<h3>Import the Backend Realm App</h3>
<ol>
<li>If you don&#8217;t already have one, <a href="https://cloud.mongodb.com/">create a MongoDB Atlas Cluster</a>, keeping the default name of Cluster0. The Atlas cluster must be running MongoDB 5.0 or later.</li>
<li>Install the <a href="https://docs.mongodb.com/realm/deploy/realm-cli-reference">Realm CLI</a> and <a href="https://docs.atlas.mongodb.com/configure-api-access#programmatic-api-keys">create an API key pair</a>.</li>
<li>Download the repo and install the Realm app:</li>
</ol>
<pre><code class="bash">git clone https://github.com/ClusterDB/RChat.git
git checkout flex-sync
cd RChat/RChat-Realm/RChat
realm-cli login --api-key &lt;your new public key&gt; --private-api-key &lt;your new private key&gt;
realm-cli import # Then answer prompts, naming the app RChat

</code></pre>
<ol>
<li>From the Atlas UI, click on the Realm logo and you will see the RChat app. Open it and copy the App Id. You&#8217;ll need to use this before building the iOS app.</li>
</ol>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/copy_realm_app_id_b2d9b27ddc.png" alt="Screen capture of how to copy the Realm App ID in the Realm UI" /></p>
<h3>How Flexible Sync is Enabled in the Back End</h3>
<h4>Schema</h4>
<p>The schema represents how the data will be stored in MongoDB Atlas **and*- what the Swift (and Kotlin) model classes must contain.</p>
<p>Each collection/class requires a schema. If you enable Realm&#8217;s &#8220;Developer Mode&#8221; option, then Realm will automatically define the schema based on your Swift or Kotlin model classes. In this case, your imported Realm <code>App</code> includes the schemas, and so developer mode isn&#8217;t needed. You can view the schemas by browsing to the &#8220;Schema&#8221; section in the <a href="https://cloud.mongodb.com/">Realm UI</a>:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/schemas_in_realm_ui_4032fe478c.png" alt="Screen capture of schema section of the Realm UI" /></p>
<p>You can find more details about the schema/model in <a href="https://www.mongodb.com/developer/how-to/realm-swiftui-ios-chat-app/">Building a Mobile Chat App Using Realm – Data Architecture</a>, but note that for flexible sync (as opposed to the original partition-based sync), the <code>partition</code> field has been removed.</p>
<p>We&#8217;re interested in the schema for three collections/model-classes:</p>
<p><strong>User:</strong></p>
<pre><code class="json">{
  "bsonType": "object",
  "properties": {
    "_id": {
      "bsonType": "string"
    },
    "conversations": {
      "bsonType": "array",
      "items": {
        "bsonType": "object",
        "properties": {
          "displayName": {
            "bsonType": "string"
          },
          "id": {
            "bsonType": "string"
          },
          "members": {
            "bsonType": "array",
            "items": {
              "bsonType": "object",
              "properties": {
                "membershipStatus": {
                  "bsonType": "string"
                },
                "userName": {
                  "bsonType": "string"
                }
              },
              "required": [
                "membershipStatus",
                "userName"
              ],
              "title": "Member"
            }
          },
          "unreadCount": {
            "bsonType": "long"
          }
        },
        "required": [
          "unreadCount",
          "id",
          "displayName"
        ],
        "title": "Conversation"
      }
    },
    "lastSeenAt": {
      "bsonType": "date"
    },
    "presence": {
      "bsonType": "string"
    },
    "userName": {
      "bsonType": "string"
    },
    "userPreferences": {
      "bsonType": "object",
      "properties": {
        "avatarImage": {
          "bsonType": "object",
          "properties": {
            "_id": {
              "bsonType": "string"
            },
            "date": {
              "bsonType": "date"
            },
            "picture": {
              "bsonType": "binData"
            },
            "thumbNail": {
              "bsonType": "binData"
            }
          },
          "required": [
            "_id",
            "date"
          ],
          "title": "Photo"
        },
        "displayName": {
          "bsonType": "string"
        }
      },
      "required": [],
      "title": "UserPreferences"
    }
  },
  "required": [
    "_id",
    "userName",
    "presence"
  ],
  "title": "User"
}
</code></pre>
<p><code>User</code> documents/objects represent users of the app.</p>
<p><strong>Chatster:</strong></p>
<pre><code class="json">{
  "bsonType": "object",
  "properties": {
    "_id": {
      "bsonType": "string"
    },
    "avatarImage": {
      "bsonType": "object",
      "properties": {
        "_id": {
          "bsonType": "string"
        },
        "date": {
          "bsonType": "date"
        },
        "picture": {
          "bsonType": "binData"
        },
        "thumbNail": {
          "bsonType": "binData"
        }
      },
      "required": [
        "_id",
        "date"
      ],
      "title": "Photo"
    },
    "displayName": {
      "bsonType": "string"
    },
    "lastSeenAt": {
      "bsonType": "date"
    },
    "presence": {
      "bsonType": "string"
    },
    "userName": {
      "bsonType": "string"
    }
  },
  "required": [
    "_id",
    "presence",
    "userName"
  ],
  "title": "Chatster"
}
</code></pre>
<p><code>Chatster</code> documents/objects represent a read-only subset of instances of <code>User</code> documents. <code>Chatster</code> is needed because there&#8217;s a subset of <code>User</code> data that we want to make accessible to all users. E.g., I want everyone to be able to see my username, presence status, and avatar image, but I don&#8217;t want them to see which chat rooms I&#8217;m a member of.</p>
<p>Realm Sync lets you control which users can sync which documents, but it doesn&#8217;t let you sync just a subset of a document&#8217;s fields. That&#8217;s why <code>Chatster</code> is needed. I&#8217;m looking forward to when Realm Sync permissions allow me to control access on a per-field (rather than per-document/class) basis. At that point, I can remove <code>Chatster</code> from the app.</p>
<p><strong>ChatMessage:</strong></p>
<pre><code class="json">{
  "bsonType": "object",
  "properties": {
    "_id": {
      "bsonType": "string"
    },
    "author": {
      "bsonType": "string"
    },
    "authorID": {
      "bsonType": "string"
    },
    "conversationID": {
      "bsonType": "string"
    },
    "image": {
      "bsonType": "object",
      "properties": {
        "_id": {
          "bsonType": "string"
        },
        "date": {
          "bsonType": "date"
        },
        "picture": {
          "bsonType": "binData"
        },
        "thumbNail": {
          "bsonType": "binData"
        }
      },
      "required": [
        "_id",
        "date"
      ],
      "title": "Photo"
    },
    "location": {
      "bsonType": "array",
      "items": {
        "bsonType": "double"
      }
    },
    "text": {
      "bsonType": "string"
    },
    "timestamp": {
      "bsonType": "date"
    }
  },
  "required": [
    "_id",
    "authorID",
    "conversationID",
    "text",
    "timestamp"
  ],
  "title": "ChatMessage"
}
</code></pre>
<p>There&#8217;s a <code>ChatMessage</code> document object for every message sent to any chat room.</p>
<h4>Flexible Sync Configuration</h4>
<p>You can view and edit the sync configuration by browsing to the &#8220;Sync&#8221; section of the Realm UI:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/configure_flex_sync_9b3221e283.png" alt="Enabling Realm Flexible Sync in the Realm UI" /></p>
<p>For this deployment, I&#8217;ve selected the Atlas cluster to use. <strong>That cluster must be running MongoDB 5.0 or later</strong>. At the time of writing, MongoDB 5.0 isn&#8217;t available for shared clusters (including free-tier M0 instances)—that&#8217;s expected to change very soon, possibly by the time that you&#8217;re reading this.</p>
<p>You must specify which fields the mobile app can use in its sync filter queries. Without this, you can&#8217;t refer to those fields in your sync queries or permissions. You are currently limited to 10 fields.</p>
<p>Scrolling down, you can see the sync permissions:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/sync_permission_f780c57241.png" alt="Screenshot of a JSON document representing sync permissions in the Realm UI" /></p>
<p>The UI has flattened the permissions JSON document; here&#8217;s a version that&#8217;s easier to read:</p>
<pre><code class="json">{
   "rules": {
       "User": [
           {
               "name": "anyone",
               "applyWhen": {},
               "read": {
                   "_id": "%%user.id"
               },
               "write": {
                   "_id": "%%user.id"
               }
           }
       ],
       "Chatster": [
           {
               "name": "anyone",
               "applyWhen": {},
               "read": true,
               "write": false
           }
       ],
       "ChatMessage": [
           {
               "name": "anyone",
               "applyWhen": {},
               "read": true,
               "write": {
                   "authorID": "%%user.id"
               }
           }
       ]
   },
   "defaultRoles": [
       {
           "name": "all",
           "applyWhen": {},
           "read": {},
           "write": {}
       }
   ]
}
</code></pre>
<p>The <code>rules</code> component contains a sub-document for each of our collections. Each of those sub-documents contain an array of roles. Each role contains:</p>
<ul>
<li>The <code>name</code> of the role, this should be something that helps other developers understand the purpose of the role (e.g., &#8220;admin,&#8221; &#8220;owner,&#8221; &#8220;guest&#8221;).</li>
<li><code>applyWhen</code>, which defines whether the requesting user matches the role or not. Each of our collections have a single role, and so <code>applyWhen</code> is set to <code>{}</code>, which always evaluates to true.</li>
<li>A read rule—how to decide whether this user can view a given document. This is where our three collections impose different rules:
<ul>
<li>A user can read and write to their own <code>User</code> object. No one else can read or write to it.</li>
<li>Anyone can read any <code>Chatster</code> document, but no one can write to them. Note that these documents are maintained by database triggers to keep them consistent with their associated <code>User</code> document.</li>
<li>The author of a <code>ChatMessage</code> is allowed to write to it. Anyone can read any <code>ChatMessage</code>. Ideally, we&#8217;d restrict it to just members of the chat room, but permissions don&#8217;t currently support arrays—this is another feature that I&#8217;m keen to see added.</li>
</ul>
</li>
</ul>
<h2>Adding Realm Flexible Sync to the iOS App</h2>
<p>As with the back end, the iOS app is too big to cover in its entirety in this post. I&#8217;ll explain how to build and run the app and then go through the components relevant to Realm Flexible Sync.</p>
<h3>Configure, Build, and Run the RChat iOS App</h3>
<p>You&#8217;ve already downloaded the repo containing the iOS app, but you need to change directory before opening and running the app:</p>
<pre><code class="bash">cd ../../RChat-iOS
pod install
open RChat.xcodeproj
</code></pre>
<p>Update <code>RChatApp.swift</code> with your Realm App Id (you copied that from the Realm UI when configuring your backend Realm app). In Xcode, select your device or simulator before building and running the app (⌘R). Select a second device or simulator and run the app a second time (⌘R).</p>
<p>On each device, provide a username and password and select the &#8220;Register new user&#8221; checkbox:<br />
<img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/register_rchat_user_f04514f5bf.png" alt="iOS screenshot of registering a new user through the RChat app" /></p>
<p>Once registered and logged in on both devices, you can create a new chat room, invite your second user, and start sharing messages and photos. To share location, you first need to enable it in the app&#8217;s settings.</p>
<h3>Key Pieces of the iOS App Code</h3>
<h4>The Model</h4>
<p>You&#8217;ve seen the schemas that were defined for the &#8220;User,&#8221; &#8220;Chatster,&#8221; and &#8220;ChatMessage&#8221; collections in the back end Realm app. Each of those collections has an associated Realm <code>Object</code> class in the iOS app. Sub-documents map to embedded objects that conform to <code>RealmEmbeddedObject</code>:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/R_Chat_Flex_Sync_Class_Model_496e297d36.png" alt="UML diagram showing the User, Chatster, and ChatMessage classes—together with their embedded classes" /></p>
<p>Let&#8217;s take a close look at each of these classes:</p>
<p><strong>User Class</strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/User_Flex_Sync_Class_Model_78340465be.png" alt="UML diagram showing the User class—together with its embedded classes" /></p>
<pre><code class="swift">class User: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id = UUID().uuidString
   @Persisted var userName = ""
   @Persisted var userPreferences: UserPreferences?
   @Persisted var lastSeenAt: Date?
   @Persisted var conversations = List&lt;Conversation&gt;()
   @Persisted var presence = "On-Line"
}

class UserPreferences: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var displayName: String?
   @Persisted var avatarImage: Photo?
}

class Photo: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var _id = UUID().uuidString
   @Persisted var thumbNail: Data?
   @Persisted var picture: Data?
   @Persisted var date = Date()
}

class Conversation: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var id = UUID().uuidString
   @Persisted var displayName = ""
   @Persisted var unreadCount = 0
   @Persisted var members = List&lt;Member&gt;()
}

class Member: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var userName = ""
   @Persisted var membershipStatus = "User added, but invite pending"
}
</code></pre>
<p><strong>Chatster Class</strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Chatster_Flex_Sync_Class_Model_7f5cf9bc28.png" alt="UML diagram showing the Chatster class—together with its embedded class" /></p>
<pre><code class="swift">class Chatster: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id = UUID().uuidString // This will match the _id of the associated User
   @Persisted var userName = ""
   @Persisted var displayName: String?
   @Persisted var avatarImage: Photo?
   @Persisted var lastSeenAt: Date?
   @Persisted var presence = "Off-Line"
}

class Photo: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var _id = UUID().uuidString
   @Persisted var thumbNail: Data?
   @Persisted var picture: Data?
   @Persisted var date = Date()
}
</code></pre>
<p><strong>ChatMessage Class</strong></p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Chat_Message_Flex_Sync_Class_Model_17_25_06_c33478d3e9.png" alt="UML diagram showing the ChatMessage class—together with its embedded class" /></p>
<pre><code class="swift">class ChatMessage: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id = UUID().uuidString
   @Persisted var conversationID = ""
   @Persisted var author: String? // username
   @Persisted var authorID: String
   @Persisted var text = ""
   @Persisted var image: Photo?
   @Persisted var location = List&lt;Double&gt;()
   @Persisted var timestamp = Date()
}

class Photo: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var _id = UUID().uuidString
   @Persisted var thumbNail: Data?
   @Persisted var picture: Data?
   @Persisted var date = Date()
}
</code></pre>
<h4>Accessing Synced Realm Data</h4>
<p>Any iOS app that wants to sync Realm data needs to create a Realm <code>App</code> instance, providing the Realm App ID so that the Realm SDK can connect to the backend Realm app:</p>
<pre><code class="swift">let app = RealmSwift.App(id: "rchat-xxxxx") // TODO: Set the Realm application ID
</code></pre>
<p>When a SwiftUI view (in this case, <code>LoggedInView</code>) needs to access synced data, the parent view must flag that flexible sync will be used. It does this by passing the Realm configuration through the SwiftUI environment:</p>
<pre><code class="swift">LoggedInView(userID: $userID)
   .environment(\.realmConfiguration,
               app.currentUser!.flexibleSyncConfiguration())
</code></pre>
<p><code>LoggedInView</code> can then access two variables from the SwiftUI environment:</p>
<pre><code class="swift">struct LoggedInView: View {
   ...
   @Environment(\.realm) var realm
   @ObservedResults(User.self) var users
</code></pre>
<p>The users variable is a live query containing all synced <code>User</code> objects in the Realm. But at this point, no <code>User</code> documents have been synced because we haven&#8217;t subscribed to anything.</p>
<p>That&#8217;s easy to fix. We create a new function (<code>setSubscription</code>) that&#8217;s invoked when the view is opened:</p>
<pre><code class="swift">struct LoggedInView: View {
   ...
   @Binding var userID: String?
   ...
   var body: some View {
       ZStack {
           ...
       }
       .onAppear(perform: setSubscription)
   }

   private func setSubscription() {
       let subscriptions = realm.subscriptions
       subscriptions.write {
           if let currentSubscription = subscriptions.first(named: "user_id") {
               print("Replacing subscription for user_id")
               currentSubscription.update(toType: User.self) { user in
                   user._id == userID!
               }
           } else {
               print("Appending subscription for user_id")
               subscriptions.append(QuerySubscription&lt;User&gt;(name: "user_id") { user in
                   user._id == userID!
               })
           }
       }
   }
}
</code></pre>
<p>Subscriptions are given a name to make them easier to work with. I named this one <code>user_id</code>.</p>
<p>The function checks whether there&#8217;s already a subscription named <code>user_id</code>. If there is, then the function replaces it. If not, then it adds the new subscription. In either case, the subscription is defined by passing in a query that finds any <code>User</code> documents/objects where the <code>_id</code> field matches the current user&#8217;s ID.</p>
<p>The subscription should sync exactly one <code>User</code> object to the realm, and so the code for the view&#8217;s body can work with the <code>first</code> object in the results:</p>
<pre><code class="swift">struct LoggedInView: View {
   ...
   @ObservedResults(User.self) var users
   @Binding var userID: String?
   ...
   var body: some View {
       ZStack {
           if let user = users.first {
               ...
               ConversationListView(user: user)
               ...
           }
       }
       .navigationBarTitle("Chats", displayMode: .inline)
       .onAppear(perform: setSubscription)
   }
}
</code></pre>
<p>Other views work with different model classes and sync queries. For example, when the user clicks on a chat room, a new view is opened that displays all of the <code>ChatMessage</code>s for that conversation:</p>
<pre><code class="swift">struct ChatRoomBubblesView: View {
   ...
   @ObservedResults(ChatMessage.self, sortDescriptor: SortDescriptor(keyPath: "timestamp", ascending: true)) var chats
   @Environment(\.realm) var realm
   ...
   var conversation: Conversation?
   ...
   var body: some View {
       VStack {
           ...
       }
       .onAppear { loadChatRoom() }
   }

   private func loadChatRoom() {
       ...
       setSubscription()
       ...
   }

   private func setSubscription() {
       let subscriptions = realm.subscriptions
       subscriptions.write {
           if let conversation = conversation {
               if let currentSubscription = subscriptions.first(named: "conversation") {
                   currentSubscription.update(toType: ChatMessage.self) { chatMessage in
                       chatMessage.conversationID == conversation.id
                   }
               } else {
                   subscriptions.append(QuerySubscription&lt;ChatMessage&gt;(name: "conversation") { chatMessage in
                       chatMessage.conversationID == conversation.id
                   })
               }
           }
       }
   }
}
</code></pre>
<p>In this case, the query syncs all <code>ChatMessage</code> objects where the <code>conversationID</code> matches the <code>id</code> of the <code>Conversation</code> object passed to the view.</p>
<p>The view&#8217;s body can then iterate over all of the matching, synced objects:</p>
<pre><code class="swift">struct ChatRoomBubblesView: View {
...
   @ObservedResults(ChatMessage.self,
       sortDescriptor: SortDescriptor(keyPath: "timestamp", ascending: true)) var chats
   ...
   var body: some View {
       ...
       ForEach(chats) { chatMessage in
           ChatBubbleView(chatMessage: chatMessage,
                           authorName: chatMessage.author != user.userName ? chatMessage.author : nil,
                           isPreview: isPreview)
       }
       ...
   }
}
</code></pre>
<p>As it stands, there&#8217;s some annoying behavior. If you open conversation A, go back, and then open conversation B, you&#8217;ll initially see all of the messages from conversation A. The reason is that it takes a short time for the updated subscription to replace the <code>ChatMessage</code> objects in the synced Realm. I solve that by explicitly removing the subscription (which purges the synced objects) when closing the view:</p>
<pre><code class="swift">struct ChatRoomBubblesView: View {
   ...
   @Environment(\.realm) var realm
   ...
   var body: some View {
       VStack {
           ...
       }
       .onDisappear { closeChatRoom() }
   }

   private func closeChatRoom() {
       clearSubscription()
       ...
   }

   private func clearSubscription() {
       print("Leaving room, clearing subscription")
       let subscriptions = realm.subscriptions
       subscriptions.write {
           subscriptions.remove(named: "conversation")
       }
   }
}
</code></pre>
<p>I made a design decision that I&#8217;d use the same name (&#8220;conversation&#8221;) for this view, regardless of which conversation/chat room it&#8217;s working with. An alternative would be to create a unique subscription whenever a new chat room is opened (including the ID of the conversation in the name). I could then avoid removing the subscription when navigating away from a chat room.  This second approach would come with two advantages:</p>
<ol>
<li>The app should be more responsive when navigating between chat rooms (if you&#8217;d previously visited the chat room that you&#8217;re opening).</li>
<li>You can switch between chat rooms even when the device isn&#8217;t connected to the internet.</li>
</ol>
<p>The disadvantages of this approach would be:</p>
<ol>
<li>The app could end up with a lot of subscriptions (and there&#8217;s a cost to them).</li>
<li>The app continues to store all of the messages from any chat room that you&#8217;ve ever visited from this device. That consumes extra device storage and network bandwidth as messages from all of those rooms continue to be synced to the app.</li>
</ol>
<p>A third approach would be to stick with a single subscription (named &#8220;conversations&#8221;) that matches every <code>ChatMessage</code> object. The view would then need to apply a filter on the resulting <code>ChatMessage</code> objects so it only displayed those for the open chat room. This has the same advantages as the second approach, but can consume even more storage as the device will contain messages from all chat rooms—including those that the user has never visited.</p>
<p>Note that a different user can log into the app from the same device. You don&#8217;t want that user to be greeted with someone else&#8217;s data. To avoid that, the app removes all subscriptions when a user logs out:</p>
<pre><code class="swift">struct LogoutButton: View {
   ...
   @Environment(\.realm) var realm


   var body: some View {
       Button("Log Out") { isConfirming = true }
       .confirmationDialog("Are you that you want to logout",
                           isPresented: $isConfirming) {
           Button("Confirm Logout", role: .destructive, action: logout)
           Button("Cancel", role: .cancel) {}
       }
       .disabled(state.shouldIndicateActivity)
   }

   private func logout() {
       ...
       clearSubscriptions()
       ...
   }

   private func clearSubscriptions() {
       let subscriptions = realm.subscriptions
       subscriptions.write {
           subscriptions.removeAll()
       }
   }
}
</code></pre>
<h2>Conclusion</h2>
<p>In this article, you&#8217;ve seen how to include Realm Flexible Sync in your mobile app. I&#8217;ve shown the code for Swift, but the approach would be the same when building apps with Kotlin, Javascript, or .NET.</p>
<p>This is a preview release and we want your feedback.</p>
<p>Realm Flexible Sync will evolve to include more query and permission operators. Up next, we&#8217;re looking to expose array operators (that would allow me to add tighter restrictions on who can ask to read which chat messages). We&#8217;ll also enable querying on embedded documents.</p>
<p>Another feature I&#8217;d like to see is to limit which fields from a document get synced to a given user. This could allow the removal of the <code>Chatster</code> collection, as it&#8217;s only there to provide a read-only view of a subset of <code>User</code> fields to other users.</p>
<p>Want to suggest an enhancement or up-vote an existing request? The most effective way is through our <a href="https://feedback.mongodb.com/forums/923521-realm">feedback portal</a>.</p>
<p>Got questions? Ask them in our <a href="https://www.mongodb.com/community/forums/c/realm/realm-sync/111">Community forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/using-realm-flexible-sync-in-your-app-an-ios-tutorial/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Realm-Swift Type Projections</title>
		<link>/mongodb/realm-swift-type-projections</link>
					<comments>/mongodb/realm-swift-type-projections#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Wed, 26 Jan 2022 16:39:56 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[Swift]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4659</guid>

					<description><![CDATA[Introduction Realm natively provides a broad set of data types, including Bool, Int, Float, Double, String, Date, ObjectID, List, Mutable Set, enum, Map, … But, there are other data types that many of your iOS apps are likely to use. As an example, if you&#8217;re using Core Graphics, then it&#8217;s hard to get away without]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p><a href="https://docs.mongodb.com/realm/sdk/swift/data-types/supported-property-types/">Realm natively provides a broad set of data types</a>, including <code>Bool</code>, <code>Int</code>, <code>Float</code>, <code>Double</code>, <code>String</code>, <code>Date</code>, <code>ObjectID</code>, <code>List</code>, <code>Mutable Set</code>, <code>enum</code>, <code>Map</code>, …</p>
<p>But, there are other data types that many of your iOS apps are likely to use. As an example, if you&#8217;re using Core Graphics, then it&#8217;s hard to get away without using types such as <code>CGFloat</code>, <code>CGPoint</code>, etc. When working with SwiftUI, you use the <a href="https://developer.apple.com/documentation/swiftui/color"><code>Color</code></a> struct when working with colors.</p>
<p>A typical design pattern is to persist data using types natively supported by Realm, and then use a richer set of types in your app. When reading data, you add extra boilerplate code to convert them to your app&#8217;s types. When persisting data, you add more boilerplate code to convert your data back into types supported by Realm.</p>
<p>That works fine and gives you complete control over the type conversions. The downside is that you can end up with dozens of places in your code where you need to make the conversion.</p>
<p>Type projections still give you total control over how to map a <code>CGPoint</code> into something that can be persisted in Realm. But, you write the conversion code just once and then forget about it. The Realm-Swift SDK will then ensure that types are converted back and forth as required in the rest of your app.</p>
<p>The Realm-Swift SDK enables this by adding two new protocols that you can use to extend any Swift type. You opt whether to implement <code>CustomPersistable</code> or the version that&#8217;s allowed to fail (<code>FailableCustomPersistable</code>):</p>
<pre><code class="swift">protocol CustomPersistable {
   associatedtype PersistedType
   init(persisted: PersistedType)
   var persistableValue: PersistedType { get }
}
protocol FailableCustomPersistable {
   associatedtype PersistedType
   init?(persisted: PersistedType)
   var persistableValue: PersistedType { get }
}
</code></pre>
<p>In this post, I&#8217;ll show how the <a href="https://github.com/realm/Realm-Drawing">Realm-Drawing</a> app uses type projections to interface between Realm and Core Graphics.</p>
<h2>Prerequisites</h2>
<ul>
<li>iOS 15+</li>
<li>Xcode 13.2+</li>
<li><a href="https://github.com/realm/realm-swift/releases">Realm-Swift 10.21.0+</a></li>
</ul>
<h2>The Realm-Drawing App</h2>
<p><a href="https://github.com/realm/Realm-Drawing">Realm-Drawing</a> is a simple, collaborative drawing app. If two people log into the app using the same username, they can work on a drawing together. All strokes making up the drawing are persisted to Realm and then synced to all other instances of the app where the same username is logged in.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Realm_Draw_5f4559a2b9.gif" alt="Animated screen captures showing two iOS devices working on the same drawing" /></p>
<p>It&#8217;s currently iOS-only, but it would also sync with any Android drawing app that is connected to the same Realm back end.</p>
<h2>Using Type Projections in the App</h2>
<p>The Realm-Drawing iOS app uses three types that aren&#8217;t natively supported by Realm:</p>
<ul>
<li><code>CGFloat</code></li>
<li><code>CGPoint</code></li>
<li><code>Color</code> (SwiftUI)</li>
</ul>
<p>In this section, you&#8217;ll see how simple it is to use type projections to convert them into types that can be persisted to Realm and synced.</p>
<h3>Realm Schema (The Model)</h3>
<p>An individual drawing is represented by a single <a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Model/Drawing.swift"><code>Drawing</code></a> object:</p>
<pre><code class="swift">class Drawing: Object, ObjectKeyIdentifiable {
   @Persisted(primaryKey: true) var _id: ObjectId
   @Persisted var name = UUID().uuidString
   @Persisted var lines = RealmSwift.List&lt;Line&gt;()
}
</code></pre>
<p>A Drawing contains a <code>List</code> of <a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Model/Line.swift"><code>Line</code></a> objects:</p>
<pre><code class="swift">class Line: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var lineColor: Color
   @Persisted var lineWidth: CGFloat = 5.0
   @Persisted var linePoints = RealmSwift.List&lt;CGPoint&gt;()
}
</code></pre>
<p>It&#8217;s the <code>Line</code> class that uses the non-Realm-native types.</p>
<p>Let&#8217;s see how each type is handled.</p>
<h4>CGFloat</h4>
<p>I extend <code>CGFloat</code> to conform to Realm-Swift&#8217;s <code>CustomPersistable</code> protocol. All I needed to provide was:</p>
<ul>
<li>An initializer to convert what&#8217;s persisted in Realm (a <code>Double</code>) into the <code>CGFloat</code> used by the model</li>
<li>A method to convert a <code>CGFloat</code> into a <code>Double</code>:</li>
</ul>
<pre><code class="swift">extension CGFloat: CustomPersistable {
   public typealias PersistedType = Double
   public init(persistedValue: Double) { self.init(persistedValue) }
   public var persistableValue: Double { Double(self) }
}
</code></pre>
<p>The <a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Views/DrawingView.swift"><code>view</code></a> can then use <code>lineWidth</code> from the model object without worrying about how it&#8217;s converted by the Realm SDK:</p>
<pre><code class="swift">context.stroke(path, with: .color(line.lineColor),
   style: StrokeStyle(
       lineWidth: line.lineWidth,
       lineCap: .round, l
       ineJoin: .round
   )
)
</code></pre>
<h4>CGPoint</h4>
<p><code>CGPoint</code> is a little trickier, as it can&#8217;t just be cast into a Realm-native type. <code>CGPoint</code> contains the x and y coordinates for a point, and so, I create a Realm-friendly class (<a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Model/PersistablePoint.swift"><code>PersistablePoint</code></a>) that stores just that—<code>x</code> and <code>y</code> values as <code>Doubles</code>:</p>
<pre><code class="swift">public class PersistablePoint: EmbeddedObject, ObjectKeyIdentifiable {
   @Persisted var x = 0.0
   @Persisted var y = 0.0

   convenience init(_ point: CGPoint) {
       self.init()
       self.x = point.x
       self.y = point.y
   }
}
</code></pre>
<p>I implement the <code>CustomPersistable</code> protocol for <code>CGPoint</code> by mapping between a <code>CGPoint</code> and the <code>x</code> and <code>y</code> coordinates within a <code>PersistablePoint</code>:</p>
<pre><code class="swift">extension CGPoint: CustomPersistable {
   public typealias PersistedType = PersistablePoint   
   public init(persistedValue: PersistablePoint) { self.init(x: persistedValue.x, y: persistedValue.y) }
   public var persistableValue: PersistablePoint { PersistablePoint(self) }
}
</code></pre>
<h4>SwiftUI.Color</h4>
<p><code>Color</code> is made up of the three RGB components plus the opacity. I use the <a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Model/PersistableColor.swift"><code>PersistableColor</code></a> class to persist a representation of <code>Color</code>:</p>
<pre><code class="swift">public class PersistableColor: EmbeddedObject {
   @Persisted var red: Double = 0
   @Persisted var green: Double = 0
   @Persisted var blue: Double = 0
   @Persisted var opacity: Double = 0

   convenience init(color: Color) {
       self.init()
       if let components = color.cgColor?.components {
           if components.count &gt;= 3 {
               red = components[0]
               green = components[1]
               blue = components[2]
           }
           if components.count &gt;= 4 {
               opacity = components[3]
           }
       }
   }
}
</code></pre>
<p>The extension to implement <code>CustomPersistable</code> for <code>Color</code> provides methods to initialize <code>Color</code> from a <code>PersistableColor</code>, and to generate a <code>PersistableColor</code> from itself:</p>
<pre><code class="swift">extension Color: CustomPersistable {
   public typealias PersistedType = PersistableColor

   public init(persistedValue: PersistableColor) { self.init(
       .sRGB,
       red: persistedValue.red,
       green: persistedValue.green,
       blue: persistedValue.blue,
       opacity: persistedValue.opacity) }

   public var persistableValue: PersistableColor {
       PersistableColor(color: self)
   }
}
</code></pre>
<p>The <a href="https://github.com/realm/Realm-Drawing/blob/main/iOS/DrawingApp/Views/DrawingView.swift">view</a> can then use <code>selectedColor</code> from the model object without worrying about how it&#8217;s converted by the Realm SDK:</p>
<pre><code class="swift">context.stroke(
   path,
   with: .color(line.lineColor),
   style: StrokeStyle(lineWidth:
   line.lineWidth,
   lineCap: .round,
   lineJoin: .round)
)
</code></pre>
<h2>Conclusion</h2>
<p>Type projections provide a simple, elegant way to convert any type to types that can be persisted and synced by Realm.</p>
<p>It&#8217;s your responsibility to define how the mapping is implemented. After that, the Realm SDK takes care of everything else.</p>
<p>Please provide feedback and ask any questions in the <a href="https://www.mongodb.com/community/forums/c/realm-sdks/58">Realm Community Forum</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm-swift-type-projections/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Using Maps and Location Data in Your SwiftUI (+Realm) App</title>
		<link>/mongodb/realm/maps</link>
					<comments>/mongodb/realm/maps#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 12 Jul 2021 12:46:04 +0000</pubDate>
				<category><![CDATA[Realm]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mobile]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[SwiftUI]]></category>
		<guid isPermaLink="false">/?p=4620</guid>

					<description><![CDATA[Introduction Embedding Apple Maps and location functionality in SwiftUI apps used to be a bit of a pain. It required writing your own SwiftUI wrapper around UIKit code—see these examples from the O-FISH app: Location helper Map views If you only need to support iOS14 and later, then you can forget most of that messy]]></description>
										<content:encoded><![CDATA[<h2>Introduction</h2>
<p>Embedding Apple Maps and location functionality in SwiftUI apps used to be a bit of a pain. It required writing your own SwiftUI wrapper around UIKit code—see these examples from the O-FISH app:</p>
<ul>
<li><a href="https://github.com/WildAid/o-fish-ios/blob/main/o-fish-ios/Helpers/LocationHelper.swift">Location helper</a></li>
<li><a href="https://github.com/WildAid/o-fish-ios/tree/main/o-fish-ios/Views/Components/Maps">Map views</a></li>
</ul>
<p>If you only need to support iOS14 and later, then you can <strong>forget most of that messy code <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f60a.png" alt="😊" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong>. If you need to support iOS13—sorry, you need to go the O-FISH route!</p>
<p>iOS14 introduced the <a href="https://developer.apple.com/documentation/mapkit/map">Map</a> SwiftUI view (part of <a href="https://developer.apple.com/documentation/mapkit/map">Mapkit</a>) allowing you to embed maps directly into your SwiftUI apps without messy wrapper code.</p>
<p>This article shows you how to embed Apple Maps into your app views using Mapkit&#8217;s Map view. We&#8217;ll then look at how you can fetch the user&#8217;s current location—with their permission, of course!</p>
<p>Finally, we&#8217;ll see how to store the location data in Realm in a format that lets MongoDB Realm sync it to MongoDB Atlas. Once in Atlas, you can add a <a href="https://docs.mongodb.com/manual/core/2dsphere/">geospatial index</a> and use <a href="https://www.mongodb.com/products/charts">MongoDB Charts</a> to plot the data on a map—we&#8217;ll look at that too.</p>
<p>Most of the code snippets have been extracted from the <a href="https://github.com/realm/RChat">RChat app</a>. That app is a good place to see maps and location data in action. <a href="https://developer.mongodb.com/how-to/building-a-mobile-chat-app-using-realm-new-way/">Building a Mobile Chat App Using Realm – The New and Easier Way</a> is a good place to learn more about the RChat app—including how to enable <a href="https://docs.mongodb.com/realm/sync/">MongoDB Realm Sync</a>.</p>
<h2>Prerequisites</h2>
<ul>
<li><a href="https://github.com/realm/realm-cocoa/releases">Realm-Cocoa 10.8.0</a>+ (may work with some 10.7.X versions)</li>
<li>iOS 14.5+ (<a href="https://developer.apple.com/documentation/mapkit/map">Mapkit</a> was introduced in iOS 14.0 and so most features should work with earlier iOS 14.X versions)</li>
<li><a href="https://developer.apple.com/xcode/">XCode12+</a></li>
</ul>
<h2>How to Add an Apple Map to Your SwiftUI App</h2>
<p>To begin, let&#8217;s create a simple view that displays a map, the coordinates of the center of that map, and the zoom level:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map1_7ea7ecbf15.gif" alt="Gif of scrolling around an embedded Apple Map and seeing the reported coordinates changing" /></p>
<p>With Mapkit and SwiftUI, this only takes a few lines of code:</p>
<pre><code class="swift">import MapKit
import SwiftUI

struct MyMapView: View {
    @State private var region: MKCoordinateRegion = MKCoordinateRegion(
        center: CLLocationCoordinate2D(latitude: MapDefaults.latitude, longitude: MapDefaults.longitude),
        span: MKCoordinateSpan(latitudeDelta: MapDefaults.zoom, longitudeDelta: MapDefaults.zoom))

    private enum MapDefaults {
        static let latitude = 45.872
        static let longitude = -1.248
        static let zoom = 0.5
    }

    var body: some View {
        VStack {
            Text("lat: \(region.center.latitude), long: \(region.center.longitude). Zoom: \(region.span.latitudeDelta)")
            .font(.caption)
            .padding()
            Map(coordinateRegion: $region,
                interactionModes: .all,
                showsUserLocation: true)
        }
    }
}
</code></pre>
<p>Note that <code>showsUserLocation</code> won&#8217;t work unless the user has already given the app permission to use their location—we&#8217;ll get to that.</p>
<p><code>region</code> is initialized to a starting location, but it&#8217;s updated by the <code>Map</code> view as the user scrolls and zooms in and out.</p>
<h3>Adding Bells and Whistles to Your Maps (Pins at Least)</h3>
<p>Pins can be added to a map in the form of &#8220;annotations.&#8221; Let&#8217;s start with a single pin:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map2_3812086195.png" alt="Embedded Apple Map showing a red pin" /></p>
<p>Annotations are provided as an array of structs where each instance must contain the coordinates of the pin. The struct must also conform to the <a href="https://developer.apple.com/documentation/swift/identifiable">Identifiable</a> protocol:</p>
<pre><code class="swift">struct MyAnnotationItem: Identifiable {
    var coordinate: CLLocationCoordinate2D
    let id = UUID()
}
</code></pre>
<p>We can now create an array of <code>MyAnnotationItem</code> structs:</p>
<pre><code class="swift">let annotationItems = [
    MyAnnotationItem(coordinate: CLLocationCoordinate2D(
        latitude: MapDefaults.latitude,
        longitude: MapDefaults.longitude))]
</code></pre>
<p>We then pass <code>annotationItems</code> to the <code>MapView</code> and indicate that we want a <code>MapMarker</code> at the contained coordinates:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
        MapMarker(coordinate: item.coordinate)
    }
</code></pre>
<p>That gives us the result we wanted.</p>
<p>What if we want multiple pins? Not a problem. Just add more <code>MyAnnotationItem</code> instances to the array.</p>
<p>All of the pins will be the same default color. But, what if we want different colored pins? It&#8217;s simple to extend our code to produce this:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map3_669f6ec179.png" alt="Embedded Apple Map showing red, yellow, and plue pins at different locations" /></p>
<p>Firstly, we need to extend <code>MyAnnotationItem</code> to include an optional <code>color</code> and a <code>tint</code> that returns <code>color</code> if it&#8217;s been defined and &#8220;red&#8221; if not:</p>
<pre><code class="swift">struct MyAnnotationItem: Identifiable {
    var coordinate: CLLocationCoordinate2D
    var color: Color?
    var tint: Color { color ?? .red }
    let id = UUID()
}
</code></pre>
<p>In our sample data, we can now choose to provide a color for each annotation:</p>
<pre><code class="swift">let annotationItems = [
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: MapDefaults.latitude,
            longitude: MapDefaults.longitude)),
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: 45.8827419,
            longitude: -1.1932383),
        color: .yellow),
    MyAnnotationItem(
        coordinate: CLLocationCoordinate2D(
            latitude: 45.915737,
            longitude: -1.3300991),
        color: .blue)
]
</code></pre>
<p>The <code>MapView</code> can then use the <code>tint</code>:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
    MapMarker(
        coordinate: item.coordinate,
        tint: item.tint)
}
</code></pre>
<p>If you get bored of pins, you can use <code>MapAnnotation</code> to use any view you like for your annotations:</p>
<pre><code class="swift">Map(coordinateRegion: $region,
    interactionModes: .all,
    showsUserLocation: true,
    annotationItems: annotationItems) { item in
    MapAnnotation(coordinate: item.coordinate) {
        Image(systemName: "gamecontroller.fill")
            .foregroundColor(item.tint)
    }
}
</code></pre>
<p>This is the result:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/realm_map5_8509602cd7.png" alt="Apple Map showing red, yellow and blue game controller icons at different locations on the map" /></p>
<p>You could also include the name of the system image to use with each annotation.</p>
<p>This <a href="https://gist.github.com/am-MongoDB/3073226a84bf6deb6b2df7afcb21ca92">gist</a> contains the final code for the view.</p>
<h2>Finding Your User&#8217;s Location</h2>
<h3>Asking for Permission</h3>
<p>Apple is pretty vocal about respecting the privacy of their users, and so it shouldn&#8217;t be a shock that your app will have to request permission before being able to access a user&#8217;s location.</p>
<p>The first step is to add a key-value pair to your Xcode project to indicate that the app may request permission to access the user&#8217;s location, and what text should be displayed in the alert. You can add the pair to the &#8220;Info.plist&#8221; file:</p>
<pre><code>Privacy - Location When In Use Usage Description : We'll only use your location when you ask to include it in a message
</code></pre>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/Info_plist_1500a15e11.png" alt="Screenshot from Xcode showing the key-value pair for requesting permission for the app to access the user's location" /></p>
<p>Once that setting has been added, the user should see an alert the first time that the app attempts to access their current location:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/request_access_to_location_08d1be66d1.png" alt="iPhone screenshot – app is requesting permission to access the user's location" /></p>
<h3>Accessing Current Location</h3>
<p>While Mapkit has made maps simple and native in SwiftUI, the same can&#8217;t be said for location data.</p>
<p>You need to create a SwiftUI wrapper for Apple&#8217;s <a href="https://developer.apple.com/documentation/corelocation">Core Location</a> functionality. There&#8217;s not a lot of value in explaining this boilerplate code—just copy this code from RChat&#8217;s <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Helpers/LocationHelper.swift">LocationHelper.swift</a> file, and paste it into your app:</p>
<pre><code class="swift">import CoreLocation

class LocationHelper: NSObject, ObservableObject {

    static let shared = LocationHelper()
    static let DefaultLocation = CLLocationCoordinate2D(latitude: 45.8827419, longitude: -1.1932383)

    static var currentLocation: CLLocationCoordinate2D {
        guard let location = shared.locationManager.location else {
            return DefaultLocation
        }
        return location.coordinate
    }

    private let locationManager = CLLocationManager()

    private override init() {
        super.init()
        locationManager.delegate = self
        locationManager.desiredAccuracy = kCLLocationAccuracyBest
        locationManager.requestWhenInUseAuthorization()
        locationManager.startUpdatingLocation()
    }
}

extension LocationHelper: CLLocationManagerDelegate {
    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) { }

    public func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("Location manager failed with error: \(error.localizedDescription)")
    }

    public func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
        print("Location manager changed the status: \(status)")
    }
}
</code></pre>
<p>Once added, you can access the user&#8217;s location with this simple call:</p>
<pre><code class="swift">let location = LocationHelper.currentLocation
</code></pre>
<h3>Store Location Data in Your Realm Database</h3>
<h4>The Location Format Expected by MongoDB</h4>
<p>Realm doesn&#8217;t have a native type for a geographic location, and so it&#8217;s up to us how we choose to store it in a Realm Object. That is, unless we want to synchronize the data to MongoDB Atlas using MongoDB Realm Sync, and go on to use MongoDB&#8217;s geospatial functionality.</p>
<p>To make the best use of the location data in Atlas, we need to add a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes">geospatial index</a> to the field (which we’ll see how to do soon.) That means storing the location in a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-data">supported format</a>. Not all options will work with Realm Sync (e.g., it&#8217;s not guaranteed that attributes will appear in the same order in your Realm Object and the synced Atlas document). The most robust approach is to use an array where the first element is longitude and the second is latitude:</p>
<pre><code class="json">location: [&lt;longitude&gt;, &lt;latitude&gt;]
</code></pre>
<h4>Your Realm Object</h4>
<p>The RChat app gives users the option to include their location in a chat message—this means that we need to include the location in the <a href="https://github.com/realm/RChat/blob/main/RChat-iOS/RChat/Model/ChatMessage.swift">ChatMessage</a> Object:</p>
<pre><code class="swift">@objcMembers class ChatMessage: Object, ObjectKeyIdentifiable {
  …
    let location = List&lt;Double&gt;()
  …
    convenience init(author: String, text: String, image: Photo?, location: [Double] = []) {
        ...
    location.forEach { coord in
            self.location.append(coord)
      }
        ...
        }
    }
   ….
}
</code></pre>
<p>The <code>location</code> array that&#8217;s passed to that initializer is formed like this:</p>
<pre><code class="swift">let location = LocationHelper.currentLocation
self.location = [location.longitude, location.latitude]
</code></pre>
<h2>Location Data in Your Backend MongoDB Realm App</h2>
<p>The easiest way to create your backend MongoDB Realm schema is to enable <a href="https://docs.mongodb.com/realm/sync/enable-development-mode/">Development Mode</a>—that way, the schema is automatically generated from your Swift Realm Objects.</p>
<p>This is the generated <a href="https://github.com/realm/RChat/blob/main/RChat-Realm/RChat/services/mongodb-atlas/rules/RChat.ChatMessage.json">schema</a> for our &#8220;ChatMessage&#8221; collection:</p>
<pre><code class="swift">{
    "bsonType": "object",
    "properties": {
      "_id": {
        "bsonType": "string"
      },
      ...
      "location": {
        "bsonType": "array",
        "items": {
          "bsonType": "double"
        }
      }
    },
    "required": [
      "_id",
      ...
    ],
    "title": "ChatMessage"
}
</code></pre>
<p>This is a document that&#8217;s been created from a synced Realm <code>ChatMessage</code> object:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/atlas_document_d09cb3be1d.png" alt="Screen capture of an Atlas document, which includes an array named location" /></p>
<h3>Adding a Geospatial Index in Atlas</h3>
<p>Now that you have location data stored in Atlas, it would be nice to be able to work with it—e.g., running <a href="https://docs.mongodb.com/manual/geospatial-queries/">geospatial queries</a>. To enable this, you need to add a <a href="https://docs.mongodb.com/manual/geospatial-queries/#geospatial-indexes">geospatial index</a> to the <code>location</code> field.</p>
<p>From the Atlas UI, select the &#8220;Indexes&#8221; tab for your collection and click &#8220;CREATE INDEX&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/geo_index1_604fcbcd13.png" alt="Atlas screen capture of creating a new index" /></p>
<p>You should then configure a <code>2dsphere</code> index:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/geo_index2_8878556cfc.png" alt="Atlas screen capture of creating a new 2dsphere index" /></p>
<p>Most chat messages won&#8217;t include the user&#8217;s location and so I set the <code>sparse</code> option for efficiency.</p>
<p>Note that you&#8217;ll get an error message if your ChatMessage collection contains any documents where the value in the location attribute isn&#8217;t in a valid geospatial format.</p>
<p>Atlas will then build the index. This will be very quick, unless you already have a huge number of documents containing the location field. Once complete, you can move onto the next section.</p>
<h3>Plotting Your Location Data in MongoDB Charts</h3>
<p><a href="https://www.mongodb.com/products/charts">MongoDB Charts</a> is a simple way to visualize MongoDB data. You can access it through the same UI as Realm and Atlas. Just click on the &#8220;Charts&#8221; button:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/select_charts_9c8caa71c0.png" alt="Atlas screen capture of MongoDB Charts button" /></p>
<p>The first step is to click the &#8220;Add Data Source&#8221; button:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_data_source_4cbf88fea5.png" alt="Charts screen capture of adding a new data source" /></p>
<p>Select your Atlas cluster:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_select_cluster_b6d35ea00e.png" alt="Charts screen capture of adding Atlas cluster as a data source" /></p>
<p>Select the <code>RChat.ChatMessage</code> collection:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_select_collections_4f0dc0577d.png" alt="Charts screen capture of selecting the ChatMessage collection in the RChat database" /></p>
<p>Click “Finish.” You’ll be taken to the default Dashboards view, which is empty for now. Click &#8220;Add Dashboard&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_dashboard1_b25eb3e015.png" alt="Charts screen capture of adding a new dashboard" /></p>
<p>In your new dashboard, click &#8220;ADD CHART&#8221;:</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_add_chart_f00639d1a1.png" alt="Charts screen capture of adding a new chart" /></p>
<p>Configure your chart as shown here by:<br />
&#8211; Setting the chart type to &#8220;Geospatial&#8221; and the sub-type to &#8220;Scatter.&#8221;<br />
&#8211; Dragging the &#8220;location&#8221; attribute to the coordinates box.<br />
&#8211; Dragging the &#8220;author&#8221; field to the &#8220;Color&#8221; box.</p>
<p><img decoding="async" src="https://mongodb-devhub-cms.s3.us-west-1.amazonaws.com/charts_create_chart_81189874ac.png" alt="Charts screen capture of configuring a new chart" /></p>
<p>Once you&#8217;ve created your chart, you can <a href="https://docs.mongodb.com/charts/saas/embed-chart-anon-auth/#std-label-anon-embedding-charts">embed it</a> in web apps, etc. That&#8217;s beyond the scope of this article, but check out the <a href="https://docs.mongodb.com/charts/saas/">MongoDB Charts docs</a> if you&#8217;re interested.</p>
<h2>Conclusion</h2>
<p>SwiftUI makes it easy to embed Apple Maps in your SwiftUI apps. As with most Apple frameworks, there are extra maps features available if you break out from SwiftUI, but I&#8217;d suggest that the simplicity of working with SwiftUI is enough incentive for you to avoid that unless you have a compelling reason.</p>
<p>Accessing location information from within SwiftUI still feels a bit of a hack, but in reality, you cut and paste the helper code once, and then you&#8217;re good to go.</p>
<p>By storing the location as a <code>[longitude, latitude]</code> array (<code>List</code>) in your Realm database, it&#8217;s simple to sync it with MongoDB Atlas. Once in Atlas, you have the full power of MongoDB&#8217;s geospatial functionality to work your location data.</p>
<p>If you have questions, please head to our <a href="https://community.mongodb.com/">developer community website</a> where the MongoDB engineers and the MongoDB community will help you build your next big idea with MongoDB.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm/maps/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Realm Partitioning Strategies</title>
		<link>/mongodb/realm-partitioning-strategies</link>
					<comments>/mongodb/realm-partitioning-strategies#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Tue, 04 May 2021 15:04:47 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[android]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mongodb]]></category>
		<guid isPermaLink="false">/?p=4611</guid>

					<description><![CDATA[I&#8217;ve just released a new article – Realm Partitioning Strategies. Realm partitioning can be used to control what data is synced to each mobile device, ensuring that your app is efficient, performant and secure. This article will help you pick the right partitioning strategy for your app. MongoDB Realm Sync stores the superset of your]]></description>
										<content:encoded><![CDATA[<p>I&#8217;ve just released a <a href="https://developer.mongodb.com/how-to/realm-partitioning-strategies">new article – Realm Partitioning Strategies</a>.</p>
<p>Realm partitioning can be used to control what data is synced to each mobile device, ensuring that your app is efficient, performant and secure. This article will help you pick the right partitioning strategy for your app.</p>
<p>MongoDB Realm Sync stores the superset of your application data in the cloud using MongoDB Atlas. The simplest strategy is that every instance of your mobile app contains the full database, but that quickly consumes a lot of space on the users&#8217; devices and makes the app slow to start while it syncs all of the data for the first time.<br />
Alternative strategies include partitioning by:</p>
<ul>
<li>User</li>
<li>Group/team/store</li>
<li>Chanel/room/topic</li>
<li>Geographic region</li>
<li>Bucket of time</li>
<li>Any combination of these</li>
</ul>
<p><a href="https://developer.mongodb.com/how-to/realm-partitioning-strategies">The article</a> discusses all of those strategies so that you adopt one, or craft a different strategy that&#8217;s customized to your app&#8217;s needs.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/realm-partitioning-strategies/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Accessing Realm Data on iOS using Realm Studio</title>
		<link>/mongodb/accessing-realm-data-on-ios-using-realm-studio</link>
					<comments>/mongodb/accessing-realm-data-on-ios-using-realm-studio#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Tue, 09 Feb 2021 13:17:49 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[mongodb]]></category>
		<guid isPermaLink="false">/?p=4594</guid>

					<description><![CDATA[The Realm Mobile Database makes it much faster to develop mobile applications. MongoDB Realm Studio is a desktop GUI that lets you view, manipulate, and import data held within your mobile app&#8217;s Realm database. I&#8217;ve just published a new article (Accessing Realm Data on iOS using Realm Studio) which steps through how to track down]]></description>
										<content:encoded><![CDATA[
The <a href="https://www.mongodb.com/realm/mobile/database" target="_blank" rel="noreferrer noopener">Realm Mobile Database</a> makes it much faster to develop mobile applications. <a href="https://github.com/realm/realm-studio" data-type="URL" data-id="https://github.com/realm/realm-studio">MongoDB </a><a href="https://github.com/realm/realm-studio" data-type="URL" data-id="https://github.com/realm/realm-studio" target="_blank" rel="noreferrer noopener">Realm Studio</a> is a desktop GUI that lets you view, manipulate, and import data held within your mobile app&#8217;s Realm database.




<div style="height:20px" aria-hidden="true" class="wp-block-spacer"></div>




I&#8217;ve just published a new article (<a href="https://developer.mongodb.com/how-to/realm-ios-database-access-using-realm-studio/" target="_blank" rel="noreferrer noopener">Accessing Realm Data on iOS using Realm Studio</a>) which steps through how to track down the locations of your iOS Realm database files, open them in Realm Studio, view the data, and make changes.




]]></content:encoded>
					
					<wfw:commentRss>/mongodb/accessing-realm-data-on-ios-using-realm-studio/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Building a Mobile Chat App Using Realm – Data Architecture</title>
		<link>/uncategorized/building-a-mobile-chat-app-using-realm-data-architecture</link>
					<comments>/uncategorized/building-a-mobile-chat-app-using-realm-data-architecture#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Thu, 07 Jan 2021 08:09:00 +0000</pubDate>
				<category><![CDATA[Me]]></category>
		<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[ios]]></category>
		<category><![CDATA[mobile]]></category>
		<category><![CDATA[mongodb]]></category>
		<guid isPermaLink="false">/?p=4580</guid>

					<description><![CDATA[I&#8217;ve just built an iOS chat app using SwiftUI, Realm, and Realm Sync. I decided on a chat app as it makes an interesting case study for designing a data model and controlling who can access what data: A chat message needs to be viewable by all members of a chat room and no one else.]]></description>
										<content:encoded><![CDATA[<p>I&#8217;ve just built an <a href="https://github.com/ClusterDB/RChat" target="_blank" rel="noopener">iOS chat app</a> using SwiftUI, Realm, and Realm Sync. I decided on a chat app as it makes an interesting case study for designing a data model and controlling who can access what data:</p>
<ul>
<li>A chat message needs to be viewable by all members of a chat room and no one else.</li>
<li>New messages must be pushed to the chat room for all online members in real-time.</li>
<li>The app should notify a user that there are new messages even when they don&#8217;t have that chat room open.</li>
<li>Users should be able to observe the &#8220;presence&#8221; of other users (e.g., whether they&#8217;re currently logged into the app).</li>
<li>There&#8217;s no limit on how many messages users send in a chat room, and so the data structures must allow them to grow indefinitely.</li>
</ul>
<p>Because this app&#8217;s data model (and the decisions taken when designing) serve as a great starting point for many different types of apps, I wrote it up in this <a href="https://developer.mongodb.com/how-to/realm-swiftui-ios-chat-app">HowTo article</a>.</p>
<p>You can download all of the code from the <a href="https://github.com/ClusterDB/RChat">GitHub repo</a>.</p>
<p>Checkout <a href="https://developer.mongodb.com/how-to/realm-swiftui-ios-chat-app">Building a Mobile Chat App Using Realm – Data Architecture</a> for all of the details.</p>
]]></content:encoded>
					
					<wfw:commentRss>/uncategorized/building-a-mobile-chat-app-using-realm-data-architecture/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Building an iOS app with Realm, SwiftUI, &#038; Combine</title>
		<link>/me/building-an-ios-app-with-realm-swiftui-combine</link>
					<comments>/me/building-an-ios-app-with-realm-swiftui-combine#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Tue, 01 Dec 2020 16:42:00 +0000</pubDate>
				<category><![CDATA[Me]]></category>
		<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[Realm]]></category>
		<category><![CDATA[mongodb]]></category>
		<guid isPermaLink="false">/?p=4573</guid>

					<description><![CDATA[I&#8217;m relatively new to building iOS apps (a little over a year&#8217;s experience), and so I prefer using the latest technologies that make me a more productive developer. That means my preferred app stack looks like this: In &#x1f525; Out &#x2744;&#xfe0f; Swift Objective C SwiftUI UIKit Combine RxSwift Realm Core Data MongoDB Realm Sync (where]]></description>
										<content:encoded><![CDATA[
I&#8217;m relatively new to building iOS apps (a little over a year&#8217;s experience), and so I prefer using the latest technologies that make me a more productive developer. That means my preferred app stack looks like this:

<table>
<thead>
<tr>
  <th align="left"><strong>In <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/1f525.png" alt="🔥" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong></th>
  <th align="left"><strong>Out <img src="https://s.w.org/images/core/emoji/15.0.3/72x72/2744.png" alt="❄" class="wp-smiley" style="height: 1em; max-height: 1em;" /></strong></th>
</tr>
</thead>
<tbody>
<tr>
  <td align="left">Swift</td>
  <td align="left">Objective C</td>
</tr>
<tr>
  <td align="left">SwiftUI</td>
  <td align="left">UIKit</td>
</tr>
<tr>
  <td align="left">Combine</td>
  <td align="left">RxSwift</td>
</tr>
<tr>
  <td align="left">Realm</td>
  <td align="left">Core Data</td>
</tr>
<tr>
  <td align="left">MongoDB Realm Sync (where needed)</td>
  <td align="left">Home-baked cross-platform data sync</td>
</tr>
</tbody>
</table>

I built a simple, distributed task management app on that stack, and wrote it up in <a href="https://developer.mongodb.com/how-to/realm-swiftui-combine-first-app">&#8220;Build Your First iOS Mobile App Using Realm, SwiftUI, &amp; Combine&#8221;</a>. To continue my theme on being productive, I borrowed heavily from MongoDB&#8217;s official iOS Swift tutorial:

<ul>
<li>I refactored the <a href="https://docs.mongodb.com/realm/tutorial/ios-swift/">original (UIKit) front end</a>, adding Combine for event management, and replacing the UIKit ViewControllers with Swift views.</li>
<li>The <a href="https://docs.mongodb.com/realm/tutorial/realm-app/#tutorial-task-tracker-create-realm-app">back end Realm app</a> is entirely unchanged. Note that once you&#8217;ve stood up this back end, then this app can share its data with the equivalent <a href="https://docs.mongodb.com/realm/tutorial/android-kotlin/">Android</a>, <a href="https://docs.mongodb.com/realm/tutorial/react-native/">React/JavaScript</a>, and <a href="https://docs.mongodb.com/realm/tutorial/nodejs-cli/">Node.js</a> apps with no changes.</li>
</ul>

You can download all of the code for the front end app from the <a href="https://github.com/ClusterDB/task-tracker-swiftui">GitHub repo</a>.

Checkout <a href="https://developer.mongodb.com/how-to/realm-swiftui-combine-first-app">Build Your First iOS Mobile App Using Realm, SwiftUI, &amp; Combine</a> for all of the details.
]]></content:encoded>
					
					<wfw:commentRss>/me/building-an-ios-app-with-realm-swiftui-combine/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>How to create Dynamic Custom Roles with MongoDB Stitch</title>
		<link>/mongodb/how-to-create-dynamic-custom-roles-with-mongodb-stitch</link>
					<comments>/mongodb/how-to-create-dynamic-custom-roles-with-mongodb-stitch#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Thu, 28 Mar 2019 09:54:35 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[MongoDB Stitch]]></category>
		<category><![CDATA[serverless]]></category>
		<guid isPermaLink="false">/?p=4566</guid>

					<description><![CDATA[None of us want to write lots of code to control what data each user can access. In most cases, you can set up your data access controls in seconds by using Stitch&#8217;s built-in templates, e.g., &#8220;Users can read and write their own data&#8221; or &#8220;Users can read and write their own data. Users that]]></description>
										<content:encoded><![CDATA[<p>None of us want to write lots of code to control what data each user can access. In most cases, you can set up your data access controls in seconds by using <a href="https://docs.mongodb.com/stitch/mongodb/define-roles-and-permissions/#select-a-collection-rule-template" title="Stitch includes templates to control what data a user can access">Stitch&#8217;s built-in templates</a>, e.g., &#8220;Users can read and write their own data&#8221; or &#8220;Users can read and write their own data. Users that belong to a sharing list can read that data&#8221;. Stitch also lets you create <a href="https://docs.mongodb.com/stitch/mongodb/define-roles-and-permissions/#define-the-role-s-apply-when-condition" title="Define your own criteria to identify a MongoDB Stitch role">custom roles</a> that you tailor to your application and schema – this post creates such a rule, querying a second collection when deciding whether to allow a user to insert a document.</p>
<p>The application is a troll-free timeline where you can only tag another user in a post if that user has labeled you as a trusted friend. I&#8217;ve already created a database called <code>safeplace</code> for the collections.</p>
<p>The <code>users</code> collection includes a list of usernames for their trusted friends (<code>peopleWhoCanTagMe</code>):</p>
<pre><code class="js">{
    "_id" : ObjectId("5c9273127558d01d93f53dc0"),
    "username" : "alovelace",
    "name" : {
        "first" : "Ada",
        "last" : "Lovelace"
    },
    "peopleWhoCanTagMe" : [
        "jeckert",
        "jmauchly"
    ]
}
</code></pre>
<p>You then need to create a data access rule for the <code>posts</code> collection, consisting of 2 roles, which Stitch evaluates in sequence:</p>
<p><img decoding="async" src="https://webassets.mongodb.com/_com_assets/cms/Create-Rules-nzrr0dasb3.png" alt="Creating custom roles for Stitch data access control rules" /></p>
<p>The second, <code>anyReader</code>, role lets anyone read any post, but the role we care about is <code>allowedTagger</code> which controls what the application can write to the collection.</p>
<p>The <code>allowedTagger</code> role is defined using this <a href="https://docs.mongodb.com/stitch/services/json-expressions/" title="JSON expressions to identify MongoDB Stitch roles">JSON expression</a>:</p>
<pre><code class="js">{
  "%%true": {
    "%function": {
      "name": "canTheyTag",
      "arguments": [
        "%%root.poster",
        "%%root.tagged"
      ]
    }
  }
}
</code></pre>
<p><code>%%root</code> represents the document that the user is attempting to insert. The <code>poster</code> and <code>tagged</code> attributes of the document to be written are the usernames of the author and their claimed friend. The JSON expression passes them as parameters to a <a href="https://docs.mongodb.com/stitch/functions/" title="Creating a serverless function in MongoDB Stitch">Stitch function</a> named <code>canTheyTag</code>:</p>
<pre><code class="js">exports = function(poster, tagged){
  var collection = context.services.get("mongodb-atlas")
    .db("safeplace").collection("users");
  return collection.findOne({username: tagged})
  .then ( userDoc =&gt; { 
    return (userDoc.peopleWhoCanTagMe.indexOf(poster) &gt; -1);
  }).catch( e =&gt; { console.log(e); return false; }); 
};
</code></pre>
<p>This searches the <code>users</code> collection for the tagged user and then checks that the poster&#8217;s username appears in the <code>peopleWhoCanTagMe</code> array in the retrieved document.</p>
<p>You can test this new rule using the <code>mongo</code> shell (courtesy of <a href="https://docs.mongodb.com/stitch/mongodb/connect-over-the-wire-protocol/" title="Connect to MongoDB Stitch using any MongoDB tool or connector using the MongoDB wire protocol">Stitch&#8217;s MongoDB Connection String feature</a>). Initially, I&#8217;m not included in Ada&#8217;s list of friends and so trying to tag her in a post fails:</p>
<pre><code class="js">db.posts.insert({ 
    poster: "amorgan", 
    tagged: "alovelace", 
    post: "Just sent you a pull request" })

WriteCommandError({ "ok" : 0, "errmsg" : "insert not permitted" })
</code></pre>
<p>The logs show that the insert didn&#8217;t match our customer role but that it did match the second (<code>anyReader</code>), but that inserts aren&#8217;t allowed for that role:</p>
<pre><code>Logs:
[
  "uncaught promise rejection: StitchError: insert not permitted"
]
Error:
role anyReader does not have insert permission
Stack Trace:
StitchError: insert not permitted
{
  "name": "insertOne",
  "service": "mongodb-atlas"
}
Compute Used: 936719 bytes•ms
</code></pre>
<p>Ada then adds me as a trusted friend:</p>
<pre><code class="js">db.users.update(
    {username: "alovelace"}, 
    {$push: {peopleWhoCanTagMe: "amorgan"}}
)
</code></pre>
<p>My second attempt to tag her in a post succeeds:</p>
<pre><code class="js">db.posts.insert({
    poster: "amorgan", 
    tagged: "alovelace", 
    post: "Just sent you a pull request" })

WriteResult({ "nInserted" : 1 })
</code></pre>
<p>I recently had someone ask me how to implement &#8220;traditional database roles&#8221; using Stitch, i.e. an administrator explicitly defines which user ids belong to a specific role, and then use that role to determine whether they can access a collection. You can use this same approach for that use case – have a collection that assigns users to roles and then find the user id in that collection from a Stitch function that&#8217;s used in roles for the collections you want to protect. You could then optimize the rules by including the users&#8217; roles as an attribute in their authentication token – but I&#8217;ll save that for a future post!</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/how-to-create-dynamic-custom-roles-with-mongodb-stitch/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>Replace tedious coding with MongoDB Stitch and public APIs</title>
		<link>/mongodb/replace-tedious-coding-with-mongodb-stitch-and-public-apis</link>
					<comments>/mongodb/replace-tedious-coding-with-mongodb-stitch-and-public-apis#respond</comments>
		
		<dc:creator><![CDATA[andrew]]></dc:creator>
		<pubDate>Mon, 14 Jan 2019 13:37:07 +0000</pubDate>
				<category><![CDATA[MongoDB]]></category>
		<category><![CDATA[mongodb]]></category>
		<category><![CDATA[MongoDB Stitch]]></category>
		<category><![CDATA[rest api]]></category>
		<guid isPermaLink="false">/?p=4561</guid>

					<description><![CDATA[Most apps and websites contain much functionality that&#8217;s tedious to implement and has been done thousands of times before. MongoDB Stitch takes care of a lot of these chores – for example, making it simple to interact with third-party APIs. This post explains how I used Stitch to do just that that this week. I]]></description>
										<content:encoded><![CDATA[<p>Most apps and websites contain much functionality that&#8217;s tedious to implement and has been done thousands of times before. <a href="https://docs.mongodb.com/stitch/" title="MongoDB Stitch serverless platform">MongoDB Stitch</a> takes care of a lot of these <a href="https://www.mongodb.com/blog/post/mongodb-stitch--saving-developers-from-chores?jmp=blog" title="MongoDB Stitch – saving developers from chores">chores</a> – for example, making it simple to interact with third-party APIs. This post explains how I used Stitch to do just that that this week.</p>
<p>I recently described how I <a href="https://www.mongodb.com/blog/post/taking-an-existing-website-serverless-with-mongodb-stitch-hosting?jmp=blog" title="From Legacy Website to Serverless with MongoDB Stitch Hosting">ported my legacy website to Stitch</a>. After reading that post, one of our Paris Solution Architects spotted that there was a bug in how I was validating phone numbers in my forms (specific to France&#8217;s dialling plan). I was about to go into my code to tweak the regular expressions to cope with French phone numbers. However, what if there was another country with odd rules? What if the rules changed?</p>
<p>It then struck me that this is precisely the kind of chore that I should use Stitch to replace – being an expert in regular expressions and country-specific dialling plans wasn&#8217;t going to make the experience any better for my users, and so I should contract it out to &#8220;someone&#8221; else.</p>
<p>A quick Google later, and I&#8217;d settled on the <a href="https://numverify.com/">NumVerify service</a> which provides an API to validate phone numbers and add some extra information such as the type of line and the same number in full international format.</p>
<p>To access the NumVerify API, I needed to create a Stitch <a href="https://docs.mongodb.com/stitch/services/http/" title="The Stitch HTTP Service is a generic interface that enables you to communicate with any service that is available over HTTP, such as those that provide a REST API">HTTP service</a>. I named the service <code>apiplayer.net</code> and created a rule to allow the service to access the required domain (<code>apiplayer.net</code>) using <code>GET</code> requests:</p>
<p><img decoding="async" src="https://webassets.mongodb.com/_com_assets/cms/Stitch_http_service_rule-5ghtmajuru.png" alt="Creating an HTTP Service rule in MongoDB Stitch to access REST APIs" /></p>
<p>Then I can call use that service from a new <a href="https://docs.mongodb.com/stitch/functions/define-a-function/" title="MongoDB Stitch Functions allow you to define and execute server-side logic for your application">Stitch Function</a> (<code>verifyPhoneNumber</code>):</p>
<pre><code class="js">exports = function(phoneNumber){
  const APIKey = context.values.get("numverifyAPIKey");
  const http = context.services.get("numverify");
  const url = "http://apilayer.net/api/validate?access_key=" + APIKey + "&amp;number=" + phoneNumber + "&amp;country_code=&amp;format=1";
  var validationResults;

  return http.get({"url": url})
  .then((resp) =&gt; {
      const result = EJSON.parse(resp.body.text());
      if (result.valid) {
        console.log(result.international_format);
        return result;
      } else {
        console.log(result.number + " is not a valid phone number");
        return {valid: false};
      }
    },
    (error) =&gt; {
      console.log("Verification failed: " + error);
      return {valid: false};
    }
  );
};
</code></pre>
<p>Note that <code>numverifyAPIKey</code> is a <a href="https://docs.mongodb.com/stitch/values/" title="Values are named constants that you can use in MongoDB Stitch functions and rules">Stitch Value</a> that I&#8217;ve set to the API key I received when registering with NumVerify.</p>
<p>A typical (successful) result from this function looks like:</p>
<pre><code class="js">{
  "valid": true,
  "number": "448449808001",
  "local_format": "08449808001",
  "international_format": "+448449808001",
  "country_prefix": "+44",
  "country_code": "GB",
  "country_name": "United Kingdom of Great Britain and North",
  "location": "",
  "carrier": "",
  "line_type": "special_services"
}
</code></pre>
<p>The JavaScript running in the browser now executes the Stitch Function:</p>
<pre><code class="js">function validatePhone (inputField, helpText) {
  return new Promise(function(resolve, reject) {
    if (!validateNonEmpty (inputField, helpText)) {resolve(false)} else {
      const client = stitch.Stitch.defaultAppClient;
      client.callFunction("verifyPhoneNumber", [inputField.value]).then(
      result =&gt; {
        if (result.valid) {
          inputField.value = result.international_format;
          resolve(true);
        } else {
          helpText.innerHTML = 
            '&lt;span class="english_material" lang="en"&gt;Phone number is invalid."&lt;/span&gt;\
             &lt;span class="french_material" lang="fr"&gt;Le numéro de téléphone est invalide.&lt;/span&gt;';
             resolve(false);
        }
      }),(
      error =&gt; {
        helpText.innerHTML = 
          '&lt;span class="english_material" lang="en"&gt;Phone number validation failed, but you can submit anyway."&lt;/span&gt;\
           &lt;span class="french_material" lang="fr"&gt;La validation du numéro de téléphone a échoué, mais vous pouvez quand même soumettre.&lt;/span&gt;';
        // Not going to reject the form request just because the cloud service
        // is unavailable
        resolve(true);
      });
    }
  })   
}
</code></pre>
<p>NumVerify is as flexible as possible in accepting phone numbers in different formats. It also sets the resulting <code>international_format</code> field to a fully formatted international number – I use that to replace the user-provided number in the form, ensuring that all numbers stored in Atlas are in the same format. In one swoop, I&#8217;ve ripped out my spaghetti regular expression code, made the validations more robust, and added a new feature (normalizing the phone numbers before I store them) – result!</p>
<p>See the results at <a href="https://stitch.oleronvilla.com/">stitch.oleronvilla.com</a>, but please don&#8217;t judge my code, I still need to delegate a lot more to Stitch and other services!</p>
<p>Creating your first Stitch app? Start with one of the <a href="https://docs.mongodb.com/stitch/tutorials/" title="MongoDB Stitch serverless platform – tutorials">Stitch tutorials</a>.</p>
<p>Want to learn more about MongoDB Stitch? Read the <a href="https://www.mongodb.com/collateral/mongodb-stitch-serverless-platform?jmp=blog" title="MongoDB Stitch serverless platform architecture white paper">white paper</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/mongodb/replace-tedious-coding-with-mongodb-stitch-and-public-apis/feed</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
